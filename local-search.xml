<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>x86保护模式day12</title>
    <link href="/2022/09/28/22-0928-01/"/>
    <url>/2022/09/28/22-0928-01/</url>
    
    <content type="html"><![CDATA[<p>在没有操作系统情况下，可以认为进程就是任务。（任务就是一段在处理器上运行的程序，相当于脱离了操作系统，你写的代码在CPU上运行）</p><p>在有了操作系统后，整个程序可以分为用户程序和操作系统内核程序，即任务被分成了两个部分，全局地址空间和局部地址空间，也就说一个是用户态，一个是内核态。</p><p>由于内核程序位于0特权级，用户程序位于3特权级，所以一个任务按照特权级划分实际上被分为了两个部分，一个是3特权级的用户程序，另一个就是0特权级的内核</p><p>任务是处理器执行的，<u>任务在特权级变化时，本质就是处理器当前的特权级变化</u>，比如：用户程序是3特权级，但是我们需要调用一些系统的服务，系统内核的代码是0特权级，这时候就需要从3特权级变成0特权级，这里就涉及到了特权级的变换。</p><p>其中特权级的变化涉及到了栈的问题，因为处理器规定了在不同特权级下要用不同特权级的栈。有4种等级的栈，0、1、2、3特权级的栈。比如：当前的任务在3特权级，即CPL&#x3D;3，就只能用3特权级的栈，当任务的当前特权级切换到0特权级，就只能用0特权级的栈了。</p><p>所有说一个任务最多有4个栈（0、1、2、3特权级的栈），一个TSS代表一个任务（TSS就是任务的身份证），每个任务最多有4个栈。</p><p>在如下任务的结构图中，该任务为3特权级，只有3个栈（0、1、2特权级的栈），不需要3特权级的栈，因为<u>特权级的转移只能由低特权级到高特权级转移</u>，所以3特权级的任务可以转移到0、1、2特权级。</p><img src="/2022/09/28/22-0928-01/image-20220928164518415.png" class="" title="image-20220928164518415"> <h1 id="特权转移"><a href="#特权转移" class="headerlink" title="特权转移"></a>特权转移</h1><p>特权转移分为两类：一类是通过依从代码段或门手段实现低特权级向高特权级转移（低—&gt;高），另一类是则相反，是由调用返回指令从高特权级回到低特权级（高—&gt;低，唯一一种特殊情况，是唯一一种让处理器降低特权级的情况）。</p><ul><li><p>对于第一类（低—&gt;高），由于处理器不知道目标特权级（高特权级）对应的栈地址在哪里，所以就需要在某个地方记录下目标（高特权级）栈的地址，当处理器向高特权级转移时，再取出来加载到SS、ESP寄存器来更新栈。</p><p>上面说的记录目标栈地址的地方如下</p><img src="/2022/09/28/22-0928-01/image-20220928171810584.png" class="" title="image-20220928171810584"><p>低特权级向高特权级的转移叫 “向内转移” </p><img src="/2022/09/28/22-0928-01/image-20220928192622598.png" class="" title="image-20220928192622598"></li><li><p>对于第二类，由高特权级返回到低特权级的情况下，处理器是不需要在TSS中寻找低特权栈的。</p></li></ul><h1 id="CPL、RPL、DPL"><a href="#CPL、RPL、DPL" class="headerlink" title="CPL、RPL、DPL"></a>CPL、RPL、DPL</h1><blockquote><p>RPL、CPL、DPL在前面的学习中都已经接触过了，这里再来复习和总结下</p></blockquote><h2 id="CPL"><a href="#CPL" class="headerlink" title="CPL"></a>CPL</h2><p>CPL是当前进程的权限级别，是当前正在执行的代码所在的段的特权级，存在于cs寄存器的低两位。也就是说，CPL标识了代码能够达到的最高的特权级别。</p><img src="/2022/09/28/22-0928-01/image-20220928210611366.png" class="" title="image-20220928210611366"><h2 id="RPL"><a href="#RPL" class="headerlink" title="RPL"></a>RPL</h2><p>RPL，即请求特权级， “请求” 本身就是一个动词，只有具备能动性的访问者才能作出动作，那么谁是访问者呢 ？？？</p><p>在计算机中具有能动性的就是计算机指令，只有指令才具备访问、请求其它资源的能力，<u>指令访问其它资源的能力等级叫做请求特权级</u>。</p><p>指令都是放在代码段中的，代码段寄存器CS中选择子RPL表示代码请求别人资源能力的等级，CS和EIP指向的指令便是当前处理器中正在运行的代码，所以位于CS寄存器中选择子的低2位的值不仅称之为请求特权级，还称为处理器的当前特权级，即 CPL &#x3D; CS.RPL</p><img src="/2022/09/28/22-0928-01/image-20220928221440849.png" class="" title="image-20220928221440849"><h2 id="DPL"><a href="#DPL" class="headerlink" title="DPL"></a>DPL</h2><p>DPL存储在段描述符中，规定访问该段的权限级别，每个段的DPL固定。当进程访问一个段时，需要进程特权级检查，一般要求DPL &gt;&#x3D; max {CPL, RPL}，即级别至少要相同才能通过检查。</p><p>注意：DPL是描述符中的属性，每个段都有</p><h2 id="扩展：CPL、RPL、RPL的联系是啥，CPL和RPL总是相同的吗-？？？"><a href="#扩展：CPL、RPL、RPL的联系是啥，CPL和RPL总是相同的吗-？？？" class="headerlink" title="扩展：CPL、RPL、RPL的联系是啥，CPL和RPL总是相同的吗 ？？？"></a>扩展：CPL、RPL、RPL的联系是啥，CPL和RPL总是相同的吗 ？？？</h2><blockquote><p>参考：<a href="https://blog.csdn.net/better0332/article/details/3416749">https://blog.csdn.net/better0332/article/details/3416749</a></p></blockquote><p>打一个比方，中国官员分为6级国家主席1、总理2、省长3、市长4、县长5、乡长6，假设我是当前进程，级别总理（CPL&#x3D;2）,我去聊城市(DPL&#x3D;4)考察(呵呵),我用省长的级别(RPL&#x3D;3 这样也能吓死他们:-))去访问,可以吧，如果我用县长的级别，人家就不理咱了(你看看电视上的微服私访，呵呵)，明白了吧！为什么采用RPL，是考虑到安全的问题，就好像你明明对一个文件用有写权限，为什么用只读打开它呢，还不是为了安全！</p><h1 id="依从代码段（一致性代码段）"><a href="#依从代码段（一致性代码段）" class="headerlink" title="依从代码段（一致性代码段）"></a>依从代码段（一致性代码段）</h1><blockquote><p>内存分为数据段和代码段，栈段则看作特殊的数据段</p></blockquote><p>计算机中的被访问者（受访者）可能是数据（DATA）或者代码（CODE），但是访问者一定是代码，因为只有指令才具有访问资源的能力，访问者也就是代码段中的指令。</p><p>注意：对于受访者为代码段，实际上是指处理器从当前运行的代码段转移到受访者这个目标代码段上去执行，而不是把该目标代码段当作数据一样来访问。</p><p>代码段的特权级检查是很严格的。一般来说，控制转移只允许发生在两个特权级相同的代码段之间。受访者为代码段时，访问者必须和受访者特权级相同，否则CPU不允许访问者访问受访者。</p><p>为了让访问者访问（调用）比自己特权级高的代码段，CPU也提供了相对应的解决方法，即将受访者代码段（高特权级）定义为依从的。</p><p>那么如何将代码段定义为依从的呢 ？？？</p><p>代码段Type字段如下：（在day7中学习过）</p><img src="/2022/09/28/22-0928-01/image-20220927160305259.png" class="" title="image-20220927160305259"><ul><li>如果C&#x3D;0，这样受访者代码段只能供同特权级的访问者访问（调用）</li><li>如果C&#x3D;1，则这样的代码段称为<u>依从的代码段</u>，受访者（高特权级）可以被低特权级的访问者访问</li></ul><p>但是，低特权级的访问者来访问高特权级的依从代码段时（即将CPU的控制权从低特权级的访问者转移到依从代码段上），也是有条件的，要求当前特权级CPL ≤ 依从代码段描述符DPL的特权级，在数值上有如下关系：</p><div class="code-wrapper"><pre><code class="hljs txt">处理器当前特权级CPL ≥ 依从码段描述符的DPL</code></pre></div><br/><br/><br/><p><a href="https://blog.csdn.net/weixin_44309300/article/details/115371605">https://blog.csdn.net/weixin_44309300/article/details/115371605</a></p><br/><p>举个例子，如果一个依从的代码段，其描述符的DPL为1，则只有特权级为1、2、3的程序可以调用，而特权级为0的程序则不能。<u>在任何时候，都不允许将控制从较高的特权级转移到较低的特权级</u>。</p><p>依从的代码段不是在它的DPL特权级上运行，而是在调用程序的特权级上运行。就是说，当控制转移到依从的代码段上执行时，不改变当前特权级CPL，段寄存器CS的CPL字段不发生变化，被调用过程的特权级依从于调用者的特权级，这就是为什么它被称为 “依从” 代码段。</p><h5 id="门描述符"><a href="#门描述符" class="headerlink" title="门描述符"></a>门描述符</h5><p>除了依从的代码段，另一种在特权级之间的转移控制方法是使用门。门是另一种形式的描述符，称为门描述符，简称门。</p><p>和段描述符不同，段描述符用于描述内存段，<u>门描述符则用于描述可执行的代码，比如：一段程序、一个过程（例程）或者一个任务</u>。</p><p>实际上，根据不同的用途，门的类型有好几种，如下：</p><ul><li>调用门：不同特权级之间的过程调用可以使用调用门</li><li>中断门&#x2F;陷阱门：中断门&#x2F;陷阱门是作为中断处理过程使用的</li><li>任务门：任务门对应着单个的任务，用来执行任务切换</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>x86保护模式day11</title>
    <link href="/2022/09/23/22-0923-01/"/>
    <url>/2022/09/23/22-0923-01/</url>
    
    <content type="html"><![CDATA[<p>在保护模式下，通过将内存分成大小不等的段，并用描述符对每个段的用途、类型和长度进行指定，就可以在程序运行时由处理器硬件施加访问保护。比如，当程序试图让处理器去写一个可执行的代码段时，处理器就会阻止这种企图；再比如，当程序试图让处理器访问超过段界限的内存域时，处理器也会引发异常中断。</p><p>段保护是处理器提供的基本保护功能，但对于现实的需求来说，仍是不够的。</p><p>首先，当一个程序老老实实地访问只属于它自己的段时，基本的段保护机制是很有效的，但是，一个失控的程序，或者一个恶意的程序，依然可以通过追踪和修改描述符表来达到它们访问任何内存位置的目的。比如说，如果用户程序知道GDT的位置，它可以通过向段寄存器加载操作系统的数据段描述符，或者在GDT中增加一个指向操作系统数据区的描述符，来修改只属于操作系统的私有数据。对于处理器那种和3岁小孩相仿的智力，所有这一切都是合法的。</p><p>其次，32位处理器是为多任务系统而设计的（任务是一个抽象的一般性术语，指由软件完成的一个活动）。所谓多任务系统，是指能够同时执行两个以上程序的系统，即使前面一个系统没有执行完成，其他程序也可以执行。在单处理器（核）的系统中，多个程序并不可能真正的同时执行，但是，处理器可以在多个任务之间周期性地切换和轮转。这样，它们都处于走走停停的状态，快速的处理器加上高效的任务切换，在外界看来，多个任务都在同时运行中。</p><p>多任务系统，对任务之间的隔离和保护，以及任务和操作系统之间的隔离和保护都提出了要求，这可以看做对段保护机制的进一步强化。同时，在多任务系统中，操作系统居于核心软件的位置，为各个任务服务，负责任务的加载、创建和执行环境管理，并执行任务之间的调度，对操作系统的保护显得尤为重要。事实上，对于这种要求，基本的段保护机制已经无能为力了，所以引入了特权级别。</p><h1 id="任务的隔离和特权级保护"><a href="#任务的隔离和特权级保护" class="headerlink" title="任务的隔离和特权级保护"></a>任务的隔离和特权级保护</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>程序是记录在载体上的指令和数据，总是为了完成某个特定的工作，其正在执行中的一个副本，叫做任务。这句话的意思是说，如果一个程序有多个副本正在内存中运行，那么，它对应这一个任务，每一个副本都是一个任务。</p><h2 id="任务的LDT、TSS"><a href="#任务的LDT、TSS" class="headerlink" title="任务的LDT、TSS"></a>任务的LDT、TSS</h2><p>一直以来，我们把所有的段描述符都放在GDT中，而不管它属于内核还是用户程序。在多任务系统中，为了有效的在任务之间实施隔离，处理器建议每个任务都应该有自己的描述符表——局部描述符表LDT，把自己专属的段放到LDT中。</p><p>和GDT一样，LDT也是用来存放描述符的。不同之处在于，LDT只属于某个任务。或者说，每个任务都有自己的LDT，每个任务私有的段，都应当在LDT中进行描述。另外，LDT的第一个描述符，也就是0号槽位，也是有效的，可以使用的。</p><p>为了追踪全局描述符表（GDT），访问它的内部描述符，处理器使用了GDTR寄存器（GDTR寄存器用于存放GDT的线性基地址和界限），这是可以理解的，正如其名称所暗示的那样，全局描述符表（GDT）是全局性的，为所有任务服务，是它们所共有的，我们只需要一个全局描述符表（GDT）就够了</p><p>和GDT不同，局部描述符表（LDT）的数量则不止一个，具体有多少，视任务的多少而定。为了追踪和访问这些LDT，处理器使用了局部描述符表寄存器（LDTR）。</p><img src="/2022/09/23/22-0923-01/image-20220926180128425.png" class="" title="image-20220926180128425"><p>在一个多任务的系统中，会有很多任务在轮流执行，正在执行的那个任务，称之为当前任务。因为LDTR寄存器只有一个，所以，它只用于指向当前任务的LDT。每当有任务切换时，LDTR的内容被更新，以指向新任务的LDT，和GDTR一样，LDTR包含了32位线性基地址字段和16位段界限字段，以指示当前LDT的位置和大小。</p><p>在一个多任务的环境中，当任务发生切换时，必须保护旧任务的运行状态，或者说是保护现场，保护的内容包括通用寄存器、段寄存器、栈指针寄存器ESP、指令指针寄存器EIP、状态寄存器EFLAGS，等等。否则的话，等下次该任务又恢复执行时，一切都变得茫然而毫无头绪。</p><p>为了保存任务的状态，并在下次重新执行的时恢复它们，每个任务都应当用一个额外的内存区域保存相关信息，这叫做任务状态段（Task State segment，TSS），TSS具有固定的格式，最小尺寸必须是104字节。处理器固件能够识别TSS中的每个元素，并在任务切换的时候读取其中的信息</p><p>和LDT一样，处理器用TR寄存器来指向当前任务的TSS。和GDTR、LDTR一样，TR寄存器在处理器中也是只有一个，当任务发生切换的时候，TR寄存器的内容也会跟着指向新任务的TSS。这个过程是这样的：<u>首先，处理器将当前任务的现场信息保存到由TR寄存器指向的TSS，然后，再使TR寄存器指向新任务的TSS，并从新任务的TSS中恢复现场</u>。</p><blockquote><p>为啥叫TR，而不叫TSSR呢 ？？？</p></blockquote><p>因为TSS是一个任务存在的标志，用于区别一个任务和其他任务，所以这个寄存器叫任务寄存器（Task Register，TR）</p><blockquote><p>TSS的结构如下图：</p></blockquote><img src="/2022/09/23/22-0923-01/image-20220926184228202.png" class="" title="image-20220926184228202"><h2 id="全局空间和局部空间"><a href="#全局空间和局部空间" class="headerlink" title="全局空间和局部空间"></a>全局空间和局部空间</h2><p>在多任务系统中，操作系统肩负着任务的创建，以及在任务之间调度和切换的工作。不过，更为繁重和基础的工作是对处理器、设备及存储器的管理。</p><p>从程序编写者角度看，操作系统是他们可信赖的朋友。首先，他们不必关心自己程序是如何加载到内存并开始运行的，操作系统自然会处理好这些事情；其次，对设备的访问涉及大量的硬件细节，而且极为繁琐，操作系统能够肩负起设备管理的职责，并提供了大量的例程和数据供应用程序调用。使用操作系统提供的这些服务，可以极大的简化程序的编写，并能够在访问设备时消除潜在的竞争和冲突。</p><p>比如说，当中断发生时，不可能由某个任务来进行处理，而只能由操作系统来提供中断处理过程，并采取适当的操作，以进行一些和所有任务都有关系的全局性管理工作，如空闲内存的查找和分配、回收已终止任务的内存空间、设备访问的排队和调度，等等。</p><p>这就是说，每个任务实际上包含两个部分：全局部分和私有部分。</p><ul><li>全局部分：全局部分是所有任务共有的，含有操作系统的软件和库程序，以及可以调用的系统服务和数据。</li><li>私有部分：私有部分则是每个任务各自的数据和代码，与任务所要解决的具体问题有关，彼此并不相同。</li></ul><img src="/2022/09/23/22-0923-01/image-20220926210619946.png" class="" title="image-20220926210619946"><p>任务实际是在内存中运行的，所以，所谓的全局部分和私有部分，其实是地址空间的划分，即全局地址空间和局部地址空间，简称全局空间和局部空间。</p><p>地址空间的访问是依靠分段机制来进行的。具体的说，需要在描述符表中定义各个段的描述符，然后再通过描述符来访问它们。因此，全局地址空间是用全局描述符表（GDT）来指定的，而局部地址空间则是由每个任务私有的局部描述符（LDT）来定义的。</p><p>从程序员的角度来看，任务的全局空间包含了操作系统的段，是由别人编写的，但是他可以调用这些段的代码，或者获取这些段中的数据；任务局部空间的内容是由程序员自己创建的。通常，任务会在自己的局部空间运行，当它需要操作系统提供服务时，转入全局空间执行。</p><p>我们知道，段寄存器（CS、SS、DS、ES、FS、GS）由16位的选择器和不可见的描述符高速缓存器组成。选择器的 位2 是表示指示器TI</p><ul><li>若 TI &#x3D;0，指向GDT，表示当前正在访问的段描述符位于GDT中</li><li>否则指向LDT，表示当前正在访问的描述符位于LDT中。</li></ul><h2 id="虚拟内存管理的一般方法"><a href="#虚拟内存管理的一般方法" class="headerlink" title="虚拟内存管理的一般方法"></a>虚拟内存管理的一般方法</h2><p>选择器的高13位指定描述符的索引号，也就是描述符表中的编号，从0开始。每个段描述符都对应着一个内存段。很显然，在一个任务的全局地址空间上，可以划分出 2的13次方 个段，即8192个段。因为GDT的0号描述符不能用，故实际上是8191个段，但这无关紧要。又因为段内偏移是32位的，段的最大长度为4GB（2的32次方），因此，一个任务的全局地址空间，其总大小为 2的13次方 × 2的32次方 &#x3D; 2的45次方 字节（即32TB）</p><p>同理，局部描述符表LDT可以定义 2的13次方个，即8192个描述符，每个段最大长度也是4GB，故一个任务局部地址空间同样也是32TB。</p><p>这样一来，每个任务的总地址空间即为 32TB+32TB&#x3D;64TB。在一个只有32根地址线的处理器上，无论如何也不可能提供这么巨大的存储空间。但是不要紧张，这只是虚假的，或者说虚拟的空间。操作系统允许程序的编写者使用该地址空间来写程序，即使用虚拟地址或者逻辑地址来访问内存，就像处理器真的拥有这么巨大的地址空间一样。</p><p>上面的一段话可以理解为：编译器不考虑处理器可寻址空间的大小，也不考虑物理内存的大小，它只是负责编译程序。当程序编译时，编译器允许生成非常巨大的程序。但是，当程序超出了物理内存的大小，或者操作系统无法分配这么大的物理空间时，怎么办呢 ？？？</p><p>同一块物理内存，可以让多个任务，或者每个任务的不同段来使用。当执行或访问一个新的段时，如果它不在物理内存中，而且也没有空闲的物理内存来加载它，那么，操作系统将挑出一个暂时用不到的段，把它换出到磁盘中，并把那个腾出来的空间分配给马上要访问的段，并修改段的描述符，使之指向这段内存空间。下一次，当被换出的那个段马上又用到时，再按相同的办法换到物理内存。所有这一切，任务和程序的编写者是不必关心的，这就是虚拟内存管理的一般方法。</p><h2 id="特权级保护概述"><a href="#特权级保护概述" class="headerlink" title="特权级保护概述"></a>特权级保护概述</h2><p>前面引入了LDT、TSS，这只是从任务层面上进一步强化了分段机制，从安全保障的角度来看，只相当于构建了可靠的硬件设施。</p><p>当然，仅有设施是不够的，还需要规章制度，还要有人来执行，处理器也一样。为此，在分段机制的基础上，处理器引入了特权级，并由固件负责实施特权级保护。</p><p>Intel处理器可以识别4个特权级别，0~3，较大的数值意味着较低的特权级别，如下图，这是Intel处理器提供的4级环状保护结构。</p><img src="/2022/09/23/22-0923-01/image-20220926224029735.png" class="" title="image-20220926224029735">                                             <ul><li><p>特权级0</p><p>因为操作系统是为所有程序服务的，可靠性最高，而且必须对软硬件有完全的控制权，所以它的主体部分必须拥有特权级0，并处于整个环形结构的中心。也正是因为这样，操作系统的主体部分通常又被称做内核（Kernel、Core）</p></li><li><p>特权级1、2</p><p>特权级1和2通常赋予哪些可靠性不如内核的系统服务程序，比较典型就是设备驱动程序。当然，在很多比较流行的操作系统中，驱动与内核的特权级相同，都是0。</p></li><li><p>特权级3</p><p>应用程序的可靠性被视为最低的，而且通常不需要直接访问硬件和一些敏感的系统资源，调用设备驱动程序或者操作系统例程就能完成绝大多数工作，故赋予它们最低的特权级3</p></li></ul><h3 id="实施特权级保护"><a href="#实施特权级保护" class="headerlink" title="实施特权级保护"></a>实施特权级保护</h3><ul><li><p>实施特权级保护第一步是为所有可管理的对象赋予一个特权级，以决定谁能访问它们。</p><p>在day7的学习中，我们学习过DPL位，如下：</p><img src="/2022/09/23/22-0923-01/image-20220926231858720.png" class="" title="image-20220926231858720"><p>DPL字段的取值可以为 00、01、10、11，分别对应着特权级 0、1、2、3</p><p>DPL是每个描述符都有的字段，所以又称为描述符特权级</p><p>描述符总是指向它所描述的目标对象，代表着该对象，因此，DPL字段实际上是目标对象的特权级</p><p>比如：对于数据段来说，DPL决定了它们所应当具备的最低特权级别。如果有一个数据段，其描述符的DPL字段为2，那么，只有特权级别为0、1、2的程序才能访问它。当一个特权级别为3的程序也去读写该段时，将会被处理器阻止，并引发异常中断。对任何段的访问都要先把它的描述符加载到段寄存器，所以这种保护手段很容易实现。</p><p>这里注意：32位处理器的段寄存器，实际是由16位的段选择器和描述符高速缓存器组成，而后者是不能直接访问的。正因为我们接触不到描述符高速缓存器，所以为了方便，以后提到段寄存器时，一般指的就是段选择器。</p></li><li><p>在实模式下，段寄存器放的是段地址； 而在保护模式下，段寄存器存放的是段选择子，段地址则位于描述符高速缓存器中。<u>当处理器正在一个<strong>代码段</strong>中取指令和执行指令时，那个代码段的特权级叫做当前特权级（CPL）</u>。正在执行的这个代码段，其选择子位于段寄存器CS中，其最低2位就是当前特权级的数值。</p></li><li><p>一般来说，操作系统都是从BIOS那里接管处理器控制权的，进入保护模式的工作也是由它做的，而且，最重要的是，它还肩负着整个计算机系统的管理工作，所以操作系统必须在0特权级别上，而当操作系统的代码在执行时，当前特权级CPL就是0。</p><p>相反，普通应用程序则工作在特权级别3上。没有人愿意将自己的程序放在特权级3上，但是，只要你在某个操作系统上写的程序，这就由不得你。我们在操作系统上编写应用时，不需要考虑GDT、LDT、分段、描述符这些东西，它们是在程序加载时，由操作系统负责创建的，而我们作为应用程序的编写者，只需要负责程序的具体功能就可以。应用程序的加载和开始执行，也是由操作系统所主导的，而操作系统一定会将应用程序放在特权级3上。当应用程序开始执行时，当前特权级CPL自然就是3。</p><p>这实际上就是把一个任务分成特权级截然不同的两部分，全局部分是特权级0的，而局部空间则是特权级别3的。这种划分是有好处的，全局空间是为所有任务服务的，其重要性不言而喻。为了保证它的安全性，并能够访问所有的硬件资源，应该使它拥有最高的特权级别。当任务在自己的局部空间内执行时，当前特权级 CPL 是 3，当它通过调用系统服务（Windows API），进入操作系统内核，在全局空间执行时，当前特权级 CPL 就变成了 0。总之，很重要的一点是，不能僵化的看待任务和任务的特权级别。</p></li></ul><h3 id="特权指令"><a href="#特权指令" class="headerlink" title="特权指令"></a>特权指令</h3><p>不同特权级别的程序，所担任的职责以及在系统中扮演的角色是不一样的。计算机系统的脆弱性在于一条指令就能改变它的整体运行状态，比如停机指令 hlt 和对控制寄存器 CR0 的写操作，像这样的指令只能由最高特权级别的程序来做。<u>因此，那些只有在当前特权级 CPL 为 0 时才能执行的指令，称为特权指令。</u> </p><p>典型的特权级指令包括：加载全局描述符表的 lgdt （在实模式下也可执行）、加载局部描述符表的指令 lldt、加载任务寄存器的指令 ltr、读写控制寄存器的 mov 指令、停机指令 hlt 等十几条指令。</p><h3 id="I-x2F-O特权级"><a href="#I-x2F-O特权级" class="headerlink" title="I&#x2F;O特权级"></a>I&#x2F;O特权级</h3><p>除了那些特权级敏感的指令外，处理器还允许对各个特权级别所能执行的 I&#x2F;O 操作进行控制。通常，这指的是端口访问的许可权，因为对设备的访问都是通过端口进行的。</p><p>如下图，在处理器的标志寄存器 EFLAGS 中，位13、位12是 IOPL 位，也就是输入&#x2F;输出特权级，它代表着当前任务的 I&#x2F;O 特权级别</p><img src="/2022/09/23/22-0923-01/image-20220927090506389.png" class="" title="image-20220927090506389"><p>任务是由操作系统加载和创建的，与任务相关的信息都在它在自己的任务状态段（TSS）中，其中就包括一个 EFLAGS 寄存器副本，用于指示与当前任务相关的机器状态，比如：他自己的 I&#x2F;O 特权级 IOPL。在多任务系统中，随着任务的切换，前一个任务的所有状态被保存到它自己的TSS中，新任务的各种状态从其TSS中恢复，包括 EFLAGS 寄存器的值。</p><p>处理器不限制 0 特权级程序的 I&#x2F;O 访问，它总是允许的。但是，处理器可以限制低特权级程序的 I&#x2F;O 访问权限。这是很重要的，操作系统的功能之一是设备管理，它可不希望应用程序拥有私有访问外设的能力。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>x86保护模式day10</title>
    <link href="/2022/09/19/22-0919-01/"/>
    <url>/2022/09/19/22-0919-01/</url>
    
    <content type="html"><![CDATA[<blockquote><p>day10的笔记主要参考 “从实模式到保护模式” PDF中的第13章程序的动态加载和执行、网上资料</p><p>感觉day10讲的内容有点懵（基础不够扎实）</p><p>后续有时间再进行学习，先跳过</p></blockquote><p>计算机硬件之上为软件，而软件分为了两个层次，一个是操作系统，另一个就是普通的用户程序，普通的用户程序仅关心业务逻辑来解决实际问题，而软件是如何加载到内存中就是由操作系统来解决，而用户程序则是提供一些信息来帮助操作系统将软件加载到内存中</p><p>相反，操作系统则要考虑用什么方法来加载用户程序，并在适当的时候将处理器的执行流转移到用户代码中去。同时，为了减轻用户程序的工作量，操作系统还应当管理硬件，并提供大量的例程供用户程序使用。</p><p>操作系统不能放入硬盘的主引导扇区（因 为主引导扇区只有512个字节，而操作系统远大于512个字节），计算机从主引导程序开始执行，主引导程序会加载内核，然后再把控制权给内核，内核负责加载用户程序，并提供各种例程给用户程序调用，提供给用户程序调用的例程也叫应用程序接口（API）</p><p>任务：学习保护模式下的加载器，并模拟操作系统加载用户程序</p><img src="/2022/09/19/22-0919-01/image-20220922082141360.png" class="" title="image-20220922082141360"><h1 id="内核与操作系统"><a href="#内核与操作系统" class="headerlink" title="内核与操作系统"></a>内核与操作系统</h1><h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><h3 id="什么是内核"><a href="#什么是内核" class="headerlink" title="什么是内核"></a>什么是内核</h3><p><u>内核是操作系统的核心。内核是操作系统执行的第一道程序，被率先加载到内存中开始系统行为。</u>内核始终保持在主内存中直到系统被关闭。内核将用户输入的命令转换成计算机硬件能理解的机器语言。</p><p><u>内核是系统应用软件和硬件的桥梁。</u>内核直接与硬件联系，并告之它由应用软件发起的请求。操作系统不能脱离内核工作，内核是系统正常运行最重要的程序。</p><p>内核分为单核(Monolithic Kernel)和微核(Microkernel)两种。对于单核，所有操作系统服务运行在单核的主线程中，单核提供了对系统硬件的广泛访问。对于微核，其提供的是硬件抽象，意味着操作系统必须在系统调用(system calls)和原语(primitives)的帮助下工作。</p><h3 id="内核的作用"><a href="#内核的作用" class="headerlink" title="内核的作用"></a>内核的作用</h3><p>内核的主要职责是：进程管理、磁盘管理、任务调度、内存管理等，具体如下：</p><ul><li><p>文件管理</p><p>为了更有效地搜索和使用文件，内核使用文件系统(file system)来组织文件，并通过文件系统保持对文件数据存储、文件状态、访问设置的监视。</p></li><li><p>进程管理</p><p>在多进程环境下，内核决定哪一道进程被CPU优先运行，以及分配的运行时间片长度是多少，称为进程调度。当进程不再被需要的时候，将被内核自动销毁。</p></li><li><p>内存管理</p><p>内核检测内存空间——生成或销毁内存，以确保应用程序被正确执行。</p></li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h3><p>操作系统是用来管理计算机系统资源的软件，内核是用户和系统硬件的桥梁。操作系统提供的接口允许用户直接看到其输入命令的响应结果，例如Window的命令行cmd和Linux的Shell终端。没有操作系统，系统就不可能运行，部分嵌入式系统看似没有操作系统，但仍然对硬件作了一层简单封装，也可理解为Tiny OS。<u>操作系统的主要职责是创建应用软件可以运行的环境。</u></p><p>操作系统同样是运行在计算机系统中的持久化程序，直至系统关闭。<u>它是计算机系统运行的第一道程序，一旦操作系统被加载到内存，计算机就做好了执行用户程序的准备。</u></p><h3 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h3><p>在操作系统中，内核是最重要的程序。除了内核的职责外，操作系统额外负责安全性与隐私、中断与挂起等服务，具体如下：</p><ul><li><p>安全性</p><p>为了保护用户数据安全，操作系统对计算机进行了密码保护，保护程序不被非法途径泄露。</p></li><li><p>工作分析</p><p>操作系统跟踪资源的使用情况，这些分析数据可以用来监视、反映资源对特定用户或用户群体的利用率，便于系统调整。</p></li><li><p>与用户和其他软件合作</p><p>操作系统也向用户分配解释器、汇编、编译器和其他系统级软件，便于用户和其他应用调用接口。</p></li><li><p>控制系统性能</p><p>为控制系统性能，操作系统时刻监视其运行状态，最主要是测量应用发起服务接口请求，和系统返回响应之间的时间。在操作系统的帮助下，通过提供解决问题的关键性信息可以提供系统性能。</p></li><li><p>错误自检</p><p>操作系统密切监测系统漏洞来防止运行崩溃。</p></li><li><p>设备管理</p><p>操作系统保持对所有接入计算机的硬件设备的监视和跟踪，决定了每个外设是否可以访问计算机资源以及访问的允许时长是多少。</p></li></ul><h2 id="操作系统和内核的区别"><a href="#操作系统和内核的区别" class="headerlink" title="操作系统和内核的区别"></a>操作系统和内核的区别</h2><blockquote><p>内核+用户界面&#x3D;操作系统</p></blockquote><table><thead><tr><th>序号</th><th>内核</th><th>操作系统</th></tr></thead><tbody><tr><td>1</td><td>系统级软件，操作系统的一部分</td><td>系统级软件</td></tr><tr><td>2</td><td>应用软件和硬件的接口</td><td>用户和硬件的接口</td></tr><tr><td>3</td><td>运行操作系统必须具有内核</td><td>运行计算机系统必须有操作系统</td></tr><tr><td>4</td><td>分为单核和微核两种</td><td>分为分布式OS、实时OS、单核OS、微核OS、多处理OS</td></tr><tr><td>5</td><td>是操作系统执行的第一道程序</td><td>是计算机系统执行的第一道程序</td></tr><tr><td>6</td><td>主要负责进程管理、磁盘管理、任务调度、内存管理等核心任务</td><td>主要负责安全性与隐私、中断与挂起等其他任务</td></tr></tbody></table><h1 id="内核的结构、功能、加载"><a href="#内核的结构、功能、加载" class="headerlink" title="内核的结构、功能、加载"></a>内核的结构、功能、加载</h1><h2 id="内核的结构"><a href="#内核的结构" class="headerlink" title="内核的结构"></a>内核的结构</h2><p>内核的结构分为4个部分，分别是初始化代码、内核代码段、内核数据段和公共例程段。（注意：其中主引导程序也是初始化代码的组成部分）</p><ul><li><p>初始化代码（初始化代码大部分位于 硬盘主引导扇区代码c13.mbr.asm 中）</p><p>初始化代码用于从BIOS那里接管处理器和计算机硬件的控制权，安装最基本的段描述符，初始化最初的执行环境。然后，从硬盘上读取和加载内核的剩余部分，创建组成内核的各个内存段。</p></li><li><p>内核代码段</p><p>内核代码段用于分配内存，读取和加载用户程序，控制用户程序的执行</p></li><li><p>内核数据段</p><p>内核数据段提供了一段可读可写的内存空间，供内核自己使用</p></li><li><p>公共例程段</p><p>公共例程段用于提供各种用途和功能的子过程以简化代码的编写，这些例程既可以用于内核，也供用户程序调用。</p></li><li><p>内核代码段、内核数据段、公共例程段的代码位于 保护模式微型核心程序c13_core.asm 中（除了上述内容外，内核文件还包括一个头部，记录了各个段的汇编位置，这些统计数据用于告诉初始化代码如何加载内核）</p><img src="/2022/09/19/22-0919-01/image-20220921213915701.png" class="" title="image-20220921213915701"></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>逻辑地址、线性地址、物理地址、段基址、段基值区别</title>
    <link href="/2022/09/18/22-0918-01/"/>
    <url>/2022/09/18/22-0918-01/</url>
    
    <content type="html"><![CDATA[<img src="/2022/09/18/22-0918-01/image-20220918133508367.png" class="" title="image-20220918133508367"><h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><p>现代程序内部使用的都是逻辑地址，也就是段内偏移量。</p><h1 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h1><p>编译器编译程序时，会为程序生成代码段和数据段，然后将所有代码放到代码段中，将所有数据放到数据段中。最后程序中的每句代码和每条数据都会有自己的逻辑地址。</p><h1 id="线性地址"><a href="#线性地址" class="headerlink" title="线性地址"></a>线性地址</h1><p>CPU加载程序后，会为这个程序分配内存，所分配内存又分为代码段内存和数据段内存。代码段内存的基址保存在CS中，数据段内存的基址保存在DS中。</p><p>段基址+逻辑地址&#x3D;线性地址。</p><p>CPU实模式下，段基址表示的是内存段。而保护模式下段基地表示的是段描述表的selector。</p><h1 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h1><p>如果CPU没有分页机制，那么线性地址&#x3D;物理地址。</p><p>由于线性地址是连续，内存中可能没有这么大的一块连续空间。为了解决这个问题，CPU采用了分页的内存管理机制，每页4KB。</p><p>有了分页机制，线性地址必须通过转换才能变成物理地址。</p><h1 id="段基值、段基址、物理地址的区别："><a href="#段基值、段基址、物理地址的区别：" class="headerlink" title="段基值、段基址、物理地址的区别："></a>段基值、段基址、物理地址的区别：</h1><p>段基址（段地址、段基地址）&#x3D;段基值×10H，即 段基址&#x3D;段基值左移4位</p><p>物理地址（实际地址、绝对地址）&#x3D;段基值×10H+偏移地址&#x3D;段基址+偏移地址</p><p>需要注意的是：很多微机教材中没有介绍段基值，而是直接定义 物理地址&#x3D;段基址×10H+偏移地址，这是因为这类教材中认为段寄存器中的16位数就是段基址，而将段基址×10H定义为段的起始地址</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>x86保护模式day9</title>
    <link href="/2022/09/14/22-0914-01/"/>
    <url>/2022/09/14/22-0914-01/</url>
    
    <content type="html"><![CDATA[<h1 id="对内存段的保护"><a href="#对内存段的保护" class="headerlink" title="对内存段的保护"></a>对内存段的保护</h1><blockquote><p>处理器引入保护模式主要就是提供保护功能，其中非常重要的一部分就是对内存段的保护，也就是禁止程序的非法内存访问</p></blockquote><p>利用内存保护功能，可以实现虚拟内存管理，当处理器访问一个实际上不存在的段的时候，就会引发异常中断，然后操作系统会接管异常处理的过程，并用硬盘来进行段的换入和换出</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><blockquote><p>c12_mbr.asm代码如下：</p></blockquote><div class="code-wrapper"><pre><code class="hljs x86asm">         <span class="hljs-comment">;代码清单12-1</span>         <span class="hljs-comment">;文件名：c12_mbr.asm </span>         <span class="hljs-comment">;文件说明：硬盘主引导扇区代码 </span>         <span class="hljs-comment">;创建日期：2011-10-27 22:52</span>         <span class="hljs-comment">;设置堆栈段和栈指针 </span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">cs</span>               <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>,<span class="hljs-built_in">eax</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>,<span class="hljs-number">0x7c00</span>               <span class="hljs-comment">;计算GDT所在的逻辑段地址</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,[<span class="hljs-built_in">cs</span>:pgdt+<span class="hljs-number">0x7c00</span>+<span class="hljs-number">0x02</span>]      <span class="hljs-comment">;GDT的32位线性基地址 </span>         <span class="hljs-keyword">xor</span> <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">edx</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>,<span class="hljs-number">16</span>         <span class="hljs-keyword">div</span> <span class="hljs-built_in">ebx</span>                            <span class="hljs-comment">;分解成16位逻辑地址 </span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">eax</span>                         <span class="hljs-comment">;令DS指向该段以进行操作</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>,<span class="hljs-built_in">edx</span>                        <span class="hljs-comment">;段内起始偏移地址 </span>         <span class="hljs-comment">;创建0#描述符，它是空描述符，这是处理器的要求</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebx</span>+<span class="hljs-number">0x00</span>],<span class="hljs-number">0x00000000</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebx</span>+<span class="hljs-number">0x04</span>],<span class="hljs-number">0x00000000</span>           <span class="hljs-comment">;创建1#描述符，这是一个数据段，对应0~4GB的线性地址空间</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebx</span>+<span class="hljs-number">0x08</span>],<span class="hljs-number">0x0000ffff</span>    <span class="hljs-comment">;基地址为0，段界限为0xfffff</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebx</span>+<span class="hljs-number">0x0c</span>],<span class="hljs-number">0x00cf9200</span>    <span class="hljs-comment">;粒度为4KB，存储器段描述符 </span>         <span class="hljs-comment">;创建保护模式下初始代码段描述符</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebx</span>+<span class="hljs-number">0x10</span>],<span class="hljs-number">0x7c0001ff</span>    <span class="hljs-comment">;基地址为0x00007c00，512字节 </span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebx</span>+<span class="hljs-number">0x14</span>],<span class="hljs-number">0x00409800</span>    <span class="hljs-comment">;粒度为1个字节，代码段描述符 </span>         <span class="hljs-comment">;创建以上代码段的别名描述符</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebx</span>+<span class="hljs-number">0x18</span>],<span class="hljs-number">0x7c0001ff</span>    <span class="hljs-comment">;基地址为0x00007c00，512字节</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebx</span>+<span class="hljs-number">0x1c</span>],<span class="hljs-number">0x00409200</span>    <span class="hljs-comment">;粒度为1个字节，数据段描述符</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebx</span>+<span class="hljs-number">0x20</span>],<span class="hljs-number">0x7c00fffe</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebx</span>+<span class="hljs-number">0x24</span>],<span class="hljs-number">0x00cf9600</span>                  <span class="hljs-comment">;初始化描述符表寄存器GDTR</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> [<span class="hljs-built_in">cs</span>: pgdt+<span class="hljs-number">0x7c00</span>],<span class="hljs-number">39</span>      <span class="hljs-comment">;描述符表的界限   </span>          <span class="hljs-keyword">lgdt</span> [<span class="hljs-built_in">cs</span>: pgdt+<span class="hljs-number">0x7c00</span>]               <span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0x92</span>                         <span class="hljs-comment">;南桥芯片内的端口 </span>         <span class="hljs-keyword">or</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0000_0010B</span>         <span class="hljs-keyword">out</span> <span class="hljs-number">0x92</span>,<span class="hljs-built_in">al</span>                        <span class="hljs-comment">;打开A20</span>         <span class="hljs-keyword">cli</span>                                <span class="hljs-comment">;中断机制尚未工作</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">cr0</span>         <span class="hljs-keyword">or</span> <span class="hljs-built_in">eax</span>,<span class="hljs-number">1</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cr0</span>,<span class="hljs-built_in">eax</span>                        <span class="hljs-comment">;设置PE位</span>               <span class="hljs-comment">;以下进入保护模式... ...</span>         <span class="hljs-keyword">jmp</span> <span class="hljs-built_in">dword</span> <span class="hljs-number">0x0010</span>:flush             <span class="hljs-comment">;16位的描述符选择子：32位偏移</span>                                                      [<span class="hljs-meta">bits</span> <span class="hljs-number">32</span>]                          <span class="hljs-symbol">  flush:</span>                                              <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-number">0x0018</span>                               <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">eax</span>               <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-number">0x0008</span>                     <span class="hljs-comment">;加载数据段(0..4GB)选择子</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">eax</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">fs</span>,<span class="hljs-built_in">eax</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">gs</span>,<span class="hljs-built_in">eax</span>               <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-number">0x0020</span>                     <span class="hljs-comment">;0000 0000 0010 0000</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>,<span class="hljs-built_in">eax</span>         <span class="hljs-keyword">xor</span> <span class="hljs-built_in">esp</span>,<span class="hljs-built_in">esp</span>                        <span class="hljs-comment">;ESP &lt;- 0</span>               <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">es</span>:<span class="hljs-number">0x0b8000</span>],<span class="hljs-number">0x072e0750</span> <span class="hljs-comment">;字符&#x27;P&#x27;、&#x27;.&#x27;及其显示属性</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">es</span>:<span class="hljs-number">0x0b8004</span>],<span class="hljs-number">0x072e074d</span> <span class="hljs-comment">;字符&#x27;M&#x27;、&#x27;.&#x27;及其显示属性</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">es</span>:<span class="hljs-number">0x0b8008</span>],<span class="hljs-number">0x07200720</span> <span class="hljs-comment">;两个空白字符及其显示属性</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">es</span>:<span class="hljs-number">0x0b800c</span>],<span class="hljs-number">0x076b076f</span> <span class="hljs-comment">;字符&#x27;o&#x27;、&#x27;k&#x27;及其显示属性</span>         <span class="hljs-comment">;开始冒泡排序 </span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>,pgdt-string-<span class="hljs-number">1</span>              <span class="hljs-comment">;遍历次数=串长度-1 </span>  @@<span class="hljs-number">1</span>:         <span class="hljs-keyword">push</span> <span class="hljs-built_in">ecx</span>                           <span class="hljs-comment">;32位模式下的loop使用ecx </span>         <span class="hljs-keyword">xor</span> <span class="hljs-built_in">bx</span>,<span class="hljs-built_in">bx</span>                          <span class="hljs-comment">;32位模式下，偏移量可以是16位，也可以 </span>  @@<span class="hljs-number">2</span>:                                      <span class="hljs-comment">;是后面的32位 </span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,[string+<span class="hljs-built_in">bx</span>]          <span class="hljs-keyword">cmp</span> <span class="hljs-number">ah</span>,<span class="hljs-built_in">al</span>                          <span class="hljs-comment">;ah中存放的是源字的高字节 </span>         <span class="hljs-keyword">jge</span> @@<span class="hljs-number">3</span>          <span class="hljs-keyword">xchg</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">ah</span>          <span class="hljs-keyword">mov</span> [string+<span class="hljs-built_in">bx</span>],<span class="hljs-built_in">ax</span>   @@<span class="hljs-number">3</span>:         <span class="hljs-keyword">inc</span> <span class="hljs-built_in">bx</span>          <span class="hljs-keyword">loop</span> @@<span class="hljs-number">2</span>          <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ecx</span>          <span class="hljs-keyword">loop</span> @@<span class="hljs-number">1</span>               <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>,pgdt-string         <span class="hljs-keyword">xor</span> <span class="hljs-built_in">ebx</span>,<span class="hljs-built_in">ebx</span>                        <span class="hljs-comment">;偏移地址是32位的情况 </span>  @@<span class="hljs-number">4</span>:                                      <span class="hljs-comment">;32位的偏移具有更大的灵活性</span>         <span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-number">0x07</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[string+<span class="hljs-built_in">ebx</span>]         <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">es</span>:<span class="hljs-number">0xb80a0</span>+<span class="hljs-built_in">ebx</span>*<span class="hljs-number">2</span>],<span class="hljs-built_in">ax</span>          <span class="hljs-comment">;演示0~4GB寻址。</span>         <span class="hljs-keyword">inc</span> <span class="hljs-built_in">ebx</span>         <span class="hljs-keyword">loop</span> @@<span class="hljs-number">4</span>               <span class="hljs-keyword">hlt</span> <span class="hljs-comment">;-------------------------------------------------------------------------------</span>     string           <span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;s0ke4or92xap3fv8giuzjcy5l1m7hd6bnqtw.&#x27;</span><span class="hljs-comment">;-------------------------------------------------------------------------------</span>     pgdt             <span class="hljs-built_in">dw</span> <span class="hljs-number">0</span>                      <span class="hljs-built_in">dd</span> <span class="hljs-number">0x00007e00</span>      <span class="hljs-comment">;GDT的物理地址</span><span class="hljs-comment">;-------------------------------------------------------------------------------                             </span>     <span class="hljs-built_in">times</span> <span class="hljs-number">510</span>-($-$$) <span class="hljs-built_in">db</span> <span class="hljs-number">0</span>                      <span class="hljs-built_in">db</span> <span class="hljs-number">0x55</span>,<span class="hljs-number">0xaa</span></code></pre></div><h3 id="计算逻辑地址"><a href="#计算逻辑地址" class="headerlink" title="计算逻辑地址"></a>计算逻辑地址</h3><blockquote><p>要安装GDT全局描述符表，首先会计算GDT在实模式下的逻辑地址</p></blockquote><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-comment">;计算GDT所在的逻辑段地址</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,[<span class="hljs-built_in">cs</span>:pgdt+<span class="hljs-number">0x7c00</span>+<span class="hljs-number">0x02</span>]      <span class="hljs-comment">;GDT的32位线性基地址 </span><span class="hljs-keyword">xor</span> <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">edx</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>,<span class="hljs-number">16</span><span class="hljs-keyword">div</span> <span class="hljs-built_in">ebx</span>                            <span class="hljs-comment">;分解成16位逻辑地址</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">eax</span>                         <span class="hljs-comment">;令DS指向该段以进行操作</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>,<span class="hljs-built_in">edx</span>                        <span class="hljs-comment">;段内起始偏移地址 </span></code></pre></div><ul><li><code>mov eax,[cs:pgdt+0x7c00+0x02]</code>：将GDT的线性基地址放入到eax中</li><li><code>xor edx,edx</code>：用xor异或运算，将edx清零</li><li><code>mov ebx,16</code>：将16放入ebx中</li><li><code>div ebx</code>：将<code>ebx÷eax</code>的结果保存在eax中，然后余数保存在edx中</li><li><code>mov ds,eax</code>：将除法运算后的结果给ds，即把段地址给ds寄存器</li><li><code>mov ebx,edx</code>：将除法运算后的余数给ebx，即把偏移地址给ebx寄存器</li></ul><h3 id="创建描述符"><a href="#创建描述符" class="headerlink" title="创建描述符"></a>创建描述符</h3><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-comment">;创建0#描述符，它是空描述符，这是处理器的要求</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebx</span>+<span class="hljs-number">0x00</span>],<span class="hljs-number">0x00000000</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebx</span>+<span class="hljs-number">0x04</span>],<span class="hljs-number">0x00000000</span>  <span class="hljs-comment">;创建1#描述符，这是一个数据段，对应0~4GB的线性地址空间</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebx</span>+<span class="hljs-number">0x08</span>],<span class="hljs-number">0x0000ffff</span>    <span class="hljs-comment">;基地址为0，段界限为0xfffff</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebx</span>+<span class="hljs-number">0x0c</span>],<span class="hljs-number">0x00cf9200</span>    <span class="hljs-comment">;粒度为4KB，存储器段描述符 </span><span class="hljs-comment">;创建保护模式下初始代码段描述符</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebx</span>+<span class="hljs-number">0x10</span>],<span class="hljs-number">0x7c0001ff</span>    <span class="hljs-comment">;基地址为0x00007c00，512字节 </span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebx</span>+<span class="hljs-number">0x14</span>],<span class="hljs-number">0x00409800</span>    <span class="hljs-comment">;粒度为1个字节，代码段描述符 </span><span class="hljs-comment">;创建以上代码段的别名描述符</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebx</span>+<span class="hljs-number">0x18</span>],<span class="hljs-number">0x7c0001ff</span>    <span class="hljs-comment">;基地址为0x00007c00，512字节</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebx</span>+<span class="hljs-number">0x1c</span>],<span class="hljs-number">0x00409200</span>    <span class="hljs-comment">;粒度为1个字节，数据段描述符</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebx</span>+<span class="hljs-number">0x20</span>],<span class="hljs-number">0x7c00fffe</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebx</span>+<span class="hljs-number">0x24</span>],<span class="hljs-number">0x00cf9600</span></code></pre></div><h4 id="创建0-描述符（空描述符）"><a href="#创建0-描述符（空描述符）" class="headerlink" title="创建0#描述符（空描述符）"></a>创建0#描述符（空描述符）</h4><p>该描述符索引为0，处理器禁止访问该描述符，任何时候用索引字段0来访问该描述符，都会被处理器阻止，并引发异常中断。c语言中，一个没有进行初始化的指针，初始值一般就为0（空描述符能够阻止不安全的访问）</p><h4 id="创建1-描述符（数据段描述符）"><a href="#创建1-描述符（数据段描述符）" class="headerlink" title="创建1#描述符（数据段描述符）"></a>创建1#描述符（数据段描述符）</h4><p>通过分析可以得到：</p><ul><li><p>基地址为0，段界限为0xfffff</p></li><li><p>G&#x3D;1，段的单位是4KB，大小4kb~4GB</p></li></ul><h5 id="段界限和段大小"><a href="#段界限和段大小" class="headerlink" title="段界限和段大小"></a>段界限和段大小</h5><ul><li><p>段的扩展方向是向上，即地址越来越高，此时的段界限用来表示段内偏移的最大值。对于栈段，段的扩展方向是向下，即地址越来越低，此时的段界限用来表示段内偏移的最小值。无论是向上扩展，还是向下扩展，段界限的作用如同其名，表示段的边界、大小、范围。（段界限实际就是一个偏移量）</p></li><li><p>段界限只是个单位量，它的单位要么是字节，要么是 4KB，这是由描述符中的 G 位来指定的，G&#x3D;0，单位是字节，G&#x3D;1，单位是4KB</p><ul><li><p>段大小（段长度） &#x3D; （描述符中段界限+1）×（段界限的粒度大小： 4KB 或者 1B）</p><p>如果粒度大小为4KB，那么如下：</p><img src="/2022/09/14/22-0914-01/image-20220919200102808.png" class="" title="image-20220919200102808"></li><li><p>实际段界限 &#x3D; （描述符中段界限+1）×（段界限的粒度大小： 4KB 或者 1B） - 1</p><p>  （注意：这里的段界限是不同与段描述符中的段界限的，段描述符中的段界限是一个单位量）</p><p>  （另外注意：段界限不是指段的最大长度，而是只段内的最大偏移，所以一定要在段长度的基础上再减1）</p></li></ul><img src="/2022/09/14/22-0914-01/image-20220919195900427.png" class="" title="image-20220919195900427"></li></ul><h4 id="创建2-描述符（代码段描述符）"><a href="#创建2-描述符（代码段描述符）" class="headerlink" title="创建2#描述符（代码段描述符）"></a>创建2#描述符（代码段描述符）</h4><p>通过分析可以得到：</p><ul><li>段界限为0x1ff，然后段长度&#x3D;0x1ff+1&#x3D;0x200，即512个字节</li></ul><h4 id="创建3-描述符（别名描述符）"><a href="#创建3-描述符（别名描述符）" class="headerlink" title="创建3#描述符（别名描述符）"></a>创建3#描述符（别名描述符）</h4><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-comment">;创建保护模式下初始代码段描述符</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebx</span>+<span class="hljs-number">0x10</span>],<span class="hljs-number">0x7c0001ff</span>    <span class="hljs-comment">;基地址为0x00007c00，512字节 </span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebx</span>+<span class="hljs-number">0x14</span>],<span class="hljs-number">0x00409800</span>    <span class="hljs-comment">;粒度为1个字节，代码段描述符 </span><span class="hljs-comment">;创建以上代码段的别名描述符</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebx</span>+<span class="hljs-number">0x18</span>],<span class="hljs-number">0x7c0001ff</span>    <span class="hljs-comment">;基地址为0x00007c00，512字节（该部分与代码段描述符代码一样）</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebx</span>+<span class="hljs-number">0x1c</span>],<span class="hljs-number">0x00409200</span>    <span class="hljs-comment">;粒度为1个字节，数据段描述符 （该部分与代码段描述符稍有区别，只有最后面的200不一样，即段属性不同，该段为可读可写的）</span></code></pre></div><p>创建别名描述符的代码与创建代码段描述符的代码有一部分一模一样，这是为啥呢 ？？？</p><p>代码段是不可以写入的，但所谓的不可写入并非改变了内存的物理性质使内存不可写入，而是通过该段的描述符来访问这个区域的时候，处理器不允许向里面写入数据或更改数据。</p><p>但是很多时候我们需要对代码段做一些修改，比如：调试程序时，有一个<code>int3</code>指令（该指令的功能是下断点的，用于调试的指令），在调试代码的时候，就会向代码里插入断点指令，但是处理器会禁止访问代码段，所以我们只能安装一个新的描述符，并且将该描述符定义为数据段描述符，而且是可以读可以写的，起始地址和代码段相同，都是0x7c00。</p><p>2个以上的描述符都指向同一个段时（同时共享一个内存），把另外一个描述符称之为别名，别名技术并非只适用于代码段。</p><h4 id="创建4-描述符（栈描述符）"><a href="#创建4-描述符（栈描述符）" class="headerlink" title="创建4#描述符（栈描述符）"></a>创建4#描述符（栈描述符）</h4><blockquote><p>安装栈段</p></blockquote><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebx</span>+<span class="hljs-number">0x20</span>],<span class="hljs-number">0x7c00fffe</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebx</span>+<span class="hljs-number">0x24</span>],<span class="hljs-number">0x00cf9600</span></code></pre></div><p>通过分析可以得到：</p><ul><li>基地址为0x00007c00</li><li>段界限为0xFFFFE</li><li>粒度4KB</li></ul><h3 id="初始化描述符表寄存器GDTR"><a href="#初始化描述符表寄存器GDTR" class="headerlink" title="初始化描述符表寄存器GDTR"></a>初始化描述符表寄存器GDTR</h3><blockquote><p>设置描述符表的界限</p></blockquote><p>由于前面我们设置了5个描述符，所以表的界限 &#x3D; 5×8 -1 &#x3D;39 </p><h3 id="打开地址线、设置PE位，进入保护模式"><a href="#打开地址线、设置PE位，进入保护模式" class="headerlink" title="打开地址线、设置PE位，进入保护模式"></a>打开地址线、设置PE位，进入保护模式</h3><p>省略，day7的学习中进行过详细分析</p><h3 id="修改段寄存器时的保护"><a href="#修改段寄存器时的保护" class="headerlink" title="修改段寄存器时的保护"></a>修改段寄存器时的保护</h3><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">jmp</span> <span class="hljs-built_in">dword</span> <span class="hljs-number">0x0010</span>:flush<span class="hljs-comment">;这条指令会刷新缓存，当然由于是jmp指令，肯定会修改寄存器cs</span><span class="hljs-comment">;上述代码中，还有如下修改段寄存器的指令：</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">eax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">fs</span>,<span class="hljs-built_in">eax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">gs</span>,<span class="hljs-built_in">eax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>,<span class="hljs-built_in">eax</span></code></pre></div><p>在上面有关修改段寄存器的指令执行时候，保护模式下，段寄存器存储的都是选择子。处理器把指令中给出的选择子传送到段寄存器的选择子部分，在处理器部件完成传送之前，要确认选择子是正确的，并且该选择子选择的描述符也是正确的</p><p>然后会判断描述符是不是超出描述符表的界限，如果通过了GDT表边界检查从中取得描述符后，紧接着还要对描述符的类型进行确认，假如取出来的描述符的类别是只能执行的代码段，那么则不允许加载到 cs 之外的其它段寄存器中，还会检查描述符的 P 位，如果P位&#x3D; 0 ，虽然描述符已经被定义，但该描述符并没有在物理内存中，处理器会引发异常中断，如果P位 &#x3D; 1，则处理器把描述符加载到段寄存器的描述符高速缓存器，同时设置 TYPE 字段A位为1</p><h3 id="代码段执行时的保护"><a href="#代码段执行时的保护" class="headerlink" title="代码段执行时的保护"></a>代码段执行时的保护</h3><p>在32位保护模式下，尽管段的信息在描述符表中，但是一旦相应的描述符被加载到段寄存器的描述符高速缓存器，则处理器取指令和指令时，将不再访问描述符，而是直接使用段寄存器的描述符高速缓存器，从中取得线性基地址，同指令指针寄存器EIP相加，共同形成32位的物理地址从内存中取得下一条指令，不过在指令实际开始执行之前，处理器必须检查其存放地址的有效性，以防止执行超出允许范围之外的指令。</p><p>检查存放地址的要求范围如下：</p><img src="/2022/09/14/22-0914-01/image-20220918222610171.png" class="" title="image-20220918222610171"><h3 id="栈操作时的保护"><a href="#栈操作时的保护" class="headerlink" title="栈操作时的保护"></a>栈操作时的保护</h3><p>栈是向下扩展的，由高地址扩展到低地址，栈指针可访问的最低地址是由实际段界限决定的，规定了实际使用段界限就是段内不允许访问的最低偏移地址</p><img src="/2022/09/14/22-0914-01/image-20220918223138599.png" class="" title="image-20220918223138599"><p>实际使用的段界限+1 ≤ ESP的内容 - 操作数长度 ≤ 0xFFFFFFFF </p><p>比如：栈段的粒度是字节，描述符中的段界限是0x7a00，假设现在ESP的内容是0x00007a04，那么执行 push edx</p><p>由于执行的push edx，所以压入的是4个字节的大小，那么 esp - 4 &#x3D; 0x7a00</p><p>但 0x7a00 &lt; 0x7a00+1，不满足 实际使用的段界限+1 ≤ ESP的内容 - 操作数长度，所以无法执行push edx指令</p><h1 id="各种地址的区别"><a href="#各种地址的区别" class="headerlink" title="各种地址的区别"></a>各种地址的区别</h1><p>物理地址就是物理内存的真正地址，相当于内存中每个存储单元的门牌号，具有唯一性，不管在什么模式下，不管什么虚拟地址、线性地址，CPU 最终都要以物理地址去访问内存，只有物理地址才内存访问的终点站</p><p>在实模式下，段基址+段内偏移地址 经过段部件的处理，直接输出的就是物理地址，CPU可以直接用这个地址访问内存</p><p>而在保护模式下，段基址+段内偏移地址 称为线性地址，不过这个时候段基址已经不再是真正的地址了，而是选择子，类似数组下标索引，通过这个索引可以在GDT表中找到对应的段描述符，段描述符记录了该段的起始、大小、属性等信息，这样便得到了段基址。如果没有开启地址分页功能，此线性地址就被当作物理地址来用可以直接访问内存，如果开启了分页功能，此线性地址又多了一个名字，被叫做虚拟地址，虚拟地址要经过CPU页部件转换成具体的物理地址。</p><p>无论在实模式或保护模式下，段内偏移地址又称为有效地址，也称为逻辑地址。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>x86保护模式day8</title>
    <link href="/2022/09/13/22-0913-01/"/>
    <url>/2022/09/13/22-0913-01/</url>
    
    <content type="html"><![CDATA[<blockquote><p>该节课的主要任务为回顾和扩展前几天课程的内容，笔记简单记</p></blockquote><h1 id="80386的平坦模型"><a href="#80386的平坦模型" class="headerlink" title="80386的平坦模型"></a>80386的平坦模型</h1><p>80386总共有32根地址线，如果段基址为0，那么只用段内偏移地址FFFFFFFF也是可以访问内存的任何角落，以段基址为0，只靠偏移来访问，就是平坦模型</p><h1 id="80386的虚拟8086模式"><a href="#80386的虚拟8086模式" class="headerlink" title="80386的虚拟8086模式"></a>80386的虚拟8086模式</h1><p>为了兼容8086的程序，所以出现了一个过渡的模式来对8086的程序进行兼容，这个模式即虚拟8086模式，即80386处理器实际有三个模式：保护模式、实模式、虚拟8086模式</p><p>注意：虚拟8086模式就是在保护模式下的保护模式</p>]]></content>
    
    
    <categories>
      
      <category>x86保护模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>x86保护模式day7</title>
    <link href="/2022/09/08/22-0908-01/"/>
    <url>/2022/09/08/22-0908-01/</url>
    
    <content type="html"><![CDATA[<h1 id="一般指令的扩展"><a href="#一般指令的扩展" class="headerlink" title="一般指令的扩展"></a>一般指令的扩展</h1><h2 id="32位除法"><a href="#32位除法" class="headerlink" title="32位除法"></a>32位除法</h2><p>如果被除数是64位，那么高32位在edx寄存器，低32位在eax中保存</p><h2 id="栈操作"><a href="#栈操作" class="headerlink" title="栈操作"></a>栈操作</h2><p>栈操作在32位处理器也进行了扩展，允许压入4个字节操作数（双字），还支持立即数压栈（之前学过的压栈都是<code>mov ax,4</code>，然后再<code>push ax</code>），可以直接<code>push 0x4</code></p><p>注意：实际0x4是表示不清楚的，0x4可以表示0x0004（一个字），还可以表示成0x00000004（两个字），所以我们需要说明操作的大小，如下：</p><ul><li><p>push byte 0x4 （byte告诉编译器压入的是一个字节）</p><ul><li><p>push 8位立即数——对应的机器码——&gt;6A</p></li><li><p>push 16位立即数——对应的机器码——&gt;68</p></li><li><p>push 32位立即数——对应的机器码——&gt;68</p></li></ul></li><li><p>push byte 0x4 该指令在32位处理器下编译后对应机器码为6a 04，但是当执行时压入的不是一个字节（因为无论任何时候处理器都不会压入一个字节，要不压入字、要不压入双字）</p><ul><li>在16位下执行的时候，sp-2，压入0x0004</li><li>在32位下执行的时候，esp-4，压入0x00000004</li></ul></li><li><p>push word 0xfffb</p><ul><li>在16位模式下，sp-2，压入0xfffb</li><li>在32位模式下，sp-4，压入0xffff fffb</li></ul></li><li><p>push dword 0xfb</p><ul><li>在16位模式下，sp-2，压入0x0000 00fb</li><li>在32位模式下，sp-4，压入0x0000 00fb</li></ul></li></ul><h1 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h1><p>在实模式下，用户程序对内存的访问非常的自由，没有任何的限制</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">0x8000</span><span class="hljs-keyword">push</span> <span class="hljs-built_in">ds</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">cx</span><span class="hljs-keyword">mov</span> [<span class="hljs-number">0x05</span>],<span class="hljs-built_in">ds</span><span class="hljs-comment">;[0x8000]实际就是0x8000:0x0005</span><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ds</span></code></pre></div><h2 id="全局描述符表"><a href="#全局描述符表" class="headerlink" title="全局描述符表"></a>全局描述符表</h2><p>为了程序在内存中能够自由浮动而不影响执行，处理器将内存划分成逻辑上的段解决重定位问题，在保护模式下，对内存的访问仍然使用段地址和偏移地址，但是在每个段能够访问之前，必须先进行登记，登记的信息包括段的起始地址、段的界限等各种访问属性</p><p>登记好了之后，如果访问的偏移地址超出段的界限时，处理器会阻止这种访问，产生一个叫做内部异常的中断</p><p>和一个段有关的信息需要8个字节来描述，这个称之为段描述符</p><p>为了存放这些描述符，需要在内存中开辟一段空间，在这段空间中所有的描述符都挨在一起，构成一个描述符表，最主要的描述符表就是全局描述符表，简称GDT（所谓全局就是为整个软硬件系统服务）</p><p>为了跟踪这个全局描述符表，处理器内部有一个48位的寄存器，全局描述符寄存器 GDTR，如下图：</p><img src="/2022/09/08/22-0908-01/image-20220909204954938.png" class="" title="image-20220909204954938"><ul><li>这里GDT的边界是0~15，即大小也就是2的16次方，即GDT表的大小65536</li><li>由于一个描述符占8个字节，65536÷8&#x3D;8192，所以最多可以定义8192个描述符</li><li>全局描述符表可以位于内存的任何地方，但是因为进入保护模式后，处理器会按照新的内存访问模式工作，所以必须在进入保护模式之前来定义GDT表，因为在实模式下（16位处理器有20条地址总线，寻址范围最大为2的20次方，即寻址空间只有1MB），只能按照1MB来访问内容，所以GDT通常都定义在1MB的范围内</li></ul> <img src="/2022/09/08/22-0908-01/image-20220909212002260.png" class="" title="image-20220909212002260"><p>在保护模式下，不能说访问哪个段就访问哪个段，在访问之前，必须现在GDT中定义要访问的内存段</p><p>通常，在操作系统上，描述符不是用户程序自己建立的，而是操作系统根据你的程序结构建立的，用户程序是无法建立的和修改GDT的，在这种情况下，操作系统为你建立了几个段，你就只能在这些段内老老实实工作，一旦超出这个范围或者未按照预定的方法访问这些段，都将处理器阻止</p><p>每个描述符在GDT中占8字节，下图就是存储器段描述符格式，图中上面是高32位，下面是低32位 </p><img src="/2022/09/08/22-0908-01/image-20220910160219727.png" class="" title="image-20220910160219727"><p>在实模式下，段地址并非真实的物理地址，在计算物理地址时还要左移4位。</p><blockquote><p>这里解释 “计算物理地址时还要左移4位” 这句话 </p><p>前面学习16位汇编时，物理地址&#x3D;段地址×16+偏移地址</p><p>乘16就是十六进制左移一位，比如：段地址为1200h，那么段地址×16&#x3D;1200 0h，这里的左移4位是<code>相对二进制而言</code>的</p></blockquote><p>和实模式不同，32位保护模式下，段地址是32位的线性地址，如果没有开启页功能，那么该线性地址就是物理地址</p><p>扩展了解：为啥上图中的（段）基地址分成了三个部分，不是连着的呢 ？<br>这要从80286开始说起，80286也有保护模式，是属于16位的保护模式，但寻址是24位的（最多访问16M的内存），然后32位处理器（80386）为了向下兼容，所以只能在旧的描述符（80286的描述符）格式下进行扩展，所以造成了段基地址不连续</p><p>20位的段界限（段限长，共两部分 <code>0~15</code> 和 <code>16~19</code> ）用来限制段的扩展范围，对于向上扩展的段，如代码段和数据段，偏移量从0开始递增，段界限就决定了偏移量的最大值，对于向下扩展的段，如栈段，段界限决定了偏移量的最小值</p><h3 id="G位"><a href="#G位" class="headerlink" title="G位"></a>G位</h3><p>G位是粒度位，用于解释段界限的含义，当G&#x3D;0，段界限以字节为单位，段的扩展范围为1字节到1兆（2的0次方到2的20次方） ，当G&#x3D;1，段界限以4KB为单位，段的扩展范围就是从4KB~4GB</p><h3 id="S位"><a href="#S位" class="headerlink" title="S位"></a>S位</h3><p>S位用于指定描述符的类型，S&#x3D;0，表示描述符是系统段描述符，S&#x3D;1，表示描述符是代码段或数据段描述符（栈段属于特殊的数据段描述符）</p><h3 id="DPL位"><a href="#DPL位" class="headerlink" title="DPL位"></a>DPL位</h3><p>DPL表示描述符的特权级，分别是0,1,2,3，其中0就是最高特权级别，3是最低。通常刚进入保护模式时候，执行的代码具有最高特权级别（刚进入保护模式时，可以看成从处理器继承而来，所以拥有最高权限）。每当操作系统加载一个用户程序，通常都会指定一个比较低的特权级别（一般的用户程序，都是3的特权级别），不同特权级别是相互隔离的，其访问相互限制，有些处理器指令只能由0特权级别的程序来执行，在这里描述符的特权级用于指定要访问该段所必须具备的最低特权级，如果这里的数值是2，那么只有特权级别为0,1,2的程序才能访问该段，特权3访问这个段时处理器是会阻止的</p><h3 id="P位"><a href="#P位" class="headerlink" title="P位"></a>P位</h3><p>P位表示段存在位，用于指示描述符对应的段是否存在，一般描述符所指示的段都在内存中，当内存空间紧张时，有可能只是建立了描述符，但是对应的内存空间可能并不存在，这时候就把描述符的P位清零。同样，在内存空间紧张情况下，操作系统会把很少用到的段放到硬盘中去，然后节省下空间给当前急需内存的程序使用，同样也会把描述符的P位清零，当再次轮到它执行时，再装入内存，然后将P位置为1。</p><p>P位是处理器负责检查的，每当通过描述符访问内存中的段时，如果P位是0，处理器会产生一个异常中断，通常该中断处理过程是由操作系统提供的，该处理过程任务就是负责将该段从硬盘放到内存中，并将P位置1。在多用户多任务的系统中，这是一种常用的虚拟内存调度策略</p><h3 id="D-x2F-B位"><a href="#D-x2F-B位" class="headerlink" title="D&#x2F;B位"></a>D&#x2F;B位</h3><p>D&#x2F;B位表示默认操作数的大小&#x2F;默认的栈指针大小，设立该标志位主要是为了在32位的处理器上兼容16位保护模式的程序，该标志位对于不同的段有不同的效果，对于代码段，此位称为D位，用于指示指令默认的偏移地址和操作数尺寸，D&#x3D;0表示指令指令中偏移地址或操作数是16位的，D&#x3D;1，表示指令指令中偏移地址或操作数是32位的。</p><p>如果代码段描述符D位是0，那么处理器在这个段上执行时使用16位寄存器IP来取指令，否则使用32位EIP</p><p>对于栈段来说，该位叫B位，用于栈操作的时候，是使用SP还是ESP，该位是0，使用SP，该位是1，使用ESP。同时B位的值也决定了栈的上部边界，如果B&#x3D;0，栈的上部边界（也就是SP寄存器最大值）为0xFFFF。B&#x3D;1，那么也就是ESP的最大值0xFFFFFFFF</p><h3 id="L位"><a href="#L位" class="headerlink" title="L位"></a>L位</h3><p>AVL左边就是L位，是64位代码段标志，保留给64位处理器使用的，一般置为0即可</p><h3 id="TYPE字段"><a href="#TYPE字段" class="headerlink" title="TYPE字段"></a>TYPE字段</h3><p>type字段为4位，用于指示描述符的类别，如下图：</p><img src="/2022/09/08/22-0908-01/image-20220910160530032.png" class="" title="image-20220910160530032"><ul><li>X位：表示是否可以执行（其中数据段总是不可执行，所以X&#x3D;0，代码段总可以执行，所以X&#x3D;1）</li><li>E位：E位指示段的扩展方向，E&#x3D;0，表示向上扩展，也就是向高地址方向扩展，表示的就是普通的数据段。E&#x3D;1，表示向下扩展，通常表示栈段</li><li>C位：表示一致性&#x2F;非一致性，C&#x3D;0，表示一致性，表示这样的代码段可以从与它特权级相同的代码段调用。C&#x3D;1，表示非一致性，表示可以从低特权级的程序转移到该段执行，但低特权级的程序仍然保持自身的特权级 <ul><li>注意：所有的数据段都是非一致性的，他们不能被低特权的程序访问，但可以被更高特权的程序访问</li></ul></li><li>R位：表示代码段是否允许读出来，代码段总是可以执行的，但是为了防止程序被破坏，代码段不允许被写入，至于代码段能否被读出来，则由R位决定，R&#x3D;0，代码段不可被读出来，代码段只能被执行，R&#x3D;1，表示代码段可被读出，段的内容可以被读到。<br>但是如果代码段的内容不可读，那么处理器如何来执行呢 ？？<br>因为R位是来限制程序和指令的行为，并不会限制处理器的，所以处理器一定是可以读取到代码段的</li><li>A位：表示已访问位（accessed）用于指示它所指向的段最近是否被访问过，在描述符创建的时候应该清零。每当该段被访问时，处理器自动将该位设置1，对该位的清零是由操作系统负责的，通过定期监控该位的状态，就可以统计出该段的使用频率，从而实现虚拟内存管理。</li></ul><h3 id="AVL"><a href="#AVL" class="headerlink" title="AVL"></a>AVL</h3><p>avl位属于软件可以使用的位，通常操作系统来使用，处理器一般不用</p><h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><blockquote><p>分析代码c11_mbr.asm</p></blockquote><div class="code-wrapper"><pre><code class="hljs x86asm">         <span class="hljs-comment">;</span>         <span class="hljs-comment">;文件名：c11_mbr.asm</span>         <span class="hljs-comment">;文件说明：硬盘主引导扇区代码 </span>         <span class="hljs-comment">;</span>         <span class="hljs-comment">;设置堆栈段和栈指针 </span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">cs</span>               <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>,<span class="hljs-built_in">ax</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>,<span class="hljs-number">0x7c00</span>               <span class="hljs-comment">;计算GDT所在的逻辑段地址 </span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,[<span class="hljs-built_in">cs</span>:gdt_base+<span class="hljs-number">0x7c00</span>]        <span class="hljs-comment">;低16位 </span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,[<span class="hljs-built_in">cs</span>:gdt_base+<span class="hljs-number">0x7c00</span>+<span class="hljs-number">0x02</span>]   <span class="hljs-comment">;高16位 </span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">16</span>                 <span class="hljs-keyword">div</span> <span class="hljs-built_in">bx</span>                     <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span>                          <span class="hljs-comment">;令DS指向该段以进行操作</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-built_in">dx</span>                          <span class="hljs-comment">;段内起始偏移地址 </span>               <span class="hljs-comment">;创建0#描述符，它是空描述符，这是处理器的要求 null描述符 </span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">0x00</span>],<span class="hljs-number">0x00</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">0x04</span>],<span class="hljs-number">0x00</span>           <span class="hljs-comment">;创建#1描述符，保护模式下的代码段描述符</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">0x08</span>],<span class="hljs-number">0x7c0001ff</span><span class="hljs-comment">;线性基地址为0x00007c00 段界限为0x001FF G=0粒度为字节，该段的长度为512字节 </span><span class="hljs-comment">;S=1表示代码段或者数据段  D=1表示32的段 P=1表示该段在内存中，</span><span class="hljs-comment">;DPL=00 特权级位0 TYPE=1000，表示只能执行的代码段</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">0x0c</span>],<span class="hljs-number">0x00409800</span><span class="hljs-comment">;0   0  0  0 0  0  0  0  0  1  0  0  0  0  0  0  1  0  0  1  1  0  0 0 0 0 0 0 0 0 0 0     </span><span class="hljs-comment">;31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0</span>         <span class="hljs-comment">;创建#2描述符，保护模式下的数据段描述符（文本模式下的显示缓冲区） </span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">0x10</span>],<span class="hljs-number">0x8000ffff</span>              <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">0x14</span>],<span class="hljs-number">0x0040920b</span>              <span class="hljs-comment">;创建#3描述符，保护模式下的堆栈段描述符</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">0x18</span>],<span class="hljs-number">0x00007a00</span><span class="hljs-comment">;0x07a00</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">0x1c</span>],<span class="hljs-number">0x00409600</span>         <span class="hljs-comment">;初始化描述符表寄存器GDTR</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> [<span class="hljs-built_in">cs</span>: gdt_size+<span class="hljs-number">0x7c00</span>],<span class="hljs-number">31</span>  <span class="hljs-comment">;描述符表的界限（总字节数减一）   </span>                                                      <span class="hljs-keyword">lgdt</span> [<span class="hljs-built_in">cs</span>: gdt_size+<span class="hljs-number">0x7c00</span>]               <span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0x92</span>                         <span class="hljs-comment">;南桥芯片内的端口 </span>         <span class="hljs-keyword">or</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0000_0010B</span>         <span class="hljs-keyword">out</span> <span class="hljs-number">0x92</span>,<span class="hljs-built_in">al</span>                        <span class="hljs-comment">;打开A20 </span>         <span class="hljs-keyword">cli</span>                                <span class="hljs-comment">;保护模式下中断机制尚未建立，应 </span>                                            <span class="hljs-comment">;禁止中断 </span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">cr0</span>         <span class="hljs-keyword">or</span> <span class="hljs-built_in">eax</span>,<span class="hljs-number">1</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cr0</span>,<span class="hljs-built_in">eax</span>                        <span class="hljs-comment">;设置PE位</span>               <span class="hljs-comment">;以下进入保护模式... ...</span>         <span class="hljs-keyword">jmp</span> <span class="hljs-built_in">dword</span> <span class="hljs-number">0x0008</span>:flush             <span class="hljs-comment">;16位的描述符选择子：32位偏移</span>                                           <span class="hljs-comment">;清流水线并串行化处理器 </span>         [<span class="hljs-meta">bits</span> <span class="hljs-number">32</span>] <span class="hljs-symbol"></span><span class="hljs-symbol">    flush:</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">00000000000_10_000B</span>         <span class="hljs-comment">;加载数据段选择子(0x0010)</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">cx</span>         <span class="hljs-comment">;以下在屏幕上显示&quot;Protect mode OK.&quot; </span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">0x00</span>],<span class="hljs-string">&#x27;P&#x27;</span>           <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">0x02</span>],<span class="hljs-string">&#x27;r&#x27;</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">0x04</span>],<span class="hljs-string">&#x27;o&#x27;</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">0x06</span>],<span class="hljs-string">&#x27;t&#x27;</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">0x08</span>],<span class="hljs-string">&#x27;e&#x27;</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">0x0a</span>],<span class="hljs-string">&#x27;c&#x27;</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">0x0c</span>],<span class="hljs-string">&#x27;t&#x27;</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">0x0e</span>],<span class="hljs-string">&#x27; &#x27;</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">0x10</span>],<span class="hljs-string">&#x27;m&#x27;</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">0x12</span>],<span class="hljs-string">&#x27;o&#x27;</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">0x14</span>],<span class="hljs-string">&#x27;d&#x27;</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">0x16</span>],<span class="hljs-string">&#x27;e&#x27;</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">0x18</span>],<span class="hljs-string">&#x27; &#x27;</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">0x1a</span>],<span class="hljs-string">&#x27;O&#x27;</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">0x1c</span>],<span class="hljs-string">&#x27;K&#x27;</span>         <span class="hljs-comment">;以下用简单的示例来帮助阐述32位保护模式下的堆栈操作 </span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">00000000000_11_000B</span>         <span class="hljs-comment">;加载堆栈段选择子</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>,<span class="hljs-built_in">cx</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span>,<span class="hljs-number">0x7c00</span>         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebp</span>,<span class="hljs-built_in">esp</span>                        <span class="hljs-comment">;保存堆栈指针 </span>         <span class="hljs-keyword">push</span> <span class="hljs-built_in">byte</span> <span class="hljs-string">&#x27;.&#x27;</span>                      <span class="hljs-comment">;压入立即数（字节）</span>                  <span class="hljs-keyword">sub</span> <span class="hljs-built_in">ebp</span>,<span class="hljs-number">4</span>         <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">ebp</span>,<span class="hljs-built_in">esp</span>                        <span class="hljs-comment">;判断压入立即数时，ESP是否减4 </span>         <span class="hljs-keyword">jnz</span> ghalt                                   <span class="hljs-keyword">pop</span> <span class="hljs-built_in">eax</span>         <span class="hljs-keyword">mov</span> [<span class="hljs-number">0x1e</span>],<span class="hljs-built_in">al</span>                      <span class="hljs-comment">;显示句点 </span><span class="hljs-symbol">      </span><span class="hljs-symbol">  ghalt:</span>              <span class="hljs-keyword">hlt</span>                                <span class="hljs-comment">;已经禁止中断，将不会被唤醒 </span><span class="hljs-comment">;-------------------------------------------------------------------------------</span>              gdt_size         <span class="hljs-built_in">dw</span> <span class="hljs-number">0</span>         gdt_base         <span class="hljs-built_in">dd</span> <span class="hljs-number">0x00007e00</span>     <span class="hljs-comment">;GDT的物理地址 </span>                                      <span class="hljs-built_in">times</span> <span class="hljs-number">510</span>-($-$$) <span class="hljs-built_in">db</span> <span class="hljs-number">0</span>                          <span class="hljs-built_in">db</span> <span class="hljs-number">0x55</span>,<span class="hljs-number">0xaa</span></code></pre></div><h2 id="设置堆栈段和栈指针"><a href="#设置堆栈段和栈指针" class="headerlink" title="设置堆栈段和栈指针"></a>设置堆栈段和栈指针</h2><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-comment">;设置堆栈段和栈指针 </span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">cs</span>      <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>,<span class="hljs-number">0x7c00</span><span class="hljs-comment">;--------------</span>gdt_base <span class="hljs-built_in">dd</span> <span class="hljs-number">0x00007e00</span><span class="hljs-comment">;GDT物理地址</span></code></pre></div><p>上述代码如下图：</p><img src="/2022/09/08/22-0908-01/image-20220910194715352.png" class="" title="image-20220910194715352"><h2 id="计算GDT所在的逻辑段地址"><a href="#计算GDT所在的逻辑段地址" class="headerlink" title="计算GDT所在的逻辑段地址"></a>计算GDT所在的逻辑段地址</h2><blockquote><p>我们从实模式到保护模式，就需要安装存储器的段描述符，并且加载到描述符表，安装描述符之前，我们要把GDT的物理地址转为逻辑段地址和偏移地址</p></blockquote><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-comment">;计算GDT所在的逻辑段地址 </span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,[<span class="hljs-built_in">cs</span>:gdt_base+<span class="hljs-number">0x7c00</span>]        <span class="hljs-comment">;低16位放到ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,[<span class="hljs-built_in">cs</span>:gdt_base+<span class="hljs-number">0x7c00</span>+<span class="hljs-number">0x02</span>]   <span class="hljs-comment">;高16位放到dx</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">16</span>        <span class="hljs-keyword">div</span> <span class="hljs-built_in">bx</span>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span>                          <span class="hljs-comment">;令DS指向该段以进行操作</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-built_in">dx</span>                          <span class="hljs-comment">;段内起始偏移地址 </span></code></pre></div><h2 id="创建描述符"><a href="#创建描述符" class="headerlink" title="创建描述符"></a>创建描述符</h2><h3 id="创建0-描述符（空描述符）"><a href="#创建0-描述符（空描述符）" class="headerlink" title="创建0#描述符（空描述符）"></a>创建0#描述符（空描述符）</h3><blockquote><p>处理器规定第一个描述符必须是空描述符，也叫null描述符（其实就是初始化为0）</p></blockquote><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-comment">;创建0#描述符，它是空描述符，这是处理器的要求 null描述符 </span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">0x00</span>],<span class="hljs-number">0x00</span><span class="hljs-comment">;将描述符置为0</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">0x04</span>],<span class="hljs-number">0x00</span>  <span class="hljs-comment">;将描述符置为0</span></code></pre></div><p>为啥要有空描述符呢 ？？</p><p>如果程序设计有问题，寄存器和内存单元的初始值可能会为0，会用0这个索引来选择0号描述符，这样设置null描述符后，就可避免安全问题</p><p><code>mov dword [bx+0x00],0x00</code>：将双字0x00000000放入bx+0的地址空间中，这里bx为07e00，也就是将0放入地址空间07e00</p><p><code>mov dword [bx+0x04],0x00</code> ：将双字0x00000000放入bx+0x04的地址空间中，即将0放入地址空间07e04</p><p>如下图：</p><img src="/2022/09/08/22-0908-01/image-20220911135715856.png" class="" title="image-20220911135715856"><h3 id="创建1-描述符（保护模式下的代码段描述符）"><a href="#创建1-描述符（保护模式下的代码段描述符）" class="headerlink" title="创建1#描述符（保护模式下的代码段描述符）"></a>创建1#描述符（保护模式下的代码段描述符）</h3><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-comment">;创建#1描述符，保护模式下的代码段描述符</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">0x08</span>],<span class="hljs-number">0x7c0001ff</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">0x0c</span>],<span class="hljs-number">0x00409800</span></code></pre></div><p>放入内存中如下图 ：</p><img src="/2022/09/08/22-0908-01/image-20220911140124581.png" class="" title="image-20220911140124581"><img src="/2022/09/08/22-0908-01/image-20220911144630591.png" class="" title="image-20220911144630591"><p>整合上面两个图的信息，可得知：</p><ul><li><p>段限长：即浅蓝色的部分，0x001FF</p></li><li><p>线性基地址：即粉色部分，0x00007c00</p></li><li><p>粒度：G&#x3D;0，即粒度为字节，该段长度512个字节</p></li><li><p>S&#x3D;1，该段属于存储器的段（代码段或数据段），而不是系统的段</p></li><li><p>D&#x3D;1，表示该段为32位的段</p></li><li><p>P&#x3D;1，表示该段在内存中</p></li><li><p>DPL&#x3D;00，表示该段特权级别为0</p></li><li><p>TYPE&#x3D;1000，表示一个只能执行的代码段</p><img src="/2022/09/08/22-0908-01/image-20220911145840994.png" class="" title="image-20220911145840994"></li></ul><h3 id="创建2-描述符（保护模式下的数据段描述符）"><a href="#创建2-描述符（保护模式下的数据段描述符）" class="headerlink" title="创建2#描述符（保护模式下的数据段描述符）"></a>创建2#描述符（保护模式下的数据段描述符）</h3><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">0x10</span>],<span class="hljs-number">0x8000ffff</span>     <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">0x14</span>],<span class="hljs-number">0x0040920b</span></code></pre></div><p>分析过程同#1描述符</p><h3 id="创建-3描述符（保护模式下的堆栈段描述符）"><a href="#创建-3描述符（保护模式下的堆栈段描述符）" class="headerlink" title="创建#3描述符（保护模式下的堆栈段描述符）"></a>创建#3描述符（保护模式下的堆栈段描述符）</h3><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">0x18</span>],<span class="hljs-number">0x00007a00</span><span class="hljs-comment">;0x07a00</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">0x1c</span>],<span class="hljs-number">0x00409600</span></code></pre></div><p>分析过程同#1描述符</p><h2 id="将描述符加载到GDTR寄存器"><a href="#将描述符加载到GDTR寄存器" class="headerlink" title="将描述符加载到GDTR寄存器"></a>将描述符加载到GDTR寄存器</h2><blockquote><p>描述符安装到内存相对应位置之后，需要将描述符线性基地址和界限加载到描述符表寄存器GDTR</p></blockquote><p>首先我们要先定义一个描述符表的界限，低16位就是界限，如下图：</p><img src="/2022/09/08/22-0908-01/image-20220911153457716.png" class="" title="image-20220911153457716"><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> [<span class="hljs-built_in">cs</span>: gdt_size+<span class="hljs-number">0x7c00</span>],<span class="hljs-number">31</span>  <span class="hljs-comment">;描述符表的界限（总字节数减一）</span></code></pre></div><blockquote><p>解释：总字数减一的含义：</p></blockquote><img src="/2022/09/08/22-0908-01/image-20220911154020182.png" class="" title="image-20220911154020182"><blockquote><p>这里为啥表大小是32呢 ？？</p></blockquote><p>因为总共有4个描述符（空 描述符、代码段描述符、数据段描述符、堆栈段描述符），即一共有4个段，一个段占4个字节，一个字节8位，4*8&#x3D;32</p><h3 id="lgdt指令"><a href="#lgdt指令" class="headerlink" title="lgdt指令"></a>lgdt指令</h3><p>lgdt的操作数一个48位的内存单元，格式如下：</p><div class="code-wrapper"><pre><code class="hljs txt">lgdt 48位内存单元</code></pre></div><p>其中48位的内存单元中，低16位就是界限值，高32位是基地址，计算机启动后，基地址会被初始化为0x00000000，界限是0xFFFF</p><img src="/2022/09/08/22-0908-01/image-20220911153457716.png" class="" title="image-20220911153457716"><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">lgdt</span> [<span class="hljs-built_in">cs</span>: gdt_size+<span class="hljs-number">0x7c00</span>]</code></pre></div><p>上述指令中，lgdt指令会把从 gdt_size+0x7c00标号开始后面的6个字节（即48位）加载到GDT寄存器中</p><h2 id="打开A20地址线"><a href="#打开A20地址线" class="headerlink" title="打开A20地址线"></a>打开A20地址线</h2><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0x92</span>                         <span class="hljs-comment">;南桥芯片内的端口 </span><span class="hljs-keyword">or</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0000_0010B</span><span class="hljs-keyword">out</span> <span class="hljs-number">0x92</span>,<span class="hljs-built_in">al</span>                        <span class="hljs-comment">;打开A20 </span></code></pre></div><blockquote><p>进入保护模式之前，还有一个历史遗留的问题</p></blockquote><p>地址线从0开始编号，第一根地址线为A0，A20是处理器的第21根地址线</p><p>在8086中有20根地址线，不存在第21根地址线问题，在8086中，当逻辑地址到达FFFF之后，如果逻辑地址+1，正常来说，FFFF+1&#x3D;10000，但是由于逻辑地址只能保留16位，所以最高位的1就没有了，这样FFFF+1&#x3D;0000，就又绕回到最低位0000，逻辑地址就从最高位FFFF绕回到了最低位0000</p><p>同理，物理地址FFFFF，FFFFF+1&#x3D;00000，也是会绕回最低位物理地址00000</p><p>当年，很多程序员利用硬件的某些特性展示自己的技术，依赖回绕特性来写一些代码</p><p>80286有24根地址线，进位不会被丢弃，这样回绕特性就不能用了，为了80286能够兼容运行8086程序，就把第21根地址线这一位强制变成0，这样进位就不是1，而是0，这样就能模仿8086的回绕特性</p><p>但是如果在80286中想要访问更多的地址线，那么我们就要先打开A20地址线，让第21根地址线由0变成1 （注意：老式设备才需要，一般处理器默认就是打开的）</p><img src="/2022/09/08/22-0908-01/image-20220911163225748.png" class="" title="image-20220911163225748"><p>打开地址线的代码如下：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0x92</span>                         <span class="hljs-comment">;南桥芯片内的端口 </span><span class="hljs-keyword">or</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0000_0010B</span><span class="hljs-keyword">out</span> <span class="hljs-number">0x92</span>,<span class="hljs-built_in">al</span>                        <span class="hljs-comment">;打开A20 </span></code></pre></div><h2 id="关闭中断"><a href="#关闭中断" class="headerlink" title="关闭中断"></a>关闭中断</h2><blockquote><p>保护模式下的中断机制和实模式不同，因此原来的中断向量表不再适用，在保护模式下，所有的BIOS中断都不能再用（因为这是实模式下的代码），在重新设置保护模式下的中断环境之前，必须先关闭中断</p></blockquote><div class="code-wrapper"><pre><code class="hljs abnf">cli<span class="hljs-comment">;保护模式下中断机制尚未建立，应禁止中断 </span></code></pre></div><h2 id="进入保护模式"><a href="#进入保护模式" class="headerlink" title="进入保护模式"></a>进入保护模式</h2><h3 id="CR0寄存器"><a href="#CR0寄存器" class="headerlink" title="CR0寄存器"></a>CR0寄存器</h3><p>CR0寄存器（32位）是处理器内部的控制寄存器，包含了一系列用于控制处理器操作模式和运行状态的标志位，它的第0位（PE，即Protection Enable）是开启保护模式的车钥匙，该位设置为1，则处理器进入保护模式，按保护模式的规则开始运行</p><p>设置PE位，进入保护模式，代码如下：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">cr0</span><span class="hljs-keyword">or</span> <span class="hljs-built_in">eax</span>,<span class="hljs-number">1</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cr0</span>,<span class="hljs-built_in">eax</span>                        <span class="hljs-comment">;设置PE位</span></code></pre></div><h3 id="描述符高速缓存器"><a href="#描述符高速缓存器" class="headerlink" title="描述符高速缓存器"></a>描述符高速缓存器</h3><blockquote><p>8086有4个16位的段寄存器，CS、ES、DS、SS</p></blockquote><p>32位处理器在原先的基础上又增加了2个段寄存器FS、GS，也就是一共有6个：CS，ES，DS，SS，FS，GS</p><p>32位处理器的6个段寄存器又分可见部分和隐藏部分两个部分</p><ul><li>可见部分为16位，与8086一样，目的是在实模式下用于按传统方式寻址，寻址空间1MB（这样就兼容了8086的程序可以在32位的处理器上运行）</li><li>不可见部分为16位，称为描述符高速缓存器，里面有段的基地址和各种访问属性。这部分内容程序不可访问，由处理器自动使用</li></ul><p>32位处理器的段寄存器结构如下图：</p><img src="/2022/09/08/22-0908-01/image-20220912162820252.png" class="" title="image-20220912162820252"><h4 id="8086和32位处理器的内存访问"><a href="#8086和32位处理器的内存访问" class="headerlink" title="8086和32位处理器的内存访问"></a>8086和32位处理器的内存访问</h4><h5 id="8086处理器（只有实模式）"><a href="#8086处理器（只有实模式）" class="headerlink" title="8086处理器（只有实模式）"></a>8086处理器（只有实模式）</h5><blockquote><p>在学习16位汇编已经学习过，简单说明</p></blockquote><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">0x2000</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">cx</span><span class="hljs-keyword">mov</span> [<span class="hljs-number">0xc0</span>],<span class="hljs-built_in">al</span></code></pre></div><p>首先将ds寄存器的内容设置为0x2000，这个只是逻辑段地址，接着向段内偏移地址为0x00c0的地方写入1字节，写入时，处理器将ds的内容左移4位加上偏移地址，实际物理地址为0x200c0</p><h5 id="32位处理器"><a href="#32位处理器" class="headerlink" title="32位处理器"></a>32位处理器</h5><h6 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h6><p>在32位处理器的实模式下，每当引用一个段（执行将段地址传送到段寄存器的指令，比如如下指令：）</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0x2000</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span></code></pre></div><p>32位处理器将逻辑段地址0x2000传送到ds段寄存器中，然后自动将段地址左移4位得到段基地址，并传送到描述符高速缓存器中</p><p>段基址&#x3D;0x2000左移四位&#x3D;0x20000，段基址也只有20位，所以高速缓存器中的32位段基址仅低20位有效，高20位全部为0</p><p>此时ds段寄存器如下图：</p><img src="/2022/09/08/22-0908-01/image-20220912163606344.png" class="" title="image-20220912163606344"><p class="note note-warning">扩展：段基值、段基址、物理地址的区别：<br/>    段基址（段地址、段基地址）=段基值×10H，即 段基址=段基值左移4位<br/>    物理地址（实际地址、绝对地址）=段基值×10H+偏移地址=段基址+偏移地址<br/>    需要注意的是：很多微机教材中没有介绍段基值，而是直接定义 物理地址=段基址×10H+偏移地址，这是因为这类教材中认为段寄存器中的16位数就是段基址，而将段基址×10H定义为段的起始地址</p><h6 id="保护模式-1"><a href="#保护模式-1" class="headerlink" title="保护模式"></a>保护模式</h6><p>在32位处理器的保护模式下，CS，ES，DS，SS，FS，GS称之为段选择器，而不是段寄存器。</p><p>32位处理器在实模式下，访问内存时会将逻辑地址传送给ds段寄存器。而在保护模式下，处理器访问内存会将<code>段选择子</code>传送给ds段选择器</p><blockquote><p>那么什么是段选择子呢 ？？</p><p>段选择子可以大致理解成段描述符在描述符表（GDT）中的索引号</p></blockquote><p>段选择子具体由如下三部分组成：</p><img src="/2022/09/08/22-0908-01/image-20220911175145059.png" class="" title="image-20220911175145059"><ul><li>第一部分是描述符索引号</li><li>第二部分是描述符表指示器，TI&#x3D;0表示描述符在GDT中，TI&#x3D;1表示描述符在LDT中</li><li>第三部分，RPL是请求特权级，表示给出当前选择子的那个程序的特权级别</li></ul><blockquote><p>加载段选择子</p></blockquote><p>前面我们定义过0#描述符（空描述符）、1#描述符（代码段描述符）、2#描述符（数据段描述符）、3#（堆栈段描述符），那么加载的段选择子的描述符索引应该是哪个描述符的索引呢 ？</p><p>32位处理器在进行内存访问时，段选择子将传送给ds数据段选择器，那么这里段选择子的索引肯定是数据段描述符的索引</p><p>在c11_mbr_asm文件中，我们可以发现加载段选择子的代码如下：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">00000000000_10_000B</span>         <span class="hljs-comment">;加载数据段选择子(0x0010)</span></code></pre></div><p>通过分析，可以得出段选择子的描述符索引恰好为2，恰好就是我们之前定义过的数据段描述符的索引</p><img src="/2022/09/08/22-0908-01/image-20220911175655390.png" class="" title="image-20220911175655390"><p>将段选择子传送给ds段选择器后，此时ds段选择器如下：</p><img src="/2022/09/08/22-0908-01/image-20220912171948219.png" class="" title="image-20220912171948219"><p>因为每个描述符占8个字节，那么描述符在表内的偏移地址&#x3D;索引号×8，然后GDTR寄存器提供一个线性基地址，那么我们就可以得到该描述符的起始物理地址，就能够访问到该描述符，然后处理器就把描述符中的段属性、段基址、段界限加载到高速缓存器中</p><p>即如下三个步骤：</p><img src="/2022/09/08/22-0908-01/image-20220912180425116.png" class="" title="image-20220912180425116"><ul><li><p>步骤①</p><ul><li>2号描述符的起始物理地址 &#x3D; 2×8 + 0x7e00 &#x3D; 16（十进制）+ 0x07e00（十六进制）&#x3D; 0x10 +  0x07e00 &#x3D; 0x07e10</li></ul></li><li><p>步骤②</p><ul><li><p>处理器会找到2号描述符在描述符表的位置，如下：</p><img src="/2022/09/08/22-0908-01/image-20220912181800340.png" class="" title="image-20220912181800340"></li></ul></li><li><p>步骤③</p><ul><li><p>将②号描述符的内容0x0040920b8000ffff加载到描述符高速缓存表中</p><img src="/2022/09/08/22-0908-01/image-20220912183635479.png" class="" title="image-20220912183635479"><ul><li>2号 描述符中：<ul><li>段属性&#x3D; 0100 1001 0010  （段属性即G、D&#x2F;B、L、AVL、P、DPL、S、TYPE）</li><li>段基址&#x3D; 0000 00000 0000 1011 1000 0000 0000 0000 （即0xB8000）</li><li>段界限&#x3D; 0000 FFFF FFFF FFFF FFFF</li></ul></li></ul></li><li><p>然后将段属性、段基址、段界限加载到高速缓存器中就行了，此后每当指令访问内存时，就不再访问描述符，直接用当前段寄存器描述符高速缓存器提供线性基地址</p><ul><li>比如保护模式下执行指令：mov byte[0x02],’r’<ul><li>32位处理器会直接把高速缓存器里的32位段基址（即0xB8000）拿出来，然后加上偏移地址，就形成了物理地址，即物理地址&#x3D;0xB8002，也就是通过mov指令将P的ASCII码写入0xB8002这个物理地址</li></ul></li></ul></li></ul></li></ul><h3 id="清空流水线"><a href="#清空流水线" class="headerlink" title="清空流水线"></a>清空流水线</h3><blockquote><p>这里为啥要清空流水线呢 ? </p></blockquote><p>32位处理器在实模式下访问内存时，描述符高速缓存器中的段基地址是会保存内容的，所以在刚进入保护模式的时候，这些内容还是残留在里面的，我们要进行刷新，代码如下：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">jmp</span> <span class="hljs-built_in">dword</span> <span class="hljs-number">0x0008</span>:flush</code></pre></div><h1 id="代码调试"><a href="#代码调试" class="headerlink" title="代码调试"></a>代码调试</h1><blockquote><p>采用bochs进行调试，调试前需要先把c11_mbr.asm编译成二进制的bin文件，然后把bin文件加载到vhd格式的虚拟磁盘中，然后设置bochs从vhd格式磁盘启动</p></blockquote><p>处理器刚加电后，除了cs段寄存器外，其余的寄存器全部为0，可以通过sreg来查看段寄存器的状态，如下：</p><img src="/2022/09/08/22-0908-01/image-20220912214436960.png" class="" title="image-20220912214436960"><p>这里的base&#x3D;0xffff0000，即段基址&#x3D;0xffff0000</p><p>然后s进行跳转（即执行下一个命令），并且再次执行sreg查看段寄存器，如下：</p><img src="/2022/09/08/22-0908-01/image-20220912220613445.png" class="" title="image-20220912220613445"><p>这里cs的段基址从0xffff0000跳转到了0x000f0000，这是为啥呢 ？？？</p><p>因为计算机加电后，会读取BIOS中的ROM芯片，而ROM的起始物理地址就是0x000f0000（在<a href="https://ayuxy.cercel.app//2022/08/21/22-0821-01/#%E5%86%85%E5%AD%98">x86保护模式day1</a>中学习过）</p><p>然后我们需要跳转到主引导扇区0x7c00，开始加载操作系统执行（通过<code>b 0x7c00</code>设置断点，然后通过<code>c</code>设置好的断点来执行）</p><img src="/2022/09/08/22-0908-01/image-20220912224930703.png" class="" title="image-20220912224930703"><img src="/2022/09/08/22-0908-01/image-20220912225020357.png" class="" title="image-20220912225020357"><p>然后通过<code>u/100</code>反汇编后面的100条指令，如下 ：</p><img src="/2022/09/08/22-0908-01/image-20220912225338071.png" class="" title="image-20220912225338071"><p>前面了解过我们只要设置cr0就可以进入到保护模式</p><p>我们可以先跳转到cli这个指令的地方，如下：</p><img src="/2022/09/08/22-0908-01/image-20220912225535479.png" class="" title="image-20220912225535479"><p>然后单步执行调试</p><img src="/2022/09/08/22-0908-01/image-20220912230052573.png" class="" title="image-20220912230052573"><p>然后还可以通过creg查看控制器的内容，如下：</p><img src="/2022/09/08/22-0908-01/image-20220912230224563.png" class="" title="image-20220912230224563">]]></content>
    
    
    <categories>
      
      <category>x86保护模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>x86保护模式day6</title>
    <link href="/2022/09/07/22-0907-01/"/>
    <url>/2022/09/07/22-0907-01/</url>
    
    <content type="html"><![CDATA[<h1 id="32位处理器寻址方式"><a href="#32位处理器寻址方式" class="headerlink" title="32位处理器寻址方式"></a>32位处理器寻址方式</h1><blockquote><p>回顾：16位处理器寻址方式</p></blockquote><p><a href="http://localhost:4000/2022/08/21/22-0821-02/#8086-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F">http://localhost:4000/2022/08/21/22-0821-02/#8086-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F</a></p><blockquote><p>32位处理器寻址</p></blockquote><p>32位处理器出现后，寄存器和偏移地址的宽度都扩展了，但是原有的16位方案已经成型，再进行修改很困难，所以解决方法是让16位指令和32位指令共用相同的指令码（机器码）。通过不同的指令前缀和结合处理器当前的运行状态来决定指令的寻址方式</p><ul><li><p>当CPU运行在16位模式下，如果没有指令前缀0x66（mov指令翻译成机器码b8 00，加上前缀后，mov指令机器码为66 b8 00），则认为是传统的16位寻址方式，若有则指令是32位寻址方式</p></li><li><p>当CPU运行在32位模式下，如果没有指令前缀0x66，则认为是默认的32位寻址方式，若有则指令是16位寻址方式</p></li></ul><blockquote><p>32位处理器兼容16位工作模式，可以运行传统的16位代码，但我们肯定是要用32位的模式来发挥最高的运行效率，在32位模式下默认使用32位宽度的寄存器</p></blockquote><div class="code-wrapper"><pre><code class="hljs txt">32位模式下默认使用32宽度的寄存器mov eax,ebxmov ecx,0x66;exc=0x00000066mov edx,[mem];指令里包含了内存地址的操作数，那么它是一个32位的有效地址（段内偏移地址），即mem是一个32位的段内偏移地</code></pre></div><p>指令有效地址：</p><ul><li><p>指令有效地址可以使用全部的32位通用寄存器作为基址寄存器，同时还可以加上一个除了ESP之外的32位通用寄存器作为变址寄存器，变址寄存器还允许乘以1、2、4、8作为<code>比例因子</code>，最后还可以加上一个8位或32位的偏移量。比如：mov ecx,[eax+ebx*8+0x02]</p><img src="/2022/09/07/22-0907-01/image-20220907152633897.png" class="" title="image-20220907152633897"></li><li><p>在16位模式下，内存寻址的操作数，不允许使用栈指针sp，不能写成mov ax,[sp]，但在32位下可以单独用，比如：mov eax,[esp]</p></li><li><p>Intel处理器为了组成众多复杂的指令，给定了一套复杂的指令格式</p><ul><li><p>每一条处理器指令都可以拥有<code>1~4</code>个前缀或者不使用前缀，每个前缀的长度是一个字节，前缀（如果有的话）的后面是操作码部分，指示什么样的操作，比如：传送、加法、移位等，根据指令的不同，操作码的长度是<code>1~3</code>个字节，操作码还可以用来指示操作的字长，即数据宽度是字还是字节            </p></li><li><p>指令编码格式如下：</p><img src="/2022/09/07/22-0907-01/image-20220908144047735.png" class="" title="image-20220908144047735"></li></ul></li></ul><h1 id="指令分析"><a href="#指令分析" class="headerlink" title="指令分析"></a>指令分析</h1><h2 id="16位指令分析"><a href="#16位指令分析" class="headerlink" title="16位指令分析"></a>16位指令分析</h2><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,[<span class="hljs-built_in">bx</span>+<span class="hljs-built_in">si</span>+<span class="hljs-number">0x02</span>]</code></pre></div><p>NASM编译上述指令，发现机器码为8b 50 02</p><img src="/2022/09/07/22-0907-01/image-20220908145530138.png" class="" title="image-20220908145530138"><p>对机器码8b 50 02的分析如下：</p><ul><li><p>内存单元到寄存器的传送指令用了操作码0x8b</p></li><li><p>在8b之后是1字节的寻址方式和操作类型部分</p><ul><li><p>50的二进制即1001 0000</p><img src="/2022/09/07/22-0907-01/image-20220908151226450.png" class="" title="image-20220908151226450"></li><li><p>位7和位6的值为01，表示使用了基址变址的寻址方式，而且带有8位的偏移量</p></li><li><p>位5~位3的值是010，表示目的操作数为寄存器dx</p></li><li><p>位~位0的值是000，表示寻址方式为 “bx+si+8位的偏移量”</p></li></ul></li><li><p>02</p><ul><li>02表示的就是一个字节的偏移量</li></ul></li></ul><h2 id="32位指令分析"><a href="#32位指令分析" class="headerlink" title="32位指令分析"></a>32位指令分析</h2><blockquote><p>32位处理器使用相同的编码格式，但寻址方式和寄存器的定义是完全不同于16位的</p></blockquote><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">edx</span>,[<span class="hljs-built_in">eax</span>+<span class="hljs-number">0x02</span>]</code></pre></div><p>NASM编译上述指令，发现机器码为66 67 8b 50 02</p><img src="/2022/09/07/22-0907-01/image-20220908152526131.png" class="" title="image-20220908152526131"><p>先分析 8b 50 02</p><ul><li><p>内存单元到寄存器的传送指令用了操作码0x8b</p></li><li><p>在8b之后是1字节的寻址方式和操作类型部分</p><ul><li><p>50的二进制即1001 0000</p><img src="/2022/09/07/22-0907-01/image-20220908153101819.png" class="" title="image-20220908153101819"></li><li><p>位7和位6的值为01，表示使用了<code>基址寻址方式</code>，而且带有8位的偏移量</p></li><li><p>位5~位3的值是010，表示目的操作数为寄存器<code>edx</code></p></li><li><p>位~位0的值是000，表示寻址方式为 “<code>eax+8位的偏移量</code>“</p></li></ul></li><li><p>02</p><ul><li>02表示的就是一个字节的偏移量</li></ul></li></ul><blockquote><p>通过对比，我们发现：</p><ul><li><p>相同的机器指令，在16位模式下和32位模式下的解释和执行效果是不同的</p></li><li><p>32位处理器可以执行16位的程序，包括实模式和保护模式（16位也是有保护模式的）</p><ul><li>在16位模式下，处理器把所有的指令都看成16位的<ul><li>比如：16位模式下，inc ax 对应机器码为 40</li></ul></li></ul></li><li><p>当32位处理器在16位模式下运行时也可以使用32位寄存器，执行32位运算，为此必须要使用指令前缀0x66来改变这种默认状态(0x66具有反转当前默认操作数大小的作用)</p><div class="code-wrapper"><pre><code class="hljs txt">如果处理器运行在32位模式下，处理器认为指令是32位的，如果加了0x66，那么就表示指令的操作数是16位的。[16位模式下]mov cx,dx      ;89 D1mov eax,ebx    ;66 89 D8[32位模式下]mov cx,dx      ;66 89 D1mov eax,ebx    ;89 D8</code></pre></div></li></ul></blockquote><h1 id="伪指令bits"><a href="#伪指令bits" class="headerlink" title="伪指令bits"></a>伪指令bits</h1><blockquote><p>在编写程序时候就要考虑到指令的运行环境，编译器提供了伪指令bits，用于指明其后的指令应该被编译成16位还是32位</p><p>注意：如果没有指定就是默认的16位</p></blockquote><div class="code-wrapper"><pre><code class="hljs txt">bits 16;等价于[bits 16]，两种写法一样mov cx,dx;nasm编译后的机器码 89 d1mov eax,ebx;nasm编译后的机器码 66 89 d8bits 32mov cx,dx;nasm编译后的机器码 66 89 d1mov eax,ebx;nasm编译后的机器码 89 d8</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>x86保护模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>x86保护模式day5</title>
    <link href="/2022/08/21/22-0821-05/"/>
    <url>/2022/08/21/22-0821-05/</url>
    
    <content type="html"><![CDATA[<h1 id="现代处理器的结构和特点"><a href="#现代处理器的结构和特点" class="headerlink" title="现代处理器的结构和特点"></a>现代处理器的结构和特点</h1><h2 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h2><p>在8086处理器时候，就已经有了指令预取，当指令执行时，如果总线是空闲的，那么就可以在指令执行的同时，预取指令并同时译码</p><p>执行一条指令需要如下过程：<br>取指令—&gt;需要从内存中拿出指令—&gt;然后对指令进行译码—&gt;访问操作数和结果—&gt;并且进行移位、加法等其他任何操作</p><p>流水线可以提高CPU的执行效率，流水线把一条指令的执行过程分解成若干个细小的步骤，并分配给相对应的单元来完成，各个单元执行独立的，并行的</p><p>正常的指令执行的时长如下：</p><img src="/2022/08/21/22-0821-05/image-20220906174014271.png" class="" title="image-20220906174014271"><p>如果采用流水线的方式，在取指令的同时可以译码，在译码的同时还可以继续取指令（压榨CPU，让CPU不断工作，提高速度），如下：</p><img src="/2022/08/21/22-0821-05/image-20220906174023746.png" class="" title="image-20220906174023746"><h1 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h1><p>除了流水线会影响处理器速度外，影响处理器速度的另外一个因素是内存（即我们所说的存储器）。从处理器向外看，分别是寄存器、内存、硬盘，寄存器的速度非常快，其次是内存，最后是硬盘，硬盘速度相对要慢很多，在这种情况下，CPU的速度很快，这样就需要等待内存和硬盘这种速度比较慢的设备，CPU就无法全速运行，为了解决这个矛盾，高速缓存就出现了</p><p>高速缓存就是处理器和内存中的一个静态处理器，容量比较小，位置在处理器中，高速缓存会缓存程序在运行时具有的局部性规律（比如：判断程序经常执行一些指令和数据）</p><img src="/2022/08/21/22-0821-05/image-20220906174106020.png" class="" title="image-20220906174106020"><p>如果CPU要读取0x10，如果L1一级缓存中没有0x10，一级缓存会先去内存中读取数据0x10所在的页，然后CPU从高速缓存中读取0x10</p><img src="/2022/08/21/22-0821-05/image-20220906174318227.png" class="" title="image-20220906174318227"><h1 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h1><p>为了实现流水线技术，需要将指令拆分成更小的可独立执行的部分，即拆分成微操作，比如：加法指令，如果参与加法的数据不依赖前面指令的结果，那它可以完全提前把这加法指令执行了，把结果保存到缓存中，等到真正轮到这条指令执行的时候，再把缓存中的结果写入到内存中</p><p>如下指令，从内存地址0x20取数据，然后把数据和eax寄存器中的数据相加，并且把结果放到eax寄存器中</p><p>add eax,[0x20]</p><p>该指令可以拆分成两个微操作，一个操作是从内存中读取数据保存到临时寄存器，另一个用于将eax寄存器的值和临时寄存器的值相加，如下：</p><p>mov ebx,[0x20]</p><p>add eax,ebx</p><p>微操作的有很多优点，如下：</p><div class="code-wrapper"><pre><code class="hljs txt">push eax  ;该指令可以分成两部分，sub esp,4和mov [esp],eax然后执行call func，call指令在执行的时候，需要在栈保存返回地址，如果不用微操作，只有等待push eax完成后才可以执行call指令，但是如果采用微操作，就可以不用执行完push eax指令，在执行完sub esp,4后就可以执行call指令</code></pre></div><h1 id="寄存器重命名"><a href="#寄存器重命名" class="headerlink" title="寄存器重命名"></a>寄存器重命名</h1><div class="code-wrapper"><pre><code class="hljs txt">;mem1代表一个地址mov eax,[mem1]shl eax,3mov [mem2],eaxmov eax,[mem3]add eax,2mov [mem4],eax以上代码做了2件事情，但互不相干处理器为最后三条指令使用了另一个不同的临时寄存器，IA-32架构（x86架构）的处理器只有8个32位通用寄存器，因此我们奢求在每个计算中都使用新的寄存器，好在IA-32内部有大量的临时寄存器可以使用，处理器可以重命名这些寄存器以代表一个逻辑寄存器mov eax,[mem1];该指令在高速缓存mov ebx,[mem2];该指令不在高速缓存add ebx,eaxadd eax,3;这里的eax实际是重命名后的另一个临时寄存器mov [mem3],eax;在所有的操作完成后，那个代表eax的临时寄存器的内容被写入真实的eax寄存器，该过程称为隐退mov [mem4],ebx</code></pre></div><h1 id="分支目标预测"><a href="#分支目标预测" class="headerlink" title="分支目标预测"></a>分支目标预测</h1><p>因为流水线并不是百分之百的完美解决方案，如果我们遇到一个判断的指令，类似如下的逻辑：</p><img src="/2022/08/21/22-0821-05/image-20220906174641097.png" class="" title="image-20220906174641097"><p>如果x&gt;0，则执行a…，如果不是，则执行b…。因为流水线是乱序执行的，那么就有可能不符合if的判断逻辑，肯定是不合适的，所以当遇到条件判断时，需要进行分支预测</p><p>如下：如果在遇到分支跳转的时候，大部分会去A分支，那么后续去A分支的概率也会特别大</p><img src="/2022/08/21/22-0821-05/image-20220906174647713.png" class="" title="image-20220906174647713"><p>分支预测如何实现的呢 ？？？</p><p>在处理器内部有一个小容量的高速缓存器叫做分支目标预测器（BTB），当处理器执行了一条分支语句后，它会在BTB中记录当前指令的地址、分支目标的地址，以及本次分支预测的结果，下一次，在那条转移指令实际执行前，处理器会查找BTB，看有没有最近的转移记录，如果有对应的条目，则推测执行和上一次相同的分支，把该分支的指令送入流水线，当指令实际执行时，如果预测是失败的，那么清空流水线，同时刷新BTB的记录，代价比较大，但是90%的情况下是对的</p><p>比如，如下的条件判断代码：</p><div class="code-wrapper"><pre><code class="hljs txt">if（x&gt;16）&#123;echo 666;&#125;else&#123;echo 777&#125;</code></pre></div><img src="/2022/08/21/22-0821-05/image-20220906191803119.png" class="" title="image-20220906191803119"><p>假如通过分支预测，预测A分支会被执行，那么会将<code>echo 666</code>代码直接送到流水线上进行执行，提前执行<code>echo 666</code>代码。如果x的值为30，大于16，那么我们预测的是正确的，并且提前执行了正确的结果。但如果x的值为10，那么如果我们提前执行了<code>echo 666</code>代码，这种是预测失败的，预测失败后，会清空流水线的内容，清空BTB的内容，然后重新执行另一条分支，这个就是回滚</p><p>分支预测的结果会保存到缓存中，这样执行的结果就会快很多，当真正执行完后，再把缓存的内容放到内存中，有如下分支：</p><img src="/2022/08/21/22-0821-05/image-20220906200016144.png" class="" title="image-20220906200016144"><p>如果预测的是是A分支，A分支是执行指令①，指令的执行就需要通过寄存器来存储数据，那么就会影响一些寄存器的变化，如eax、ebx、eflags等，假如指令①执行前ebx&#x3D;0，eax&#x3D;2，那么执行完指令①之后，ebx&#x3D;3，eax&#x3D;5，且指令①的执行结果666会被保存到高速缓存中。但如果预测失败了，应该是执行B分支才对，但是我们预测的是A分支，所以需要回滚</p><img src="/2022/08/21/22-0821-05/image-20220906201217911.png" class="" title="image-20220906201217911"><p>回滚时，首先会把寄存器ebx和eax进行回滚，让ebx&#x3D;0，eax&#x3D;5，但是高速缓存中的内容不会进行回滚，这样就会导致安全问题，即所谓的熔断和幽灵</p><h1 id="侧信道攻击"><a href="#侧信道攻击" class="headerlink" title="侧信道攻击"></a>侧信道攻击</h1><p>侧信道攻击不通过直接窃取信息来获取信息。相反，他们通过“旁门左道”窃取信息</p><p>假如我们密码如下：</p><img src="/2022/08/21/22-0821-05/image-20220906174713667-16624576338971.png" class="" title="image-20220906174713667"><p>然后我们来猜解密码，我们输入ABCDE，首先会枚举密码的第一位，也就是A，由于正确密码的第一位为N，很显然匹配不上，所以会马上返回，返回时间是1ms。如果我们输入NQWER，首先会枚举密码第一位，也就是N，恰好与正确密码的第一位匹配，所以还要继续匹配第二位密码，所以返回时间要长一些，返回的时间是2ms。</p><h1 id="漏洞分析：熔断和幽灵"><a href="#漏洞分析：熔断和幽灵" class="headerlink" title="漏洞分析：熔断和幽灵"></a>漏洞分析：熔断和幽灵</h1><h2 id="Meltdown（熔断）漏洞"><a href="#Meltdown（熔断）漏洞" class="headerlink" title="Meltdown（熔断）漏洞"></a>Meltdown（熔断）漏洞</h2><div class="code-wrapper"><pre><code class="hljs txt">;rcx = 内核地址;rbx = 探测数组① mov al,byte [rcx] ;访问内核地址的内容，注意：用户程序肯定访问不到内核地址，但是乱序执行会先把指令先执行了，然后把结果放到高速缓存，然后操作系统来判断该指令有没有这个执行的权限，然后肯定会判断出当前指令没有权限执行，然后再回滚寄存器，但是这个执行的结果已经放到缓存中了② shl rax,0xc;左移12位，即rax乘4096，这里为啥乘4096呢？？为了把rax搞成一个内存页，因为保护模式是按照内存页来管理的，一个内存页就是4KB（4096个字节）③ mov rbx,qword [rbx + rax]</code></pre></div><p>Meltdown（熔断）漏洞分析过程：</p><ol><li><p>指令解码</p></li><li><p>乱序执行，所以会提前执行指令①，然后会把指令①的执行结果放到高速缓存中，假如<code>mov al,byte [rcx]</code>执行后的结果al&#x3D;0x61，那么会把0x61放到高速缓存中</p><img src="/2022/08/21/22-0821-05/image-20220906204822920.png" class="" title="image-20220906204822920"></li><li><p>然后指令②会把rax乘4096，即0x61×4096，也就是rax&#x3D; 0x61×4096</p></li><li><p>而指令③中的内存单元地址[rbx+rax]，即[rbx+0x61×4096]，假如rbx探测数组如下，数组首地址下标为0x100</p><img src="/2022/08/21/22-0821-05/image-20220906212041919.png" class="" title="image-20220906212041919"><p>即[rbx+0x61×4096]&#x3D;[rbx数组的首地址+0x61+44096]&#x3D;[0x100+0x61×4096]，[0x100+0x61×4096]地址也就是一个线性地址，假如0x100+0x61×4096&#x3D;1100，那么该线性地址即为[0x1100]，如下：</p><img src="/2022/08/21/22-0821-05/image-20220906212139261.png" class="" title="image-20220906212139261"></li><li><p>然后进行安全检测，操作系统会判断出指令①没有权限，所以会进行回滚，rax、rbx会变成执行指令①之前的状态，但是高速缓存中已经有了rcx地址的内容0x61</p></li><li><p>指令③<code>mov rbx,qword [rbx + rax]</code>会把内存地址<code>[rbx + rax]</code>的内容放到rbx中，也就会访问到内存，由于高速缓存，我们访问[0x1100]这个地址的内容一定会更快（因为高速缓存中已经有了内核地址rcx），当然，我们就可以根据0x1100这个地址反推出内核地址的内容，（0x1100-100）÷4096&#x3D;0x61，即反推出内核地址内容0x61</p></li></ol><h2 id="Spectre（幽灵）漏洞"><a href="#Spectre（幽灵）漏洞" class="headerlink" title="Spectre（幽灵）漏洞"></a>Spectre（幽灵）漏洞</h2><div class="code-wrapper"><pre><code class="hljs txt">if(x&lt;array1.size)&#123;y=array2[array1[x]*256]&#125;</code></pre></div><p>Spectre（幽灵）漏洞分析过程：</p><ol><li><p>假如让array1数组等于B数组，让array2数组等于A数组，A数组为18个字节，B数组为2个字节，具体如下：</p><p>注意：该图中A数组中保存的是字符，一个字符为两个字节，即9个字符</p><img src="/2022/08/21/22-0821-05/image-20220906214850199.png" class="" title="image-20220906214850199"></li><li><p>如果x&#x3D;10，代码即如下</p><div class="code-wrapper"><pre><code class="hljs txt">if(x&lt;B.size)&#123;y=A[B[x]*256]&#125;即if(x&lt;2)&#123;y=A[B[10]*256]&#125;</code></pre></div><p>注意：由于数组B只有2个字节大小，所以B[10]就会出现数组越界的情况</p><p>如果数组越界，刚好到用户密码的起始区域，用户密码的第一个字节为0x10</p><img src="/2022/08/21/22-0821-05/image-20220906220623603.png" class="" title="image-20220906220623603"><p>那么<code>B[10]*256=0x10*256</code>，<code>A[B[10]*256]=0x10*256=0x2560</code>，然后我们在访问A数组时，发现访问E这个字符特别快，然后根据字符E的地址0x2560可以反推出用户密码数组中的内容0x10</p><img src="/2022/08/21/22-0821-05/image-20220906220950609.png" class="" title="image-20220906220950609"></li></ol>]]></content>
    
    
    <categories>
      
      <category>x86保护模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>转载：CPU的熔断幽灵</title>
    <link href="/2022/08/21/22-0821-06/"/>
    <url>/2022/08/21/22-0821-06/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载：<br><a href="https://blog.csdn.net/xuanyuan_fsx/article/details/106052513">https://blog.csdn.net/xuanyuan_fsx/article/details/106052513</a></p></blockquote><h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>我叫阿Q，是CPU一号车间里的员工，我所在的这个CPU足足有8个核，就有8个车间，干起活来杠杠滴。</p><p>我所在的一号车间里，除了负责执行指令的我，还有负责取指令的小A，负责分析指令的小胖和负责结果回写的老K。</p><img src="/2022/08/21/22-0821-06/image-20220821125419547.png" class="" title="image-20220821125419547"><p>CPU的每个车间都有一堆箱子，人们把这些箱子叫做<code>寄存器</code>，我所在的一号车间也不例外，我们每天的工作就是不断执行指令，然后折腾这些箱子，往里面存东西取东西。</p><p>由于我们四个人的出色工作，一号车间业绩突出，在年会上还多次获得了最佳CPU核心奖呢。</p><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>我们每天都需要跟<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>打交道，不过由于内存这家伙实在太慢了，我们浪费了很多时间等待他给我们数据传输。</p><img src="/2022/08/21/22-0821-06/image-20220821125541494.png" class="" title="image-20220821125541494"><p>终于有一天，上面给我们下了命令，说竞争对手CPU的速度快赶上我们了，让我们想办法提升工作效率。这一下可难倒了我们，我们平时干活绝没有偷懒，要怪只能怪内存那家伙，是他拖了我们后腿。</p><p>一天晚上，我们哥四个在一起聚餐，讨论起上面的这道命令来，大家都纷纷叹气。</p><p>就在一筹莫展之际，老K提出了一个想法：“兄弟们，我发现了一个现象，<strong>咱们和内存打交道的时候，如果访问了某个地址的数据，它周围的数据随后也大概率会被访问到</strong>”，说到这里，老K停顿了一下。</p><img src="/2022/08/21/22-0821-06/image-20220821125634033.png" class="" title="image-20220821125634033"><p>我一边听一边想着，小A倒是先开口：“然后呢？你想表达什么意思？”</p><p>老K继续说道：“咱每次数据都找内存要，太慢了，我寻思在咱们车间划一块区域，结合我发现的那个现象，以后让内存一次性把目标区域附近的数据一起给我们，我们存在这块区域，后面在需要用到的时候就先去这里找，找不到再去找内存要，岂不省事？”</p><p>听老K这么一描述，感觉靠谱，我也赶紧附和：“好办法！你们看啊，这内存老是拖咱后退，但是这家伙一时半会也快不起来，要不咱先用这招试试，看看能不能加快一点工作效率，给上面也有个交代。”</p><p>说干就干，我们很快就付诸实践了，我们还给这技术取了个名字叫<code>缓存</code>，效果居然出奇的好，后来为了进一步优化，我们还把缓存分为了两块，一块离<a href="https://so.csdn.net/so/search?q=%E5%AF%84%E5%AD%98%E5%99%A8&spm=1001.2101.3001.7020">寄存器</a>很近叫一级缓存，剩下的叫二级缓存。一级缓存中进一步分了指令缓存和数据缓存两块。</p><img src="/2022/08/21/22-0821-06/image-20220821130113626.png" class="" title="image-20220821130113626"><p>我们车间的工作效率那是飞速提升，但不知道是谁走漏了风声，其他几个车间也知道了这项技术，纷纷效仿。</p><p>这天，为了业绩，我们决定再加第三级缓存，这次把空间弄大点，不过咱们车间地盘有点局促，放不下，我们偷偷给上面领导反馈了这事儿，想让领导帮我们协调一下。</p><p>领导倒是同意了，不过告诉我们他得一碗水端平，平衡各车间的利益。但是咱厂里空间也有限，不可能给每个车间都分配那么大的空间，于是决定由厂里统一安排一块大的区域，让各个车间来共享。没有办法，我们也只好同意了。</p><img src="/2022/08/21/22-0821-06/image-20220821131713172.png" class="" title="image-20220821131713172"><p>现在，我们用上了三级缓存技术，内存那家伙拖后腿的现象缓解了不少，相当部分时间我们都能从这三级缓存里面找到我们需要的数据。</p><h1 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h1><p>随着技术的发展，咱们CPU工厂的工作性能也是不断攀升，慢慢的，我们几个又开始闲下来了，因为我们实在太快了，尽管有了缓存，但我们还是有了不少闲暇时间。</p><p>这天我还是像往常一样，小A取指令去了，我们知道这得要点时间，于是我和小胖还有老K我们仨斗起了地主。</p><img src="/2022/08/21/22-0821-06/image-20220821133410193.png" class="" title="image-20220821133410193"><p>打了好几把，小A才气喘吁吁的回来，“小胖，该你去指令分析了，你起来让我来打几把”。小胖赶紧起身干活，换上了小A上桌。</p><p>就这样我们几个轮流工作，一直保持着三个人的斗地主牌桌。</p><p>没想到的是，没过多久，厂里领导过来视察了，正好撞见我们几个打牌，狠狠的训斥了我们一顿。</p><img src="/2022/08/21/22-0821-06/image-20220821133444813.png" class="" title="image-20220821133444813"><p>“你们几个上班时间玩得挺嗨啊”，领导的脸拉的老长。</p><p>“领导，我们没有偷懒，这取指令、译码、执行、回写几个步骤都得分步执行，但是我们工作太快，存储器跟不上我们，我们等得无聊打发时间嘛”，我上前解释到。</p><p>“干等着你们也可以提前做一些后面的准备工作嘛，不要浪费时间，让生产效率更上一层楼”，领导说完就离开了，留下我们几个面面相觑。</p><p>不过领导的一番话倒是如一记重锤敲在我的头上，对啊，我们有这打牌的时间不如提前把后续指令的准备工作先做了，肯定能提升不少效率呢！</p><p>我开始组织兄弟几个商讨方案，“兄弟们，我们最主要的时间都浪费在等待内存数据上了，如果我们能在等待的时间里把后续指令需要的数据提前准备到缓存中来，那可就节约不少时间了，不用每次都等那么久。”</p><img src="/2022/08/21/22-0821-06/image-20220821133557943.png" class="" title="image-20220821133557943"><p>老K听后很赞赏我的思路，并补充到：“<strong>不仅是准备工作，像有些指令，比如加法，如果参与加法的数据不依赖前面指令的结果，咱们完全可以提前把这加法指令执行了嘛，把结果保存在缓存中，等真正轮到这条指令执行的时候，再把缓存中的结果写到内存中，这不也是节约了时间吗</strong>”</p><p>大家开始头脑风暴起来，原来可以做的事情还这么多，之前光想着等靠要，现在要主动出击了，因为打乱了顺序提前会执行后面的指令，我们把这个技术叫做<code>乱序执行</code>.</p><p>“这次大家要保密哦，不能让隔壁车间知道咱们的这次讨论内容”，会议结束前，我提醒大家。</p><h1 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h1><p>按照这次会议讨论的结果，咱们第二天准备实行，不过刚一开始，就遇到了麻烦。</p><p>按照计划，我们在空闲时间里，会提前把后续要执行的指令能做的工作先做了，但麻烦的是我们遇到了一条判断指令，因为不知道最终结果是true还是false，我们没法知道后续是应该执行分支A的指令还是分支B的指令。不敢轻举妄动，怕一会做了无用功。</p><img src="/2022/08/21/22-0821-06/image-20220821134224810.png" class="" title="image-20220821134224810"><p>大家只好放弃了提前做准备工作的想法，还是一步步来。</p><p>不过很快我们发现，我们经常执行到这个判断指令，而且每次结果都是去执行A分支，从没有去过B分支。</p><img src="/2022/08/21/22-0821-06/image-20220821134335630.png" class="" title="image-20220821134335630"><p>于是我们几个又商量，发明了一种叫<code>分支预测</code>的技术，<strong>遇到分支跳转时，按照之前的经验，如果某个分支经常被执行，那后续再去这个分支的概率一定很大，那这样咱们预测后面会去到这个分支，就提前把这个分支后面指令能做的工作先做了</strong>。</p><p>果然，用上了<code>分支预测</code>和<code>乱序执行</code>后，我们车间的效率又狠狠的提升了一把，在工厂的集体大会上又一次表扬了我们，并且把我们的先进技术向全厂推广。</p><p>自从我们车间用上了<code>乱序执行</code>和<code>分支预测</code>后，生产效率那是大大提升，领导不仅在全厂的员工大会表扬了我们，还把这两项技术向全厂推广，在我们8个CPU核心车间都铺开了，性能甩开竞争对手CPU几条街。</p><p>可是，就在我们还沉醉在取得的成绩时，不知不觉我们竟埋下了灾难的种子······</p><img src="/2022/08/21/22-0821-06/image-20220821135249703.png" class="" title="image-20220821135249703"><p>事情还得从不久前的一个晚上说起。</p><h1 id="神秘代码"><a href="#神秘代码" class="headerlink" title="神秘代码"></a>神秘代码</h1><p>这天晚上，我们一号车间遇到了这样一段代码：</p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">uint8</span>_t <span class="hljs-built_in">array</span>1[<span class="hljs-number">160</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>&#125;;<span class="hljs-built_in">uint8</span>_t <span class="hljs-built_in">array</span>2[<span class="hljs-number">256</span> * <span class="hljs-number">512</span>];<span class="hljs-built_in">uint8</span>_t temp = <span class="hljs-number">0</span>;<span class="hljs-built_in">void</span> bad_guy(<span class="hljs-built_in">int</span> x) &#123;<span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">16</span>) &#123;temp &amp;= <span class="hljs-built_in">array</span>2[<span class="hljs-built_in">array</span>1[x] * <span class="hljs-number">512</span>];&#125;&#125;</code></pre></div><p>不到一会儿功夫，我们就执行了这个<code>bad_guy()</code>函数很多次，这不，又来了。</p><p>负责取指令的小A向内存那家伙打了一通电话，让内存把参数x的内容传输过来，我们知道，以内存那蜗牛的速度，估计得让我们好等。</p><p>这时，负责指令译码的小胖忍不住说了：“你们看，我们这都执行这个函数好多次了，每次的参数x都是小于16的，这一次估计也差不多，要不咱们启动<code>分支预测</code>功能，先把小于16分支里的指令先提前做一些？大家看怎么样”</p><img src="/2022/08/21/22-0821-06/image-20220821135655565.png" class="" title="image-20220821135655565"><p>我和负责数据回写的老K互相看了一眼，都点头表示同意。</p><p>于是，就在等待的间隙，我们又给内存那家伙打了电话，让他把<code>array1[x]</code>的内容也传过来。</p><p>等了一会儿，数据总算传了过来：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">x</span>: <span class="hljs-number">2</span><span class="hljs-attribute">array1</span>[x]: <span class="hljs-number">3</span></code></pre></div><p>拿到结果之后，我们开始一边执行<code>x&lt;16</code>的比较指令，一边继续打电话给内存索要<code>array2[3]</code>的内容。</p><p>比较指令执行的结果不出所料，果然是<code>true</code>，接下来就要走入我们预测的分支，而我们提前已经将需要的数据准备到缓存中，省去了不少时间。</p><p>就这样，我们成功的预测了后续的路线，我们真是一群机智的小伙伴。</p><img src="/2022/08/21/22-0821-06/image-20220821140235996.png" class="" title="image-20220821140235996"><h1 id="遭遇滑铁卢"><a href="#遭遇滑铁卢" class="headerlink" title="遭遇滑铁卢"></a>遭遇滑铁卢</h1><p>天有不测风云，不久，事情发生了变化。</p><p>“呀！比较结果是<code>false</code>，这一次的x比16大了”，我执行完结果后发现和我们预期的有了出入。</p><p>小A闻讯而来，“额，咱们提前执行了不该执行的指令不会有问题吧？”</p><img src="/2022/08/21/22-0821-06/image-20220821140404348.png" class="" title="image-20220821140404348"><p>老K安慰道：“没事儿，咱们只是提前把数据读到了我们的缓存中，没问题的，放心好啦”</p><p>我想了想也对，大不了我们提前做的准备工作白费了，没有多想就继续去执行&gt;16的分支指令了。</p><p>随后，同样的事情也时有发生，渐渐的我们就习惯了。</p><h1 id="灾难降临"><a href="#灾难降临" class="headerlink" title="灾难降临"></a>灾难降临</h1><p>夜越来越深，我们都有点犯困了，突然，领导来了一通电话，让我们放下手里的工作火速去他办公室。</p><p>我们几个不敢耽误，赶紧出发。</p><p>来到领导的办公室，里面多了两个陌生人，其中一个还被绑着，领导眉头紧锁，气氛很是紧张。</p><img src="/2022/08/21/22-0821-06/image-20220821140529860.png" class="" title="image-20220821140529860"><p>“阿Q啊，你知不知道你们新发明的<code>乱序执行</code>和<code>分支预测</code>技术闯了大祸了？”</p><p>我们几个一听傻眼了，“领导，这是从何说起啊？”</p><p>领导从椅子上站了起来，指着旁边的陌生人说到：“给你们介绍一下，这是操作系统那边过来的安全员，让他告诉你们从何说起吧！”</p><p>这位安全员向大家点了点头，指着被捆绑那人说道：“大家好，我们抓到这个线程在读取系统内核空间的数据，经过我们的初审，他交代了是通过你们CPU的<code>乱序执行</code>和<code>分支预测</code>功能实现的这一目的。”</p><p>我和小A几个一听都是满脸问号，我们这两个提升工作效率的技术怎么就能泄漏系统内核数据呢？</p><img src="/2022/08/21/22-0821-06/image-20220821140718910.png" class="" title="image-20220821140718910"><h1 id="真相大白"><a href="#真相大白" class="headerlink" title="真相大白"></a>真相大白</h1><p>安全员显然看出了我们的疑惑，指着被捆绑的那个线程说道：“你把之前交代的再说一遍”</p><p>“几位大爷，你们之前是不是遇到了分支预测失败的情况？”，那人抬头看着我们。</p><p>“有啊，跟这有什么关系？失败了很正常嘛，既然是预测那就不能100%打包票能预测正确啊”，我回答道。</p><p>“<strong>您说的没错，不过如果这个失败是我故意策划的呢？</strong>”</p><img src="/2022/08/21/22-0821-06/image-20220821140925900.png" class="" title="image-20220821140925900"><p>听他这么一说，我的心一下悬了起来，“纳尼，你干的？”</p><p>“是的，就是我，我先故意给你连续多次小于16的参数，误导你们，误以为后面的参数还是小于16的，然后突然来一个特意构造的大于16的参数，你们果然上钩了，预测失败，提前执行了一些本不该执行的指令。”</p><p>“那又如何呢？我们只是把后面需要的数据提前准备到了缓存中，并没有进一步做什么啊”，我还是不太明白。</p><p>“<strong>这就够了！</strong>”</p><p>“你小子都被捆上了，就别吊胃口了，一次把话说清楚”，一旁急性子的老K忍不住了。</p><img src="/2022/08/21/22-0821-06/image-20220821140943193.png" class="" title="image-20220821140943193"><p>“好好好，我这就交代。你们把数据提前准备到了缓存中，我后面去访问这部分数据的时候，发现比访问其他内存快了很多”</p><p>“那可不，我们的缓存技术可不是吹牛的！哎等等，怎么又扯到缓存上去了？”，老K继续问道。</p><p>那人继续说道：“<strong>如果我想知道某个地址单元内的值，我就以它作为数组的偏移，去访问一片内存区域。利用你们会提前预测执行而且会把数据缓存的机制。你们虽然预测失败了，但对应的那一块数据已经在缓存中了，接着，我依次去访问那一片内存，看看谁的访问时间明显比其他部分短，那就知道哪一块被缓存了，再接着反推就能知道作为偏移的数值是多少了</strong>，按照这个思路我可以知道每一个地址单元的内容”</p><img src="/2022/08/21/22-0821-06/image-20220821141014291.png" class="" title="image-20220821141014291"><p>我们几个一边听着一边想着，琢磨了好一会儿总算弄清楚了这家伙的套路，老K气得火冒三丈，差点就想动手修理那人。</p><p>“好你个家伙，倒是挺聪明的，可惜都不用在正途上！好好的加速优化机制竟然成为了你们的帮凶”，我心中也有一团火气。</p><h1 id="亡羊补牢"><a href="#亡羊补牢" class="headerlink" title="亡羊补牢"></a>亡羊补牢</h1><p>事情的真相总算弄清楚了，我们几个此刻已经汗流浃背。</p><p>经过和安全员的协商，操作系统那边推出了全新的<code>KPTI</code>技术来解决这个问题，也就是<code>内核页表隔离</code>。</p><img src="/2022/08/21/22-0821-06/image-20220821142034063.png" class="" title="image-20220821142034063"><p>以前的时候，线程执行在用户态和内核态时用的是同一本地址翻译手册，也就是人们说的<code>页表</code>，通过这本手册，我们CPU就能通过虚拟地址找到真实的内存页面。</p><p>现在好了，让线程运行在用户态和内核态时使用不同的手册，用户态线程的手册中，内核地址空间部分是一片空白，来一招釜底抽薪！</p><p>本以为我们可以回去了，没想到领导却给我们出了难题，“这祸是你们闯下的，人家操作系统那边虽然做了保护，你们是不是也该拿出点办法来呢，要不然以后我们CPU还怎么抬得起头来？”</p><p class="note note-secondary">    本文描述的是两年前爆发的大名鼎鼎的CPU的熔断与幽灵漏洞。<br/>    乱序执行与分支预测是现代处理器普遍采用的优化机制。和传统软件漏洞不同，硬件级别的漏洞影响更大更深也更难以修复。<br/>    通过判断内存的访问速度来获知是否有被缓存，这类技术有一个专门的术语叫侧信道，即通过一些场外信息来分析得出重要结论，进而达成正常途径无法达成的目的]]></content>
    
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>x86保护模式day4</title>
    <link href="/2022/08/21/22-0821-04/"/>
    <url>/2022/08/21/22-0821-04/</url>
    
    <content type="html"><![CDATA[<h1 id="磁盘数据寻址方式"><a href="#磁盘数据寻址方式" class="headerlink" title="磁盘数据寻址方式"></a>磁盘数据寻址方式</h1><p>访问硬盘上的数据都是以扇区为单位进行的，即每次读或写至少是一个扇区的数据，不肯能仅仅读写一个扇区中的几个字节</p><p>常用的磁盘寻址方式有二种方式：</p><ol><li>CHS（物理寻址方式）</li><li>LBA（逻辑寻址方式）</li></ol><p>物理寻址（CHS方式）：</p><p>物理寻址方式又称为CHS（Cylinder柱面&#x2F;Head磁头&#x2F;Sector扇区）方式，用柱面号（即磁道号）、磁头号（即盘面号）和扇区号来表示一个特定扇区。柱面和扇区从0开始编号，而扇区从1开始编号的</p><div class="code-wrapper"><pre><code class="hljs TXT"> 磁盘容量=磁头数×柱面数×扇区数×512字节</code></pre></div><p>系统在写入数据时是按照从柱面到柱面的方式，当上一个柱面写满数据后才移动磁头到下一个柱面，而且是从柱面的第一个磁头的第一个扇区开始写入，从而使磁盘性能最优</p><p>逻辑寻址（LBA方式）：</p><p>寻址方式也改为以扇区为单位的线性寻址，这种寻址方式便是LBA。即将所有的扇区统一编号。C&#x2F;H&#x2F;S中的扇区编号是从“1”至“63”，而逻辑扇区LBA方式下扇区是从“0”开始编号，所有扇区编号按顺序进行。</p><p>对于任何一个硬盘，都可以认为其扇区是从0号开始</p><p>day3 中分析的代码 c08_mbr.asm 就是采用了LBA方式来访问，而LBA又分为如下两种：</p><ol><li>LBA 28：采用28个比特来表示逻辑区号，0x000 0000 ~ 0xfff ffff （这里用的是 LBA 28）</li><li>LBA 48：采用48个比特来表示逻辑区号，同上</li></ol><h1 id="通过硬盘控制端口读取扇区的数据"><a href="#通过硬盘控制端口读取扇区的数据" class="headerlink" title="通过硬盘控制端口读取扇区的数据"></a>通过硬盘控制端口读取扇区的数据</h1><p>因为被加载器加载的用户程序实际是位于硬盘上面的，并且用户程序在磁盘上是以扇区为单位存放。而硬盘和CPU之间是通过I&#x2F;O接口进行通信的，更细致来说是通过I&#x2F;O接口上的端口来打交道，而端口的实质就是寄存器。</p><h2 id="第一步，设置读取扇区数量"><a href="#第一步，设置读取扇区数量" class="headerlink" title="第一步，设置读取扇区数量"></a>第一步，设置读取扇区数量</h2><p>个人PC的主硬盘控制器被分配了8位端口，端口号是从0x1f0~0x1f7，如果我们要读取硬盘逻辑扇区上的内容，那么首先要确定读取几个扇区，然后把读取扇区的数量写入0xf12端口，如下：</p><div class="code-wrapper"><pre><code class="hljs txt">;设置读写几个扇区mov dx,0x1f2mov al,0x01;读一个扇区out dx,al</code></pre></div><p>如下图（注意鑫哥讲课没有作图，这里自己作图只是方便理解，不一定正确）：</p><img src="/2022/08/21/22-0821-04/image-20220906162753261.png" class="" title="image-20220906162753261"><h2 id="第二步，设置起始的扇区号"><a href="#第二步，设置起始的扇区号" class="headerlink" title="第二步，设置起始的扇区号"></a>第二步，设置起始的扇区号</h2><p>然后我们还要确定到底是从哪个扇区开始读取，即设置起始的扇区号，这里我们从2号扇区开始读写，那么我们就可以把2号扇区号放入端口中</p><p>特别注意，LBA 28 采用了28位比特来表示扇区号，但是这里0x1f3端口等这些端口都是8位的，所以一个0x1f3端口肯定是无法存放28位比特的扇区号的，所以这里采用多个端口来存放，如下，0x1f3端口中存放 0 ~ 7 位，然后0x1f4存放 8 ~ 15 位，然后0x1f5存放 16 ~ 23 位，最后用0x1f6存放 24 ~ 27 位。</p><div class="code-wrapper"><pre><code class="hljs txt">;设置读写几个扇区mov dx,0x1f2mov al,0x01;读一个扇区out dx,al      ;设置起始扇区号，这里从2号扇区开始读写，由于用28位比特表示扇区号，从高位到低位也就是0000 0000 0000 0000 0000 0000 0002mov dx,0x1f3mov al,0x02out dx,al;这里0x1f3保存了0~7位，即0000 0002inc dx;dx为0x1f4mov al,0x00out dx,al;这里0x1f4保存了7~15位，即0000 0000inc dx;dx为0x1f5out dx,al;这里al的值还是0x00，并且这里0xf5保存了16~23位，即0000 0000;最后只需要用0x1f6来保存最后的高四位24~27即可，即用0x1f6保存最高位的0000inc dx;dx为0x1f6mov al,0xe0;但是要注意，为啥这里保存的是的0xe0，而不是0x00呢？？？这是为啥呢out dx,al</code></pre></div><p>如下图：</p><img src="/2022/08/21/22-0821-04/image-20220906163104891.png" class="" title="image-20220906163104891"><p>我们注意到上面的代码中，0xf16这个端口存放了扇区号的24~27位，但是为啥保存的是0xe0呢 ？？？</p><p>因为0xf16这些端口实际类似于寄存器，也是8位的，对于0xf16端口结构大致如下：</p><img src="/2022/08/21/22-0821-04/image-20220906163121936.png" class="" title="image-20220906163121936"><p>而0xe0对应的二进制为 1110 0000，那么低四位存放的就是扇区号 0000，而高四位存放的就是 1110，就表示是LBA模式</p><h2 id="第三步，向端口0x1f7写入0x20，请求硬盘进行读写"><a href="#第三步，向端口0x1f7写入0x20，请求硬盘进行读写" class="headerlink" title="第三步，向端口0x1f7写入0x20，请求硬盘进行读写"></a>第三步，向端口0x1f7写入0x20，请求硬盘进行读写</h2><p>上面我们已经把2号逻辑扇区写入端口了，但是由于硬盘有多个扇区，而我们只是要读取2号扇区的内容，所以这里还要让硬盘来读取2号扇区的内容，那么如何操作呢 ？？？</p><p>只需要向端口0x1f7写入0x20就可以请求硬盘读取（0x20表示读、0x30表示写），代码如下：</p><div class="code-wrapper"><pre><code class="hljs txt">mov dx,0x1f7mov al,0x20;读命令out dx,al</code></pre></div><p>如下图：</p><img src="/2022/08/21/22-0821-04/image-20220906163155399.png" class="" title="image-20220906163155399"><h2 id="第四步，等待硬盘读写完成"><a href="#第四步，等待硬盘读写完成" class="headerlink" title="第四步，等待硬盘读写完成"></a>第四步，等待硬盘读写完成</h2><p> 由于端口是 0x1f7 即是命令端口还是状态端口，通过端口发送读命令后，硬盘就开始忙了，然后会将0x1f7的第位置为1，来表示自己很忙。如果读完后，硬盘准备就绪后，0x1f7就会将第7位清零，表示自己忙完了，然后将第三位设置成1，表示主机已经准备好了，可以让CPU从硬盘进行读取数据或者接受数据</p><p>代码如下：</p><div class="code-wrapper"><pre><code class="hljs txt">.waits:       in al,dx       and al,0x88;0x88对应的二进制为：10001000       cmp al,0x08;0x08对应的二进制为：00001000       jnz .waits;如果忙的话，就继续循环跳转到.waits       ;如果不忙，且硬盘已准备好数据传输，继续向下执行       ;连续取出数据       mov cx,256;总共要读取的字数       mov dx,0x1f0;0x1f0表示硬盘的数据端口（0x1f0为16位）</code></pre></div><h2 id="第五步，CPU通过0x1f0数据端口从硬盘读取到数据"><a href="#第五步，CPU通过0x1f0数据端口从硬盘读取到数据" class="headerlink" title="第五步，CPU通过0x1f0数据端口从硬盘读取到数据"></a>第五步，CPU通过0x1f0数据端口从硬盘读取到数据</h2><p>一旦硬盘空闲并且准备就绪，就可以连续从这个端口 0x1f0 写入或者读出数据，读出来的数据存放到由DS寄存器指定的数据段，偏移地址为BX的地方。</p><p>如下：</p><img src="/2022/08/21/22-0821-04/image-20220906164050252.png" class="" title="image-20220906164050252"><p>在 c08_mbr.asm 的代码中，如下代码就是把硬盘数据读取出来</p><div class="code-wrapper"><pre><code class="hljs txt">.readw:       in ax,dx       mov [bx],ax       add bx,2       loop .readw       pop dx       pop cx       pop bx       pop ax           ret</code></pre></div><h1 id="重新计算段地址和偏移地址"><a href="#重新计算段地址和偏移地址" class="headerlink" title="重新计算段地址和偏移地址"></a>重新计算段地址和偏移地址</h1><p>在 c08_mbr.asm 加载器代码中，CPU读取到硬盘数据后，需要加载到内存中，然后还要重新计算段地址和偏移地址 ，我们指定了用户程序被加载的物理地址 0x10000，这个地理地址在实模式下要转为逻辑地址（段地址：偏移地址这种形式），我们知道在把asm文件编译成lst文件后，lst文件中的汇编地址就是实际加载到内存后和偏移地址的值是一样的。如下：</p><img src="/2022/08/21/22-0821-04/image-20220906164203330.png" class="" title="image-20220906164203330"><p>程序加载到 0x10000 这个物理地址，该物理地址对应的段地址为1000，偏移地址为0，即CS:IP &#x3D; 1000:0000，由于lst文件中的汇编地址实际和加载到内存后偏移地址是一样的，也就是偏移 0xc ，那这里为啥不直接用 1000:0xc 来表示code1段的地址呢 ？？？而是重新来计算段地址和偏移地址呢 ？？？</p><p>因为程序中一个段的大小是64KB（0000h~ffffh），如果程序大于64KB，那可能需要占用好几个段，每个段的地址肯定是不一样的，那么就需要重新来计算每个段的段地址和偏移地址，在 c08_mbr.asm 代码中如下：</p><img src="/2022/08/21/22-0821-04/image-20220906164212360.png" class="" title="image-20220906164212360"><p>tmd，这里  c08_mbr.asm 文件中的代码直接懵逼，后面有机会再看（狗头保命）</p><h1 id="中断回顾"><a href="#中断回顾" class="headerlink" title="中断回顾"></a>中断回顾</h1><p>Intel处理器有256个中断，中断号的范围为0~255。中断的含义即打断当前处理器的执行流程，比如：正在打游戏，突然来电话，那么你是打游戏还是接电话呢 ？？？</p><p>外部硬件中断</p><p>外部硬件中断就是处理外部设备的中断，比如：处理器控制打印机打印，打印机打印完成后，打印机需要告诉处理器已经打印完成，外部中断需要通过两根线与处理器连接，一根线叫做 NMI，另一根线叫做 INTR，如下：</p><img src="/2022/08/21/22-0821-04/image-20220906164233726.png" class="" title="image-20220906164233726"><p>不可屏蔽中断有一个中断号为2，不可屏蔽中断错误是非常致命的，在这种情况下，如果你想搞清楚发生了啥，通常是没啥意义，因为错误太严重了，通常系统会提示了信息，比如电脑蓝屏，然后我们去找工作人员维修即可</p><p>当然，通常我们学习的都是可屏蔽中断，比如：键盘向处理器发送ascii码时，处理器可以处理也可以不处理。可屏蔽中断这里只有一根线（一个引脚），只能处理一次中断，但是我们有很多中断，如果多个中断同时发生咋办 ？？？</p><p>所以就需要用 8259芯片（中断控制器）帮助处理器来控制中断，如果多个设备同时发生了中断，8259芯片就会根据自己的配置来设置中断号，以防止冲突，并且控制中断的优先级。</p><p>标志寄存器中，当 IF&#x3D;0，处理器忽略中断信号；当 IF&#x3D;1，处理器可以接受和响应中断，我们可以通过指令 cli 和 sti 来进行修改</p><p>中断向量表：自行回顾masm汇编的笔记</p><p>内部中断：发生在处理器内部，比如之前讲过的除法溢出问题</p><p>软中断：由int指令引起的中断（注意：int3 和 int 3 指令是有区别的，int3翻译成机器码是cc，而 int 3 翻译成机器码是cd03）</p><p>溢出中断：into指令可以引发溢出中断，固定为4号中断，当标志位为1时，表示溢出，溢出就可以用into指令来引发4号中断</p><p>我们经常在masm汇编时用到 int 21h、mov ax,4c00h，实际这就是调用了中断，解释如下：</p><p>int 21h 调用了系统中断，而 mov ax,4c00h 起的作用就是 ah&#x3D;4ch，意思就是调用 int 21h 的 4ch 号中断，该中断就是安全退出程序</p><h1 id="32位x86处理器编程结构（80386）"><a href="#32位x86处理器编程结构（80386）" class="headerlink" title="32位x86处理器编程结构（80386）"></a>32位x86处理器编程结构（80386）</h1><p>前面讲解的都是16位的8086处理器，后面来学习32位的x86处理器</p><p>32位x86处理器是兼容16位的8086处理器的，Intel 32 位处理器架构简称 IA-32，前面学习的都是16位的8086处理器，而32位的处理器也是由16位的8086处理器发展而来</p><p>32位的处理器有32位地址线（4GB），32位处理器的功能就是特别复杂了，其中32位的架构包含如下内容：</p><p>高速缓存、流水线、浮点处理器、多核管理、乱序执行、分支预测、虚拟化、温度、电源管理 等等</p><p>除此之外32位处理器还在16位的基础上，扩展了通用寄存器的长度：EAX、EBX、ECX、EDX、ESI、EDI、ESP、EBP、EIP、EFLAGS（标志寄存器），我们可以在程序中直接使用这些寄存器，即使是在实模式下（注意：mov eax,0xF5，这里的F5默认就是表示的 0x000000F5）</p><p>这里要注意，在32位处理器下，CS、SS、DS、ES 还是不变的，还是16位的，和16位处理器下是一样的，但是在32位模式下，传统的CS、SS、DS、ES 保存的不再是16位的段基址，而是保存的段选择子（也可以称为段选择器）， 真正的段地址位于段寄存器的描述符高速缓冲器中，并且32位处理器额外增加了 FS、GS 两个段寄存器</p><p>32位的通用寄存器高16位是不可拆分独立使用的，但是低16位可以像16位处理器那样拆分成2个8位使用</p><p>32位处理器有自己的工作模式，也就是保护模式</p><p>32位处理器有两个模型，一个是分段模型（前面的学习已经讲过分段结构），另一个是平坦模型（不分段，即只分一个段，段地址:0x00000000，段的长度为4GB，这种模型下没有段地址+偏移地址）</p><p>在前面学习过的16位处理器中，我们可以自由进行修改，可以访问内存中任意一个位置的空间，比如：在自己的程序中，我们可以通过jmp指令跳转到别人的程序中，这样显然是十分不安全的。所以在32位处理器中，在加载程序时，会先定义该程序拥有的段（也就是段描述符表），会对程序进行一些限制，来防止对内存的违规访问。</p><p>在8086处理器之后，intel公司又一次退出了80286处理器，该处理器有24根地址线，可以访问16M的内存，并且第一次提出了保护模式的概念</p><p>当然我们现在说的保护模式都是指80386处理器（32位处理器），兼容16位处理器，电脑（处理器）刚开机加电时，都是处于实模式下，进行一番设置后，就会运行在保护模式下</p><h1 id="线性地址（逻辑地址）"><a href="#线性地址（逻辑地址）" class="headerlink" title="线性地址（逻辑地址）"></a>线性地址（逻辑地址）</h1><p>传统上，段的管理是由处理器的段部件负责的，段部件将段地址和偏移地址相加，得到访问内存的地址，一般来说，段部件产生的地址就是物理地址</p><p>处理器支持多任务，多任务环境下，任务创建需要分配内存空间，任务终止后还要回收内存空间。在分段的模式下，内存的分配是不定长度的，任务大分配空间就大，任务小分配的空间就小，如下：</p><img src="/2022/08/21/22-0821-04/image-20220906164607677.png" class="" title="image-20220906164607677"><p>这样的话，时间长了之后，内存空间就会碎片化，如下：</p><img src="/2022/08/21/22-0821-04/image-20220906164614438.png" class="" title="image-20220906164614438"><p>为了解决空间的碎片化，采取了分页功能，分页功能将物理内存空间划分成逻辑上的页，页的大小是固定的，一般为4096，也就是4KB，通过使用页，来简化内存管理</p><p>页功能开启后，段部件产生的地址就不再是物理地址了，而是线性地址，线性地址还要经过页部件转化后才是物理地址</p>]]></content>
    
    
    <categories>
      
      <category>x86保护模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>x86保护模式day3</title>
    <link href="/2022/08/21/22-0821-03/"/>
    <url>/2022/08/21/22-0821-03/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>操作系统（实际可以看成一个软件）往往肩负多种任务，如：处理器管理、内存分配、程序加载、进程调度、外围设备的控制（显卡、声卡等）</p><p>程序保存到硬盘上的，然后我们双击程序运行后，首先要读取硬盘，知道该程序保存到了硬盘的什么位置上（比如：该程序保存到了c盘上），然后会把程序加载到内存的空闲地址，载入内存后要重新计算程序的段地址，这就是段的重定位（重定位在前面学习过）</p><p>注意：操作系统下运行用户exe文件时，操作系统就类似于一个加载器来加载用户exe文件</p><p>该节课的任务：写一个加载器，充分理解段的重定位，也就是实模式下的分段内存管理机制</p><p>我们在学习16位汇编时，用的是segment来定义一个段，而在32位汇编中用 SECTION 来定义一个段， SECTION 后面是段的名称，如下：</p><img src="/2022/08/21/22-0821-03/image-20220906161129036.png" class="" title="image-20220906161129036"><p>注意： 在学习16位汇编时，在段的结束都有end，而32位不需要end</p><p>align&#x3D;16 表示含义是处理器要求段在内存中的起始物理地址必须是16字节对齐的，如下：</p><img src="/2022/08/21/22-0821-03/image-20220906161136108.png" class="" title="image-20220906161136108"><h2 id="16字节对齐"><a href="#16字节对齐" class="headerlink" title="16字节对齐"></a>16字节对齐</h2><p>为啥要进行16字节对齐呢 ？？？</p><p>因为16字节对齐后，才能保证偏移地址从0开始</p><p>如下：</p><img src="/2022/08/21/22-0821-03/image-20220906161144869.png" class="" title="image-20220906161144869"><h1 id="SECTION-段名称-start"><a href="#SECTION-段名称-start" class="headerlink" title="SECTION.段名称.start"></a>SECTION.段名称.start</h1><p>SECTION.段名称.start 表达式可以取得该段的汇编地址，比如下面的代码中：</p><img src="/2022/08/21/22-0821-03/image-20220906161509390.png" class="" title="image-20220906161509390"><h1 id="vstart"><a href="#vstart" class="headerlink" title="vstart"></a>vstart</h1><p>vstart的作用：声明的是该段的地址或者说段号，具体如下：</p><img src="/2022/08/21/22-0821-03/image-20220906161528556.png" class="" title="image-20220906161528556"><p>注意：如果段没有写vstart，那么该段的起始汇编地址是相当于整个程序开头来计算的，如下：汇编代码最后定义了一个trail段，并且没有写vstart，那么trail段中program_end标号的地址是相当于整个程序开头计算的，也就是整个程序的大小</p><img src="/2022/08/21/22-0821-03/image-20220906161536535.png" class="" title="image-20220906161536535"><h1 id="用户程序必要信息"><a href="#用户程序必要信息" class="headerlink" title="用户程序必要信息"></a>用户程序必要信息</h1><p>加载器加载用户程序就必须要了解用户程序必要信息（比如windows的PE格式），这些信息不是很多，但是足以让加载器了解如何来加载用户程序，一般来说，这些信息放在用户程序的头部，包含以下内容：</p><ol><li>程序的大小（以字节为单位，加载器会根据程序大小来读取多少个逻辑扇区）</li><li>用户程序的入口点</li><li>段重定位表项数</li><li>段重定位表</li></ol><p>补充，段重定位表的作用：有时候我们会把asm文件编译成lst列表文件，打开在lst文件后，我们可以看到编译后一些指令对应的汇编地址，但实际计算机执行的是bin文件，就是把bin文件加载到内存的空闲区域，这样在实际内存中，我们并不知道具体会把bin文件的内容加载到内存哪里，这与列表文件中对应的汇编地址是完全不同的。所以我们要知道程序中的段实际加载到内存的啥地方，我们就用重定位表来解决问题。但是由于计算机并不知道程序中一共有多少个段，所以我们还需要重新定位表项数</p><p>如下：在asm文件中定义了用户程序的必要信息：</p><img src="/2022/08/21/22-0821-03/image-20220906161600042.png" class="" title="image-20220906161600042"><h1 id="加载器工作流程"><a href="#加载器工作流程" class="headerlink" title="加载器工作流程"></a>加载器工作流程</h1><p>加载器工作流程：</p><ol><li>加载器要加载一个程序并让它开始执行，需要知道内存什么地方是空闲的，就是从哪个物理内存地址开始加载程序</li><li>加载器还要知道这个程序位于硬盘上的什么地方，即程序的逻辑扇区编号</li></ol><h1 id="输入输出设备（I-x2F-O设备）"><a href="#输入输出设备（I-x2F-O设备）" class="headerlink" title="输入输出设备（I&#x2F;O设备）"></a>输入输出设备（I&#x2F;O设备）</h1><p>在屏幕上显示内容，就需要显卡，而对于电脑外放声音，就需要声卡，而显卡、声卡这些就是I&#x2F;O接口，I&#x2F;O接口可以是一个电路板，也可以是一个芯片，I&#x2F;O接口就是一个信号处理器，负责把CPU的信号转换为外围设备能够接受的另一种信号，还会负责把外围设备信号转为CPU能够接受的信号</p><p>但是由于外围设备（键盘、显示器、音响等等）是特别多的，如果我们直接把这些I&#x2F;O接口和CPU进行连接的话，CPU上需要连接很多线，这显然是不合适的，与此同时，如果多个I&#x2F;O接口同时直接与CPU连接，那么每个设备的I&#x2F;O接口都会同时与CPU进行通信，造成冲突</p><p>既然I&#x2F;O不能进行直接和CPU进行连接，那么咋办呢 ？？？</p><ol><li><p>对于CPU上需要连接多条线，可以采用总线来解决</p></li><li><p>而对于I&#x2F;O接口会与CPU通信冲突，可以采用输入输出设备集中器（即南桥芯片）</p><img src="/2022/08/21/22-0821-03/image-20220906161629156.png" class="" title="image-20220906161629156"></li></ol><p>当CPU要和某个外围设备通信时，首先南桥芯片会接到通知，然后负责和相对应传输通道进行通信，并且如果CPU如果和USB接口进行通信，南桥芯片还会控制其它的接口不进行通信。实际CPU和外围设备通信就是和USB接口等这些I&#x2F;O接口的通信，也就是和端口通信</p><p>处理器通过端口来和外围设备通信，本质上，端口就是一些寄存器，跟处理器寄存器差不多，不同的是这些叫做端口的寄存器位于I&#x2F;O接口的电路中</p><p>每一个I&#x2F;O接口都可能拥有好几个端口，分别用于不同的目的。连接硬盘的PATA&#x2F;SATA接口就有几个端口，分别是命令端口，向这个端口写入0x20表示从硬盘读数据，写0x30表示写；状态端口，CPU根据这个端口来判断硬盘工作是否正常；参数端口，CPU通过这个端口告诉硬盘读写的扇区数量，以及起始的逻辑扇区号；数据端口，通过这个端口连续读写数据</p><p>端口在不同的计算机系统中有不同的实现方式，在一些计算机系统中，端口号是映射到内存地址空间的，在另外一些里面，端口又是独立编址的，不和内存发生关系</p><p>现在我们的系统既有内存映射又有独立编址</p><p>南桥芯片里集成了2个PATA&#x2F;SATA接口，分别是主硬盘接口和副硬盘接口。主硬盘分配的端口号是 0x1f0 ~ 0x1f7 ，副硬盘 0x170 ~ 0x177</p><p>端口访问指令：</p><div class="code-wrapper"><pre><code class="hljs txt">in al,dx  ;访问8位端口in ax,dx  ;访问16位端口in al,0xf0in ax,0xf0 out 操作数可以是8位立即数或DX ，源操作数必须是AL或AXout 0x37,alout 0x37,axout dx,alout dx,ax</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>x86保护模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>x86保护模式day2</title>
    <link href="/2022/08/21/22-0821-02/"/>
    <url>/2022/08/21/22-0821-02/</url>
    
    <content type="html"><![CDATA[<h1 id="数据段的基地址"><a href="#数据段的基地址" class="headerlink" title="数据段的基地址"></a>数据段的基地址</h1><div class="code-wrapper"><pre><code class="hljs x86asm">          <span class="hljs-keyword">jmp</span> <span class="hljs-built_in">near</span> start<span class="hljs-comment">;为啥开头要jmp指令，因为部分数据可能会被当成指令执行</span>       mytext <span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-number">0x07</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">0x07</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">0x07</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-number">0x07</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-number">0x07</span>,<span class="hljs-string">&#x27; &#x27;</span>,<span class="hljs-number">0x07</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-number">0x07</span>,<span class="hljs-string">&#x27;f&#x27;</span>,<span class="hljs-number">0x07</span>,<span class="hljs-string">&#x27;f&#x27;</span>,<span class="hljs-number">0x07</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-number">0x07</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-number">0x07</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-number">0x07</span>,<span class="hljs-string">&#x27;:&#x27;</span>,<span class="hljs-number">0x07</span>number <span class="hljs-built_in">db</span> <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span><span class="hljs-symbol"></span><span class="hljs-symbol">start:</span>       <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0x7c0</span>                  <span class="hljs-comment">;设置数据段基地址 </span>       <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span>              <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0xb800</span>                 <span class="hljs-comment">;设置附加段基地址 </span>       <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span>              <span class="hljs-keyword">cld</span><span class="hljs-comment">;标志寄存器第6位ZF 零标志位  第10位是DF direction flag 通过指令设置1或0，cld设置0，表示正方向</span><span class="hljs-comment">;std设置1，表示反方向  SF符号位 计算结果如果最高位是0  SF处理器自动设0  否则1 PF </span>       <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,mytext                        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">0</span>       <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,(number-mytext)/<span class="hljs-number">2</span>      <span class="hljs-comment">;实际上等于 13</span>       <span class="hljs-keyword">rep</span> <span class="hljs-keyword">movsw</span><span class="hljs-comment">;movsb  源</span>          <span class="hljs-comment">;得到标号所代表的偏移地址</span>       <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,number              <span class="hljs-comment">;计算各个数位</span>       <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-built_in">ax</span>       <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">5</span>                      <span class="hljs-comment">;循环次数 </span>       <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">10</span>                     <span class="hljs-comment">;除数 </span><span class="hljs-symbol">digit:</span>        <span class="hljs-keyword">xor</span> <span class="hljs-built_in">dx</span>,<span class="hljs-built_in">dx</span>       <span class="hljs-keyword">div</span> <span class="hljs-built_in">si</span>       <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>],<span class="hljs-built_in">dl</span>                   <span class="hljs-comment">;保存数位</span>       <span class="hljs-keyword">inc</span> <span class="hljs-built_in">bx</span>        <span class="hljs-keyword">loop</span> digit              <span class="hljs-comment">;显示各个数位</span>       <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,number        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">4</span>                      <span class="hljs-symbol"> show:</span>       <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[<span class="hljs-built_in">bx</span>+<span class="hljs-built_in">si</span>]       <span class="hljs-keyword">add</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0x30</span>       <span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-number">0x04</span>       <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">es</span>:<span class="hljs-built_in">di</span>],<span class="hljs-built_in">ax</span>       <span class="hljs-keyword">add</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">2</span>       <span class="hljs-keyword">dec</span> <span class="hljs-built_in">si</span>       <span class="hljs-keyword">jns</span> show               <span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> [<span class="hljs-built_in">es</span>:<span class="hljs-built_in">di</span>],<span class="hljs-number">0x0744</span>         <span class="hljs-keyword">jmp</span> <span class="hljs-built_in">near</span> $  <span class="hljs-built_in">times</span> <span class="hljs-number">510</span>-($-$$) <span class="hljs-built_in">db</span> <span class="hljs-number">0</span> <span class="hljs-comment">;  naizi: jmp near naizi/jmp near $  $表示当前行首的标号  $$代表当前汇编代码的起始汇编地址</span>                 <span class="hljs-built_in">db</span> <span class="hljs-number">0x55</span>,<span class="hljs-number">0xaa</span></code></pre></div><p>将上述asm文件编译成列表文件</p><img src="/2022/08/21/22-0821-02/image-20220906150250762.png" class="" title="image-20220906150250762"><p>编译后的列表文件的内容如下：</p><div class="code-wrapper"><pre><code class="hljs txt"> 1 00000000 E91F00                                 jmp near start 2                                            3 00000003 4C076107620765076C-       mytext db &#x27;L&#x27;,0x07,&#x27;a&#x27;,0x07,&#x27;b&#x27;,0x07,&#x27;e&#x27;,0x07,&#x27;l&#x27;,0x07,&#x27; &#x27;,0x07,&#x27;o&#x27;,0x07,&#x27;f&#x27;,0x07,&#x27;f&#x27;,0x07,&#x27;s&#x27;,0x07,&#x27;e&#x27;,0x07,&#x27;t&#x27;,0x07,&#x27;:&#x27;,0x07 3 0000000C 0720076F0766076607- 3 00000015 7307650774073A07    4                                   5 0000001D 0000000000                number db 0,0,0,0,0 6                                     7                                    start: 8 00000022 B8C007                           mov ax,0x7c0                  ;设置数据段基地址  9 00000025 8ED8                             mov ds,ax10                                           11 00000027 B800B8                           mov ax,0xb800                 ;设置附加段基地址 12 0000002A 8EC0                             mov es,ax13                                           14 0000002C FC                               cld;标志寄存器第6位ZF 零标志位  第10位是DF direction flag 通过指令设置1或0，cld设置0，表示正方向15                                  ;std设置1，表示反方向  SF符号位 计算结果如果最高位是0  SF处理器自动设0  否则1 PF 16 0000002D BE[0300]                         mov si,mytext                 17 00000030 BF0000                           mov di,018 00000033 B90D00                           mov cx,(number-mytext)/2      ;实际上等于 1319 00000036 F3A5                             rep movsw;movsb  源20                                       21                                           ;得到标号所代表的偏移地址22 00000038 B8[1D00]                         mov ax,number23                                           24                                           ;计算各个数位25 0000003B 89C3                             mov bx,ax26 0000003D B90500                           mov cx,5                      ;循环次数 27 00000040 BE0A00                           mov si,10                     ;除数 28                                    digit: 29 00000043 31D2                             xor dx,dx30 00000045 F7F6                             div si31 00000047 8817                             mov [bx],dl                   ;保存数位32 00000049 43                               inc bx 33 0000004A E2F7                             loop digit34                                           35                                           ;显示各个数位36 0000004C BB[1D00]                         mov bx,number 37 0000004F BE0400                           mov si,4                      38                                     show:39 00000052 8A00                             mov al,[bx+si]40 00000054 0430                             add al,0x3041 00000056 B404                             mov ah,0x0442 00000058 268905                           mov [es:di],ax43 0000005B 83C702                           add di,244 0000005E 4E                               dec si45 0000005F 79F1                             jns show 46                                           47 00000061 26C7054407                       mov word [es:di],0x0744  48                                  49 00000066 E9FDFF                           jmp near $ 50                                   51 00000069 00&lt;rep 195h&gt;              times 510-($-$$) db 0 ;  naizi: jmp near naizi/jmp near $  $表示当前行首的标号  $$代表当前汇编代码的起始汇编地址52 000001FE 55AA                                       db 0x55,0xaa</code></pre></div><p>分析：为啥要设置数据段的基地址为0x7c0 ？？？</p><p>程序加载后，如果是从偏移地址为0开始的</p><p>那么执行 jmp label_a，而如果 label_a 标号的偏移地址是0x08，所以这里 jmp 指令就会跳转到 0x08 这个地址</p><p>前面day1学过，实际BIOS会将硬盘主引导扇区内容加载到0x7c00这个物理地址，而物理地址由段地址和偏移地址组合来，0x07c00这个物理地址可以表示成 0x0000:0x7c00，当然也可以表示成 0x07c0:0x0000 这种形式</p><p>程序加载后，如果段地址为0，那么偏移地址就是0x7c00，偏移地址也就不是从0开始的，那么我们执行 jmp label_a 指令，还是会跳到 0x08和这个偏移地址，而实际 label_a 标号的地址应该为 [0x7c00+0x08] 这个地址</p><p>那么，如果我们直接把 DS 设置为 0x07c0，那么偏移地址肯定就是 0x000，偏移地址就是从0开始，这样我们直接 jmp label_a 对应的就是跳转到 label_a 标号的地址是0x08</p><h1 id="计算机中的正数-x2F-负数"><a href="#计算机中的正数-x2F-负数" class="headerlink" title="计算机中的正数&#x2F;负数"></a>计算机中的正数&#x2F;负数</h1><p>定义一些十进制的数据如下：</p><div class="code-wrapper"><pre><code class="hljs txt">db 128,127,3,2,1,0,-1,-2,-3,-127,-128</code></pre></div><p>编译成二进制后，以十六进制形式查看：</p><img src="/2022/08/21/22-0821-02/image-20220906151320227.png" class="" title="image-20220906151320227"><p>10进制 -1 即 0-1 ，由于计算机中识别的是0和1，即对应二进制的 0 - 1，需要一直向前借位，如下：</p><img src="/2022/08/21/22-0821-02/image-20220906151326386.png" class="" title="image-20220906151326386"><p>而10进制的 -2 即 0 - 2，对应成二进制就是 0 - 10，如下：</p><img src="/2022/08/21/22-0821-02/image-20220906151332886.png" class="" title="image-20220906151332886"><p>注意：即然 -2 是 FFFFF…FFFFE，那么上面为啥只有 FE 呢 ？？？</p><p>可能是因为计算后的结果保存在了8位寄存器中，所以这里只有 1111 1110，对应的16进制就是FF</p><p>那么对于0xFF我们就可以表示成10进制的-1，也可以表示成10进制的255，但是具体表示成啥呢 ？？？</p><p>这里就引入了有符号数和无符号数来区分，如果我们看成有符号数，最高位为0，即表示正数，最高位为-1，即表示负数。如果我们看成无符号数，那么不存在正负，全表示正数</p><p>假设我们现在把 1111 看成有符号数，该数字就是一个负数，而这个负数实际是 0 减 一个正数 得到的结果，那么我们如何得到这个正数呢 ？？？</p><p>由于 0 - 正数 &#x3D; 负数，所以正数&#x3D;0-负数，即 该正数 &#x3D; 0 - 1111 &#x3D; 0000 - 1111 &#x3D; 0001</p><h1 id="neg指令"><a href="#neg指令" class="headerlink" title="neg指令"></a>neg指令</h1><p>neg指令：neg是汇编指令中的求补指令，对操作数执行求补运算：用零减去操作数，然后结果返回操作数。求补运算也可以表达成：将操作数按位取反后加1，简单来说该指令会把正数变成负数、负数变成正数</p><div class="code-wrapper"><pre><code class="hljs txt">neg al ;如果al中保存的值为 0000 1000，也就是10进制的8，一般十进制表示成8D执行neg al后，al内的值变成了 1111 1000，也就是10进制的-8 （0000 1000——&gt;按位取反——&gt;1111 0111——&gt;然后再加1——&gt;1111 1000）注意：这里为啥是-8，-8不应该是 1 1000 吗 ？？？，最前面的1表示符号位为了方便,假设是8位二进制7的二进制是0000 0111按位求反就是1111 1000注意最高位是1,说明这是个负数,负数在计算机内是补码,补码的值怎么能知道呢把补码求反再+1,(当然最高位的1不变,因为那是负号)所以是1000 0111+1是1000 1000这个数正好是-8</code></pre></div><h1 id="CBW指令"><a href="#CBW指令" class="headerlink" title="CBW指令"></a>CBW指令</h1><p>CBW指令：CBW属于符号扩展指令，它可以把8位扩展到16位，扩展前后两数的真值不变，主要用于数据类型不同时用符号扩展指令可以使得数据类型相同</p><div class="code-wrapper"><pre><code class="hljs txt">比如：把AL中的有符号数扩展到整个AX中al=0100 1111cbw执行cbw后，ax= 0000 0000 0100 1111上面的例子中al为正数，如果al为负数呢 ？？？al=1000 1101cbw执行cbw后，ax= 1111 1111 1000 1101</code></pre></div><h1 id="CWD指令"><a href="#CWD指令" class="headerlink" title="CWD指令"></a>CWD指令</h1><p>CWD指令：CWD是字到双字符的扩展指令，可将AX内容扩展到DX:AX</p><div class="code-wrapper"><pre><code class="hljs txt">AX = 0100 1111 0111 0001CWD执行cwd指令后，dx= 0000 0000 0000 0000 ax= 0100 1111 0111 0001 如果ax为负数AX = 1100 1111 0111 0001CWD执行cwd指令后，dx= 1111 1111 1111 1111 ax= 1100 1111 0111 0001</code></pre></div><h1 id="有符号数和无符号数"><a href="#有符号数和无符号数" class="headerlink" title="有符号数和无符号数"></a>有符号数和无符号数</h1><p>在编写汇编程序时，如下：</p><p>AX &#x3D; 0XBFFF </p><p>注意0xBFFF对应的十进制是49151，如下：</p><img src="/2022/08/21/22-0821-02/image-20220906151555262.png" class="" title="image-20220906151555262"><p>这里是把 0XBFFF ，即 1011 1111 1111 1111 看成了无符号数才表示成49151，如果我们把 1011 1111 1111 1111 看成有符号数，那么这个数肯定是负数，由于计算机中的负数都是补码表示的，所以 1011 1111 1111 1111 即负数的补码，我们把这个补码转为原码，对应原码为 1100 0000 0000 0001 ，第一位符号位表示负数，也就是 -16385</p><img src="/2022/08/21/22-0821-02/image-20220906151605053.png" class="" title="image-20220906151605053"><p>那么到底是表示 49151 还是表示 -16385 呢 ？？？</p><p>其实计算机不会进行区分，主要是取决于我们自己如何看待，是看作有符号数，还是看作无符号数 </p><h1 id="指令解释"><a href="#指令解释" class="headerlink" title="指令解释"></a>指令解释</h1><p>解释文章开头第一个代码块中的部分指令</p><h2 id="jns指令"><a href="#jns指令" class="headerlink" title="jns指令"></a>jns指令</h2><p>jns指令：当执行jns指令时，如果标志位 SF&#x3D;0，则跳转到指定的地址，如果 SF&#x3D;1，不跳转 （ 注意：SF表示符号标志位，如果运算结果为负数（也就是有符号数最高位为1），SF&#x3D;1，反之若为正数 SF&#x3D;0 ）</p><h2 id="js指令"><a href="#js指令" class="headerlink" title="js指令"></a>js指令</h2><p>js指令：当执行js指令时，如果标志位 SF&#x3D;1，则跳转到指定地址，如果 SF&#x3D;0，不跳转，该指令恰好和 jns 指令相反</p><h2 id="times指令"><a href="#times指令" class="headerlink" title="times指令"></a>times指令</h2><p>times指令：该指令实际前面在学习16位的masm汇编的时，学过类似的指令，即dup指令</p><ul><li><p>dup是masm的指令</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-comment">;开辟200字节内存空间</span><span class="hljs-built_in">times</span> <span class="hljs-number">200</span> <span class="hljs-built_in">db</span> <span class="hljs-number">0</span></code></pre></div></li><li><p>times是nasm的指令</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-comment">;开辟200字节内存空间</span><span class="hljs-built_in">times</span> <span class="hljs-number">200</span> <span class="hljs-built_in">db</span> <span class="hljs-number">0</span></code></pre></div></li></ul><h2 id="符号"><a href="#符号" class="headerlink" title="$ 符号"></a>$ 符号</h2><p>$ 符号：$符号的作用是表示当前行首的标号地址</p><p>比如：naizi：jmp near naizi，该指令的作用就是跳到标号naizi当前行，然后一直进行死循环，而 jmp near $ 也是跳转到当前行</p><h2 id="符号-1"><a href="#符号-1" class="headerlink" title="$$ 符号"></a>$$ 符号</h2><p>$$ 符号：表示当前汇编代码的开始地址</p><p>比如：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">1</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">1</span><span class="hljs-keyword">jmp</span> <span class="hljs-built_in">near</span> $$ <span class="hljs-comment">;实际就是跳转到mov ax,1这里</span></code></pre></div><p>db 0x55,0xaa 代表啥意思：主扇区代码结尾必须要用0x55和0xaa，主扇区一共为512个字节，那么0x55和0xaa占用了两个字节，前面还有510个字节</p><h1 id="8086-寻址方式"><a href="#8086-寻址方式" class="headerlink" title="8086 寻址方式"></a>8086 寻址方式</h1><p>如何找到要操作的数，以及如何找到存放操作结果的地方 ？？？</p><h2 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h2><div class="code-wrapper"><pre><code class="hljs txt">操作数位于寄存器中mov ax,cxadd bx,0xff00inc bx</code></pre></div><h2 id="立即寻址（立即数寻址）"><a href="#立即寻址（立即数寻址）" class="headerlink" title="立即寻址（立即数寻址）"></a>立即寻址（立即数寻址）</h2><div class="code-wrapper"><pre><code class="hljs txt">add bx,0xff00   (第一条指令add的目的操作数bx采用了寄存器寻址，而0xfff就是一个立即给出的数值，即立即数，这个立即数是cpu生成的)mov dx,label(label编译后会转为一个地址，这个地址也是一个数值，也是立即数)</code></pre></div><h2 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h2><h3 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h3><div class="code-wrapper"><pre><code class="hljs txt">mov ax,[0x1111]and word [0x023],0x555xor byte [es:label],0x555</code></pre></div><h3 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h3><div class="code-wrapper"><pre><code class="hljs txt">如果我们有一大堆数据要处理，可以用如下的方式处理buffer dw 0x10,0x20,0x30inc word [buffer]inc word [buffer+2]inc word [buffer+4]基址寻址就是在指令的地址部分使用基址寄存器BX或者BP来提供偏移地址，如下：mov [bx],dxadd byte [bp],0x222基址寻址也可以在寄存器的基础上使用一个偏移量mov dx,[bp-2]对于处理一大堆数据，可以用基址寻址来实现，如下：mov bx,buffermov cx,4s:inc word [bx] add bx,2 loop s</code></pre></div><h4 id="bp寄存器的作用"><a href="#bp寄存器的作用" class="headerlink" title="bp寄存器的作用"></a>bp寄存器的作用</h4><p>扩展：bp寄存器的作用 （bp作用为访问现行堆栈段提供方便的寄存器）</p><p>mov ax,0x6666<br>push ax<br>mov ax,0x8888<br>push ax</p><p>这里压入两个数据0x6666和0x8888，这里很显然，如果要用pop指令弹出数据，就必须先pop弹出0x8888这个数据，然后才能弹出0x6666这个数据，那么我们有没有方法直接拿到0x6666这个数据呢？？？</p><p>当然是有的，嘿嘿 ，我们可以修改SP的位置，如下：</p><img src="/2022/08/21/22-0821-02/image-20220906152143233.png" class="" title="image-20220906152143233"><p>但是如果直接修改SP，这样就直接破坏了栈的结构。而在高级语言中，所有的参数都位于栈中，为了访问到哪些被压在栈底的参数，就使用了BP来实现</p><div class="code-wrapper"><pre><code class="hljs txt">mov ax,0x6666push axmov bp,spmov ax,0x8888push axmov dx,[bp]  ;这样就拿到了0x6666，dx的内容就为0x6666，注意：这里[bp]就是ss:[bp]，默认省略了段寄存器ss</code></pre></div><h3 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h3><p>类似于基址寻址，不过这种寻址使用的是变址寄存器（索引寄存器）di、si ，如下：</p><div class="code-wrapper"><pre><code class="hljs txt">mov [si],dxmov ax,[di]mov [si+0x222],aland byte [di+100],0x888</code></pre></div><h3 id="基址变址寻址"><a href="#基址变址寻址" class="headerlink" title="基址变址寻址"></a>基址变址寻址</h3><div class="code-wrapper"><pre><code class="hljs txt">基址变址就如下四种：mov ax,[bx+si]mov ax,[bx+di]mov ax,[bp+di]mov ax,[bp+si]</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>x86保护模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>x86保护模式day1</title>
    <link href="/2022/08/21/22-0821-01/"/>
    <url>/2022/08/21/22-0821-01/</url>
    
    <content type="html"><![CDATA[<h1 id="段的划分"><a href="#段的划分" class="headerlink" title="段的划分"></a>段的划分</h1><p>程序把数据和指令集中起来，在前面学习8086汇编时，我们经常划分数据段（用来存放全局变量等）、代码段（用来存放指令），但是我们虽然进行了划分，但并没有改变内存上的物理性质。</p><h1 id="程序的重定位"><a href="#程序的重定位" class="headerlink" title="程序的重定位"></a>程序的重定位</h1><p>程序具体在内存中的哪个位置，并不能由我们来决定，在我们双击程序 A ，程序 A 加载到内存的位置是随机的（内存中哪里有空闲的地址，就会被加载到哪里）</p><p>我们在学8086汇编的时候，访问内存地址都是用的偏移地址来访问。那么，我们为啥不用物理地址来访问呢 ？？？</p><p>假设，程序加载到内存后的地址是从0开始的，并且代码段有条指令要求访问物理地址为4的数据，进而得到了FF</p><img src="/2022/08/21/22-0821-01/image-20220904223124317.png" class="" title="image-20220904223124317"><p>但是，由于程序加载到内存后的位置是随机的，那么如果程序加载到内存后是从1000开始的，但代码段中的指令是不变的，所以如果还是取物理地址为4的数据，那么肯定无法得到FF，而应该取1004地址的数据，这就是用物理地址来访问的弊端，而我们只需要把代码段设置成CS，程序里面直接用偏移地址（IP）即可</p><img src="/2022/08/21/22-0821-01/image-20220904223135781.png" class="" title="image-20220904223135781"><p>汇编中用 reg 表示寄存器，即 reg 也就是 ax、bx、bx、dx、sp、bp、si 、di 。用 sreg 表示段寄存器，即 sreg 也就是 ds、ss、cs、es</p><h1 id="NASM安装使用"><a href="#NASM安装使用" class="headerlink" title="NASM安装使用"></a>NASM安装使用</h1><p>安装nasm（编译后的exe可编译在linux和windows上），直接下一步即可</p><p>安装后可以手动编译和自动编译，笔记中只记录自动编译方法：</p><div class="code-wrapper"><pre><code class="hljs txt">cmd /k pushd &quot;$(CURRENT_DIRECTORY)&quot; &amp; D:\nasm\nasm.exe -f bin  &quot;$(FULL_CURRENT_PATH)&quot; -o &quot;$(NAME_PART).bin&quot; &amp; PAUSE &amp; EXIT</code></pre></div><img src="/2022/08/21/22-0821-01/image-20220904223217946.png" class="" title="image-20220904223217946"><img src="/2022/08/21/22-0821-01/image-20220904223222590.png" class="" title="image-20220904223222590"><p>然后运行nasm</p><img src="/2022/08/21/22-0821-01/image-20220904223230078.png" class="" title="image-20220904223230078"><p>即可得到编译后的bin文件</p><img src="/2022/08/21/22-0821-01/image-20220904223237799.png" class="" title="image-20220904223237799"><p>然后查看二进制bin文件，并且转为16进制（因为16进制更方便观看）</p><img src="/2022/08/21/22-0821-01/image-20220904223244526.png" class="" title="image-20220904223244526"><p>转为16进制形式后如下：</p><img src="/2022/08/21/22-0821-01/image-20220904223250813.png" class="" title="image-20220904223250813"><p>注意这里为啥有一些点，因为这里是一个字节来对应的，比如：16进制的69对应的ascii码就是i，但表示汉字需要两个字节，所以一些无法表示出来的就用点来表示</p><h1 id="计算机启动过程"><a href="#计算机启动过程" class="headerlink" title="计算机启动过程"></a>计算机启动过程</h1><p>每种操作系统都对管理的程序提出了种种格式的要求，比如，windows的PE、linux的elf。如果在windows上的程序格式不是PE，那么就会提示不是有效的windows程序，那么我们如何绕过这个限制呢 ？？？</p><p>我们要了解计算机的启动过程大致是啥样的 ？？？如下：</p><div class="code-wrapper"><pre><code class="hljs txt">1. 通电2. 读取ROM里面的BIOS，用来检查硬件3. 硬件检查通过4. BIOS根据指定的顺序，检查引导设备的第一扇区（即主引导扇区），加载在内存地址 0x7C005. 主引导记录把操作权交给操作系统（注意：操作系统放在硬盘的活动分区内）</code></pre></div><h2 id="三种启动过程"><a href="#三种启动过程" class="headerlink" title="三种启动过程"></a>三种启动过程</h2><p>计算机有三种启动过程：</p><ol><li><p>冷启动（加电）：指计算机在没有加电的状态下初始加电，一般原则是，先开外设电源，后开主机电源，因为主机的运行需要非常稳定的电源，为了防止外设启动引起电源波动影响主机运行，应该先把外设电源接通，同时应避免主机启动后，在同一电源线上再启动其他电器设备，如：电视，冰箱，空调等家电设备。</p></li><li><p>热启动：计算机在DOS状态下运行时，同时按下 “ctrl”、“alt”、“del” 三个键,计算机会重新启动，这种启动方式是在不断电状态下进行计算机的程序启动，所以也叫做热启动。</p></li><li><p>复位启动（复位）：指在计算机停止响应后（死机），甚至连键盘都不能响应时采用的一种热启动方式，一般在主机面板上都有一个复位按钮开关，轻轻按一下即可，计算机会重新加载硬盘等所有硬件以及系统的各种软件，当然它的威胁不亚于热启动。</p></li></ol><h2 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h2><ul><li>CPU有很多引脚，其中有一个是专门用来接受复位信号的，当计算机启动时，会执行硬件初始化，将CPU内部所有寄存器的内容初始化到一个预知的状态。</li><li>对于 8086 CPU 而言，如果接受到复位信号，会使 CS 代码段寄存器置为 0xFFFF，其他所有寄存器的内容都置为 0x000（注意：8086之后的CPU没有延续这样的设计）</li><li>处理器的作用主要还是取指令、执行指令</li></ul><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>内存有两种</p><ul><li><p>一种是主内存，如：内存条，在断电后，内存条保存的内容全部消失。刚开机的时候，内存条中啥数据也没有，所以CPU不可能从内存条中取指令。</p></li><li><p>另一种只读内存（ROM），只读内存实际就是一块单独的内部存储器，比如：我们常说的BIOS，断电后，里面的数据不会消失，开机后，CPU就是从这里面取指令</p><p>补充BIOS的概念和功能：BIOS是一组固化到计算机内主板上一个ROM芯片上的程序，它保存着计算机最重要的基本输入输出的程序、开机后自检程序和系统自启动程序，它可从CMOS中读写系统设置的具体信息</p><p>读取ROM里面的BIOS来检测硬件过程如下：</p><img src="/2022/08/21/22-0821-01/image-20220904223454290.png" class="" title="image-20220904223454290"></li></ul><h1 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h1><p>结构如下：</p><img src="/2022/08/21/22-0821-01/image-20220904223747531.png" class="" title="image-20220904223747531"><p>主引导扇区：（更多相关：<a href="https://baike.baidu.com/item/%E4%B8%BB%E5%BC%95%E5%AF%BC%E6%89%87%E5%8C%BA/7612621?fr=aladdin%EF%BC%89">https://baike.baidu.com/item/%E4%B8%BB%E5%BC%95%E5%AF%BC%E6%89%87%E5%8C%BA/7612621?fr=aladdin）</a></p><p>硬件第一个扇区就是主引导扇区（位置为 0面 0道 1扇区，包括硬盘主引导记录和分区表），开机启动并检测完硬件后，BIOS将读取硬盘主引导扇区内容把它加载到内存地址 0x0000 : 0x7C00（ 对应的物理地址为0x07C00 ），然后用 jmp 跳转指令跳转到这个地址，CS : IP 将会从0x07C00 这个物理地址开始执行汇编指令（实际0x07C00这个物理地址就是主引导记录的内存地址），而主引导记录会把操作系统的引导扇区调入内存加以执行，这样就把操作权交给了操作系统</p><p>我们如果修改主引导扇区，就会导致无法加载操作系统</p><h1 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h1><p>虚拟机也是需要存储器的（类似于机械硬盘等），但在虚拟机并不需要真正的磁盘，而是用一个文件（如：vhd格式文件、vmdk格式文件）当作虚拟磁盘</p><p>Oracle VM VirtualBox 对应的磁盘就是 vhd 格式文件，这里我们主要以 vhd 格式文件来学习</p><p>在读取磁盘的时候，会从 0 面 0道 1 扇区开始读取，读取完后，再读取 0 面 0道 2 扇区，当0道上所有的扇区全部读取完后，然后会读取 0 面 1 道 1扇区，然后再读取0 面 1 道 2扇区 ，以此类推，读取完道后，再读取面</p><p>vhd文件里一开始的512个字节对应真正硬盘的 0面 0 道 1扇区，也就是对应主引导扇区，第二个512个字节对应物理硬盘的 0面 0道 2扇区，第三个512个字节对应物理硬盘的 0面 0道 3扇区，假设只有3个扇区，然后下一个512个字节就会读取下一个道，那么第四个512个字节对应物 理硬盘的 0面 1道 1扇区，以此类推</p><div class="code-wrapper"><pre><code class="hljs txt">;向显存中写入数据naizigege,编译后的文件为ayu.binmov ax,0xb800mov ds,axmov byte [0x00],&#x27;n&#x27;mov byte [0x02],&#x27;a&#x27;mov byte [0x04],&#x27;i&#x27;mov byte [0x06],&#x27;z&#x27;mov byte [0x08],&#x27;i&#x27;mov byte [0x0a],&#x27;g&#x27;mov byte [0x0c],&#x27;e&#x27;mov byte [0x0e],&#x27;g&#x27;mov byte [0x10],&#x27;e&#x27;infi:jmp near infitimes 510-($-$$) db 0db 0x55,0xaa</code></pre></div><p>然后利用如下工具向虚拟硬盘中写数据，首先选择要写入的虚拟硬盘</p><img src="/2022/08/21/22-0821-01/image-20220904224459198.png" class="" title="image-20220904224459198"><p>然后选择写入的数据，这里写入ayu.bin文件（因为计算机识别的就是二进制文件，无法识别源码），即显示naizigege</p><img src="/2022/08/21/22-0821-01/image-20220904224506479.png" class="" title="image-20220904224506479"><p>然后选择LBA模式写入文件，会提示写入成功</p><img src="/2022/08/21/22-0821-01/image-20220904224513051.png" class="" title="image-20220904224513051"><p>然后用 Oracle VM VirtualBox 新建虚拟机</p><img src="/2022/08/21/22-0821-01/image-20220904224519933.png" class="" title="image-20220904224519933"><p>然后分配内存，如下</p><img src="/2022/08/21/22-0821-01/image-20220904224525637.png" class="" title="image-20220904224525637"><p>然后使用我们刚才写入数据的虚拟磁盘</p><img src="/2022/08/21/22-0821-01/image-20220904224531927.png" class="" title="image-20220904224531927"><p>然后开机，显示如下</p><img src="/2022/08/21/22-0821-01/image-20220904224537949.png" class="" title="image-20220904224537949"><h1 id="大小端模式"><a href="#大小端模式" class="headerlink" title="大小端模式"></a>大小端模式</h1><p>小端模式：指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，在前面我们学16位汇编时，就是小端模式，而x86汇编中也是小端模式</p><img src="/2022/08/21/22-0821-01/image-20220904224551771.png" class="" title="image-20220904224551771"><p>为啥需要区分大小端模式呢 ？？？</p><p>因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为 8bit，对于位数大于 8位 的处理器，例如 16位 或者 32位 的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。</p><p>小端模式的优势</p><p>在进行强制类型转换时，由低精度向高精度进行转化时，比如：由 short 类型（2个字节）的 0x1234 转为 int 类型（4个字节）的 0x00001234，转换完后，数值是不变的，只是存储形式变了。</p><img src="/2022/08/21/22-0821-01/image-20220904224614036.png" class="" title="image-20220904224614036"><p>如果是从高精度向低精度转换，比如：从 0x00001234 转为 0x1234 ，那么只需要将高地址的内容砍掉就好了</p><img src="/2022/08/21/22-0821-01/image-20220904224624236.png" class="" title="image-20220904224624236"><p>大端模式的优势</p><p>优点在于对于有符号数而言，判断更加方便，假设是大端模式的话，如果地址 073F:2000 的内容为十六进制的1234，并且是负数的话，那么对应大致如下：</p><img src="/2022/08/21/22-0821-01/image-20220904224635725.png" class="" title="image-20220904224635725"><p>由于符号位在低地址处，所以我们一开始就可以在低地址处知道符号位是负的</p><h1 id="屏幕显示内容的原理"><a href="#屏幕显示内容的原理" class="headerlink" title="屏幕显示内容的原理"></a>屏幕显示内容的原理</h1><p>为了显示数据，必须存在两大硬件:显卡+显示器。显卡是为显示器提供需要显示的数据，控制显示器的模式和状态。而显示器是将目标数据以可见的方式呈现在屏幕上。显存的概念和意义就是显卡拥有自己内部的而数据存储器，显存在本质上和普通内存无差别，用于存储目标数据，操作显存中的数据将导致显示器上内容的改变。</p><p>对于显卡，有两种工作模式，一个是文本模式，另一个是图形模式，开机启动后，默认是文本模式，文本模式下，内存的<code>0xB8000</code>到<code>0xBFFFF</code>这段物理地址被映射到显存。也就是说，写这些物理地址，就可以控制显示内容。</p><h1 id="16位汇编和32位的简单区别"><a href="#16位汇编和32位的简单区别" class="headerlink" title="16位汇编和32位的简单区别"></a>16位汇编和32位的简单区别</h1><p>在16位汇编中的寄存器为：AX、BX、CX 等等</p><p>在32位汇编中的寄存器为：EAX、EBX、ECX 等等 ，EAX可拆分成两个16位的寄存器使用</p><p>在64位汇编中 的寄存器为：RAX、RBX、RCX 等等、RAX可拆分成两个32位的寄存器使用，当然低32位寄存器还可以继续拆分。还新增了 R8、R9 等，这些不能拆分</p>]]></content>
    
    
    <categories>
      
      <category>x86保护模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编day11</title>
    <link href="/2022/08/20/22-0820-11/"/>
    <url>/2022/08/20/22-0820-11/</url>
    
    <content type="html"><![CDATA[<h1 id="数据标号"><a href="#数据标号" class="headerlink" title="数据标号"></a>数据标号</h1><p> 不带冒号的标号可以描述内存地址和单元长度，这种标号称为数据标号，如下：</p><div class="code-wrapper"><pre><code class="hljs txt">data segmenta dw 0,0;标号a描述了地址data:0，还有就是从这个地址开始，后面内存单元都是字单元b db 1,2;标号b描述了地址data:4，还有就是从这个地址开始，后面的内存单元都是字节单元data ends另外还有如下使用方法：mov al,b 相当于mov ax,ds:[4]mov al,b[si] 以数组形式使用</code></pre></div><h1 id="直接定址表"><a href="#直接定址表" class="headerlink" title="直接定址表"></a>直接定址表</h1><p>一个字节用两个十六进制数码来表示，用一个字节的高 4 位和低 4 位分开，分别用它们的值得到对应的数码字符。比如 2Bh，可以得到高 4 位的值为 2，低 4 位的值为 11</p><p>即，当数值为2，则显示2；当数值为11，则显示B</p><p>那么，我们就可以建立一张映射表。通过依据数据，直接对应的结果，类似如下：</p><div class="code-wrapper"><pre><code class="hljs txt">数值 ——&gt; ASCII字符  0       0  1       1  2       2  3       3  4       4  5       5  6       6  8       8  9       9   10      A   11      B   12      C   13      D   14      E   15      F</code></pre></div><p>用汇编代码表示如下：</p><div class="code-wrapper"><pre><code class="hljs txt">table db &#x27;0123456789ABCDEF&#x27;table[0]  ;对应的就是0，这里中括号里面的0有点类似数组的下表table[10] ;对应的就是A</code></pre></div><h1 id="键盘原理"><a href="#键盘原理" class="headerlink" title="键盘原理"></a>键盘原理</h1><p>day10 学习过扫描码和对应的ASCII码被送入内存的BIOS键盘缓冲区，当我们按下 a 键时，具体流程是啥 ？？</p><ol><li><p>当我们按下 a 键的时候，此时键盘缓冲区的高地址为扫描码（通码）1E，低地址为ASCII码 61</p><img src="/2022/08/20/22-0820-11/image-20220904164745649.png" class="" title="image-20220904164745649"><p>附键盘按键的各种编码对照表：<a href="https://blog.csdn.net/liuyukuan/article/details/120575746">https://blog.csdn.net/liuyukuan/article/details/120575746</a></p></li><li><p>然后 cpu 执行 int 9，从 60h 端口读取 a 的通码。然后检测状态字节（判断我们有没有按下 shift、ctrl 等控制键），这里我们没有按下shift键</p></li></ol><p>BIOS提供了int 16h中断例程给我们从键盘缓冲区读取一个键盘输入（ 前面学过的int 9的功能是将扫描码和ASCII码写入缓冲区 ）</p><div class="code-wrapper"><pre><code class="hljs txt">;使用16号中断例程的0号子程序mov ah,0 ;设置参数，用ah表示使用哪个子程序int 16hint 16h 0号功能进行如下操作：检测缓冲区是否有数据，没有就继续等待，有的话读取缓冲区第一个字单元的键盘输入，将读取的扫描码送入ah，ASCII码送入al,将已读取的键盘输入从缓冲区里删除比如说：现在缓冲区只有1E61，那么就会将1E给ah，61给al，然后将1E61从缓冲区中删除，现在缓冲区没有数据了，就会继续等待</code></pre></div><p>编写一个程序，要求：接受用户的键盘输入，输入 ‘r’ 将屏幕上的字符都设置为红色，输入 ‘g’ 显示绿色，输入 ‘b’ 显示蓝色</p><div class="code-wrapper"><pre><code class="hljs txt">assume cs:codecode segmentstart:mov ah,0int 16hmov ah,1;ah保存扫描码，这里把扫描码暂时设置1，即0000 0001cmp al,&#x27;r&#x27;;al存放的是ascii码，比较按下的键位是不是rje red;如果是r，跳转到red标号cmp al,&#x27;g&#x27;je greencmp al,&#x27;b&#x27;je bluejmp jieshured:shl ah,1;将ah中值左移1位，即0000 0010green:shl ah,1;将ah中值左移1位，即0000 0100，而0000 0100就是红色blue:mov bx,0b800hmov es,bxmov bx,1mov cx,2000;循环2000次s:and byte ptr es:[bx],11111000b;采用and指令，全1为1，所以会把后三位表示颜色的位设置成0,or es:[bx],ah;将颜色设置为相对应的颜色add bx,2;循环，将屏幕上所有的字符全部设置成相对应的颜色loop sjieshu:mov ax,4c00hint 21hcode endsend start</code></pre></div><p>效果如下：</p><p>按下r</p><img src="/2022/08/20/22-0820-11/image-20220904164843077.png" class="" title="image-20220904164843077"><p>按下g</p><img src="/2022/08/20/22-0820-11/image-20220904164849228.png" class="" title="image-20220904164849228"><p>按下b</p><img src="/2022/08/20/22-0820-11/image-20220904164856726-16622813370711.png" class="" title="image-20220904164856726"><h1 id="字符串输入本质"><a href="#字符串输入本质" class="headerlink" title="字符串输入本质"></a>字符串输入本质</h1><p>字符串输入，如何接受字符串输入 ？？</p><ol><li>在输入的同时需要显示这个字符串</li><li>一般在输入回车后，表示字符串输入结束</li><li>能够删除已经输入的字符串</li></ol><p>字符的输入和输出是按照栈的访问规则进行的，后进先出，如下：</p><p><img src="file://D:\Lucy1.7.6\Lucy%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8v1.7.6%E4%B8%AA%E4%BA%BA\Hexo_Blog\source_posts\22-0604-01\GIF%202022-6-5%2013-00-55.gif?lastModify=1662281428" alt="GIF 2022-6-5 13-00-55"></p><p>所以字符串的存储空间实际上是一个字符栈，从栈底到栈顶组成了一个字符串，如下：</p><img src="/2022/08/20/22-0820-11/image-20220904165042463.png" class="" title="image-20220904165042463"><p>输入回车符，就在字符串中加入0表示一个字符串结束</p><h1 id="对汇编语言实质思考"><a href="#对汇编语言实质思考" class="headerlink" title="对汇编语言实质思考"></a>对汇编语言实质思考</h1><p>编程思想：</p><p>比如：计算 1 + 2 + 3 + 4 &#x3D; 10，实际是先算 1 + 2 &#x3D; 3 ，然后算 3 + 3 &#x3D; 6 ，然后算 6 + 4 &#x3D;10</p><p>输入数值—&gt;计算数值—&gt;将计算后数值输出，输出的数值又可以作为输入，所谓的输入和输出其实就是数据从哪里来，数据到哪里去</p><p>这个哪里这个词是不是给人一种空间的感觉呢？那我们学到现在，学过哪些和空间位置信息相关的概念呢？</p><div class="code-wrapper"><pre><code class="hljs txt">CPU中的寄存，比如：ax，bx，cx，dx ......内存条、显卡中的内存地址、段地址、偏移地址 外设（比如：键盘）中的端口地址（端口号）网卡的网络地址硬盘的硬盘地址</code></pre></div><p>那么以上都是什么的空间位置信息？是数据的空间位置信息，那么这些数据的空间位置信息，它们对应的是哪些物理设备？</p><p>这些设备都是插在一块主板上的，而主板上都是有电路的，这又回到了我们刚开始学习的时候，这些电路需要表示哪些信息啊？</p><p>地址信息，数据信息，控制信息，也就是地址线，数据线，控制线。那么也就是说这些插在主板上的物理设备之间，它们是依靠主板上的电路去传递这些信息，然后进行互相<strong>通信</strong>的。</p><p>通信这个词语很关键，我们程序写到现在，你们应该也发现了，我们汇编程序员就是在用汇编指令去控制插在主板上的CPU，通过这些信息去和同样插在主板上的这些各个物理设备之间去进行通信</p><p>当你在执行很多指令的时候（比如：mov al,ds:[si] 、in al,60H、int 13h 等），你都需要有这些信息，特别是这个地址信息，否则的话你这数据从哪里来的啊？还有这个数据到哪里去？而所谓的读写是不是其实就是在通信</p><p>而像 mov ax,bx 指令，则表示CPU内部寄存器之间的通信</p><p>汇编语言是什么呢？ 语言是一套表示系统，再结合我们刚在所讲的，那么我们可以得到一个思考，汇编语言它是一套控制计算机通信的表示系统</p><h1 id="编译器和链接器"><a href="#编译器和链接器" class="headerlink" title="编译器和链接器"></a>编译器和链接器</h1><p>如果一个程序中有100W行代码，需要编译5分钟，那么我们一旦需要修改代码，就需要再次编译，并且等待5分钟，这样很麻烦</p><p>那么就可以把100W行代码拆分多个部分，如下：</p><p>t1.asm</p><p>t2.asm</p><p>t3.asm</p><p>t4.asm</p><p>然后把这些编译成obj</p><p>t1.asm —&gt; t1.obj</p><p>t2.asm —&gt; t2.obj</p><p>t3.asm —&gt; t3.obj</p><p>t4.asm —&gt; t4.obj</p><p>然后再通过链接器把所有obj文件链接在一起变成可执行的exe文件</p><p>假设我们需要修改 t1 里面的代码，我们是不是只需要编译 t1 就行了，其他的不用再编译，节省时间</p>]]></content>
    
    
    <categories>
      
      <category>16位汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编day10</title>
    <link href="/2022/08/20/22-0820-10/"/>
    <url>/2022/08/20/22-0820-10/</url>
    
    <content type="html"><![CDATA[<h1 id="DOS中断例程"><a href="#DOS中断例程" class="headerlink" title="DOS中断例程"></a>DOS中断例程</h1><p>实际之前我们已经接触过dos中断例程，如下：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span></code></pre></div><p>而 mov  ax,4c00h 也就是 mov ah,4ch mov al,00h </p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-number">4ch</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0</span><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><span class="hljs-comment">;表示使用int 21h中断例程的4ch子程序，功能为程序返回，ah传递参数</span></code></pre></div><p>作业：</p><div class="code-wrapper"><pre><code class="hljs txt">assume cs:code,ds:datadata segmentdb &#x27;Welcome to naizishaozhi&#x27;,&#x27;$&#x27;;这里的$表示字符串结束的标志data endscode segmentstart:mov ah,2;调用2号子程序，来设置光标;设置参数mov bh,0;设显存置第0页mov dh,5;设置第5行mov dl,12;设置第12列int 10h;设置完参数后调用10h中断例程mov ax,datamov ds,axmov dx,0;ds:dx，指向data段字符串的首地址mov ah,9;调用号子程序，功能是在光标处显示字符串int 21h;注意:调用21h中断例程时候，该例程是以dx为偏移的，所以在前面把dx设置为0mov ax,4c00hint 21hcode endsend start</code></pre></div><p>编译上述程序，指向后如下：</p><img src="/2022/08/20/22-0820-10/image-20220904162736276.png" class="" title="image-20220904162736276"><h1 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h1><p>CPU 是一块芯片，通过地址线、数据线、控制线和其他电子器件链接，那么我们在键盘上按下 ‘A’ ，CPU如何获取到我们键盘上按下的 ‘A’ 呢 ？？</p><p>在电脑的主板上有很多接口，如下，这些接口上有很多芯片，这些芯片上还有一些寄存器，比如：笔记本上的插键盘的usb接口，这个接口上就有芯片，芯片上就有寄存器。</p><img src="/2022/08/20/22-0820-10/image-20220904162855237.png" class="" title="image-20220904162855237"><p>比如：我们在键盘上按下 ‘A’ ，由于键盘上肯定也有芯片，芯片上就有寄存器，那么当我们在键盘上按下 ‘ A’ 的时候，就会把 ‘A’ 存放到键盘芯片上的寄存器中，然后通过 “端口” 把A发送给CPU，实际这里端口就是键盘和电脑连接的usb接口上的寄存器，每个端口都有一个编号，类似于内存的地址。CPU通过端口地址来定位端口，端口的范围是64KB，即 0~65535</p><img src="/2022/08/20/22-0820-10/image-20220904162902231.png" class="" title="image-20220904162902231"><p>注意：对端口的读写不能使用 mov push pop 等内存指令，端口的读写有2条：In（读）和 out（写）</p><p>比如：访问60号端口的内容  </p><div class="code-wrapper"><pre><code class="hljs txt">In al,60h;这里必须是al或者ax，这个是固定的格式，访问8位端口用al，访问16位端口用ax</code></pre></div><p>具体如下： </p><p>CPU要读取60h号端口的内容，那么CPU通过地址总线将60h这个地址信息发送出去，找到60h端口，然后通过控制线告诉这个端口要执行In读命令，那么芯片所在的60h端口会把数据通过地址线直接放到CPU的寄存器中</p><p>比如：对0~255（8位）以内的端口进行读写时，这里以20h端口为例</p><div class="code-wrapper"><pre><code class="hljs txt">in al,20hout 20h,al</code></pre></div><p>比如：对256~65535（16位）进行读写，端口号放dx中，这里的端口号为3f8h（10进制的1016）为例</p><div class="code-wrapper"><pre><code class="hljs txt">mov dx,3f8hin al,dxout dx,al</code></pre></div><h1 id="CMOS-RAM-芯片（简称CMOS）"><a href="#CMOS-RAM-芯片（简称CMOS）" class="headerlink" title="CMOS RAM 芯片（简称CMOS）"></a>CMOS RAM 芯片（简称CMOS）</h1><ol><li><p>CMOS芯片是电脑主板上的一块可读写的RAM芯片，因为可读写的特性，所以在电脑主板上用来保存BIOS设置完电脑硬件参数后的数据，这个芯片仅仅是用来存放数据的。</p></li><li><p>CMOS芯片包含一个实时钟（用来显示当前时间）和一个有128个存储单元的RAM存储器</p></li><li><p>128个字节的RAM中内部实时钟占用0~0dh单元用，来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序读取</p></li><li><p>CMOS RAM 存储的具体时间信息如下：</p><p>年、月、日、时、分、秒，这六个信息长度都为1个字节，存放单元为：秒:0   分:2   时:4  日: 7   月:8   年:9 </p><p>这些时间数据都是以BCD码的方式存放</p><p>BCD码是以4位二进制数表示十进制数码的编码方法，如下所示：</p><div class="code-wrapper"><pre><code class="hljs tap">十进制数码:     <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 1 </span>    <span class="hljs-number"> 2 </span>    <span class="hljs-number"> 3 </span>    <span class="hljs-number"> 4 </span>   <span class="hljs-number"> 5 </span>     <span class="hljs-number"> 6 </span>     <span class="hljs-number"> 7 </span>     <span class="hljs-number"> 8 </span>     9对应的BCD码:  <span class="hljs-number"> 0000 </span>  <span class="hljs-number"> 0001 </span> <span class="hljs-number"> 0010 </span> <span class="hljs-number"> 0011 </span> <span class="hljs-number"> 0100 </span> <span class="hljs-number"> 0101 </span> <span class="hljs-number"> 0110 </span>  <span class="hljs-number"> 0111 </span>  <span class="hljs-number"> 1000 </span>   1001</code></pre></div><p>比如：数值26，用BCD码表示为: 0010 0110</p><div class="code-wrapper"><pre><code class="hljs txt">;作业：编程在屏幕中间显示当前的月份;分析：当前日期为6月，我们拿到的数据实际是bcd码，也就是0000 0110，然后我们右移四位，拿到4个高位数据0000，然后and指令拿到低4位0110，然后把高位和低位分别+30h，拿到对应的ascii码，然后写入显存，显示出来对应月份assume cs:code,ds:datadata segmentdb &#x27;Welcome to naizishaozhi&#x27;,&#x27;$&#x27;data endscode segmentstart:mov al,8out 70h,alin al,71hmov ah,almov cl,4shr ah,cl;拿到月份高位（十位）and al,00001111b;拿到月份的低位（个位）;加上30H显示对应的ASCII码add ah,30Hadd al,30Hmov bx,0b800hmov es,bxmov byte ptr es:[160*12+40*2],ahmov byte ptr es:[160*12+40*2+1],11001100bmov byte ptr es:[160*12+40*2+2],almov byte ptr es:[160*12+40*2+3],11001100bmov ax,4c00hint 21hcode endsend start</code></pre></div><p>编译运行上述程序后，结果如下：</p><img src="/2022/08/20/22-0820-10/image-20220904163032978.png" class="" title="image-20220904163032978"></li><li><p>该芯片有电池供电，所以关机后内部的时钟依然可以正常工作，RAM中信息不丢失</p></li><li><p>该芯片有两个端口：70h和71h，CPU通过这两个端口来读写CMOS RAM</p></li><li><p>70h为地址端口，存放要访问的CMOS RAM单元的地址；71h为数据端口，存放从选定的CMOS RAM单元中读取的数据，或要写入其中的数据。</p><p>比如：要读取cmos 2号单元的内容</p><div class="code-wrapper"><pre><code class="hljs txt">out 70h,2;①将2送入端口70hin al,71h;②从端口71h读出2号单元的内容</code></pre></div><p>具体内容如下：</p><div class="code-wrapper"><pre><code class="hljs txt">assume cs:codecode segmentstart:mov al,2out 70h,alin al,71hmov ax,4c00hint 21hcode endsend start</code></pre></div><p>调式上述程序如下：</p><img src="/2022/08/20/22-0820-10/image-20220904163101938.png" class="" title="image-20220904163101938"><p>执行完 in al,71 指令后，al由 02 变成了 48，而2号单元对应的是分钟，此时恰好是48分</p></li></ol><h1 id="shl、shr指令"><a href="#shl、shr指令" class="headerlink" title="shl、shr指令"></a>shl、shr指令</h1><p>shl（l&#x3D;left 逻辑左移指令）和 shr（r&#x3D;right 逻辑右移指令）</p><h2 id="shl"><a href="#shl" class="headerlink" title="shl"></a>shl</h2><p>shl：将一个寄存器或内存单元中的数据向左移位，将<code>最后移出</code>的一位写入CF中，最低位用0补位</p><p>例如：</p><div class="code-wrapper"><pre><code class="hljs txt">mov al,01001000bshl al,1;从右向左移1位执行上面指令后al=10010000 CF=0然后再次执行 sh1 al,1 指令，执行后结果如下：al=00100000 CF=1</code></pre></div><p>如果一次移动多位，位数大于1时，必须将移动位数放在cl中</p><p>比如：我们向左移动5位，如下</p><div class="code-wrapper"><pre><code class="hljs txt">mov al,01010001bmov cl,5shl al,cl</code></pre></div><h2 id="shr"><a href="#shr" class="headerlink" title="shr"></a>shr</h2><p>shr：将一个寄存器或内存单元中的数据向右移，将<code>最后移出</code>的一位写入CF中，最高位用0补位</p><div class="code-wrapper"><pre><code class="hljs txt">mov al,01001001bshr al,1;执行后al=00100100b cf=1</code></pre></div><h1 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h1><p>外中断分为可屏蔽和不可屏蔽，CPU通过标志寄存器的IF位来判断是可屏蔽还是不可屏蔽，可屏蔽可以不响应（当然也可以响应）。如果不可屏蔽，则必须响应。IF&#x3D;0为可屏蔽中断，IF&#x3D;1为可屏蔽中断</p><p>可屏蔽外中断流程：</p><ol><li>中断后，取中断类型码 n（是为了定位中断例程的入口地址）</li><li>标志寄存器入栈，设置 IF&#x3D;0 TF&#x3D;0（pushf）</li><li>cs、ip入栈</li><li>ip&#x3D;n*4，cs&#x3D;nx4+2</li></ol><p>不可屏蔽中断流程：</p><ol><li>标志寄存器入栈，IF&#x3D;0 TF&#x3D;0（不可屏蔽中断类型码固定是2，不需要取中断类型码）</li><li>cs、ip入栈</li><li>ip&#x3D;n*4，cs&#x3D;nx4+2</li></ol><p>理解可屏蔽中断和不可屏蔽中断：比如，我们在键盘上按下按键，就属于可屏蔽中断，有时候会显示，有时候不显示</p><img src="/2022/08/20/22-0820-10/image-20220904163423875.png" class="" title="image-20220904163423875"><p>键盘处理过程如下：</p><ol><li><p>键盘上的每个键相当于一个开关，键盘中有一个芯片对键盘上的每一个键的开关状态进行扫描（判断我们到底有没有按这个按键）</p></li><li><p>按下一个键，开关接通，该芯片产生一个扫描码，扫描码就说明了你按的是哪个键，扫描码会送到接口芯片的寄存器中，外设都是通过端口来读取数据的，键盘的端口地址为60h</p></li><li><p>按下一个键产生的扫描码又称为通码，松开一个键产生扫描码称为断码。扫描码为一个字节。通码的第7位为0，断码的第7位为1</p><p>比如：g键的通码为 22h （对应二进制为 00100010 ），断码只需要将通码二进制第7位变为1即可，即 10100010 ，对应十六进制为a2h</p></li><li><p>键盘的输入到达60h端口，相关芯片给CPU发出了中断类型码为9的可屏蔽中断信息，CPU检测到该信息后，如果这时IF&#x3D;1,则响应，去执行int 9中断例程</p></li><li><p>BIOS提供了int 9中断例程用来进行基本的键盘输入处理</p><p>int 9 中断例程进行基本的键盘输入处理大致如下：</p><ol><li>读出60h端口中的扫描码</li><li>如果是字符键的扫描码，将该扫描码和对应的ASCII码送入内存的BIOS键盘缓冲区，如果是控制键比如CTRL和CAPSLOCK，则将其转变为状态字节（用二进制记录控制键和切换键状态的字节），写入内存中存储状态的字节单元</li><li>对键盘系统进行相关控制</li></ol></li></ol><p>BIOS键盘缓冲区用于存放 int 9 中断例程所接收的键盘输入内存区，该内存区可以存储15个键盘输入，用一个字单元存放扫描码和ASCII码，高位字节存放扫描码，低位存放ASCII码</p><p>如果我们在键盘上按的是控制键，那么会存储在内存单</p><div class="code-wrapper"><pre><code class="hljs txt">;显示0040:17存储的字节内容，该部分代码主要做演示用assume cs:code,ss:stackstack segment stackdb 128 dup (0)stack endscode segmentstart:mov bx,stackmov ss,bxmov sp,128mov bx,0b800hmov es,bxmov bx,40Hmov ds,bxmov si,17Hs: mov di,160*10+40*2mov al,ds:[si]call show_sjmp sshow_s:push cxpush axpush dspush espush sipush dimov cx,8show:mov dx,0shl al,1adc dx,30Hmov es:[di],dladd di,2loop show pop dipop sipop espop dspop axpop cxretmov ax,4c00h  ;ah=4c al=00int 21hcode endsend start</code></pre></div><p>编译上述程序，如下：</p><img src="/2022/08/20/22-0820-10/image-20220904163459454.png" class="" title="image-20220904163459454"><p>当我们按下shift键时，如下：</p><img src="/2022/08/20/22-0820-10/image-20220904163505204-16622805054141-16622805063062.png" class="" title="image-20220904163505204"><p>这8个0表示的含义如下：</p><ul><li>字节第0位：键盘右边的shift状态，1表示按下</li><li>字节第1位：键盘左边的shift状态，1表示按下</li><li>字节第2位：键盘Ctrl状态，1表示按下</li><li>字节第3位：键盘Alt状态，1表示按下</li><li>字节第4位：键盘ScrollLock状态，置为1表示Scroll灯亮</li><li>字节第5位：键盘NumLock状态，置为1表示小键盘已开启</li><li>字节第6位：键盘CapsLock状态，置为1表示输入大写字母</li><li>字节第7位：键盘Insert状态，置为1表示处于删除状态</li></ul><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><p>作业：编写程序覆盖int 9程序，按照自己意图来处理键盘的输入，比如在屏幕中间依次显示a~z，在显示的过程中，按下Esc键改变显示的颜色</p><p>思路：</p><ol><li>重写 int 9 中断例程，把原来的 int 9 中断例程覆盖掉 ，重写的内容如下大致如下</li><li>首先要判断我们按下的按键是不是ESC按键，需要先从60h端口读取出从键盘输入的内容（扫描码）（ in,al ）</li><li>ESC属于字符键，然后会将扫描码和对应的ASCII码送入内存的BIOS键盘缓冲区，然后对键盘系统进行相关控制（通过调用BIOS原来的 int 9 中断例程来实现 ）</li><li>由于上面第3步中要调用原来的 int 9 例程，所以我们要调用没有覆盖前的 int 9 中断例程，就需要保存原来 int 9 中断例程的入口地址（原来 int 9 中断例程入口地址 CS : IP &#x3D; 9×4 : 9×4+2），将入口地址 CS:IP 保存到 0:200、0:202 这里，用data段保存段地址和偏移地址</li><li>然后标志寄存器入栈 IF &#x3D;0、TF&#x3D;0（pushf）</li><li>然后CS:IP入栈、跳转到CS:IP（call dword ptr ds[0]）</li></ol><div class="code-wrapper"><pre><code class="hljs txt">;请将代码编写完成assume cs:code,ss:stackstack segment stackdb 128 dup (0)stack endsdata segmentdw 0,0;存放段地址和偏移地址data endscode segmentstart:mov ax,stackmov ss,axmov sp,128mov ax,datamov ds,ax;将原来的int 9中断例程入口地址进行保存，方便之后使用mov ax,0mov es,axpush es:[9*4]pop ds:[0]push es:[9*4+2]pop ds:[2];覆盖原来的int 9，在中断向量表中设置我们新的int 9中断例程的入口地址mov es:[9*4],offset myint9mov es:[9*4+2],csmov ax,0b800hmov es,axmov ah,&#x27;a&#x27;s:mov es:[160*12+40*2],ahcall sleepinc ahcmp ah,&#x27;z&#x27;jna s;把原来的int9入口地址恢复mov ax,0mov es,axpush ds:[0]pop es:[9*4]push ds:[2]pop es:[9*4+2]mov ax,4c00hint 21hsleep:push axpush dxmov dx,10h;循环1000 0000h次mov ax,0s1:sub ax,1sbb dx,0cmp ax,0jne s1cmp dx,0jne s1pop dxpop axretmyint9:push axpush bxpush esin al,60h;读取60h端口扫描码pushfcall dword ptr ds:[0]cmp al,01h;判断是不是esc键jne myint9endmov ax,0b800hmov es,axinc byte ptr es:[160*120+40*2+1]iretmyint9end:pop espop bxpop axiretcode endsend start</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>16位汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编day9</title>
    <link href="/2022/08/20/22-0820-09/"/>
    <url>/2022/08/20/22-0820-09/</url>
    
    <content type="html"><![CDATA[<h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><div class="code-wrapper"><pre><code class="hljs txt">assume cs:codecode segmentstart:mov ax,0mov dx,1mov bx,1div bxmov ax,4c00hint 21hcode endsend start</code></pre></div><p>把上面的程序编译成ayu.exe，由于除数为bx（16位），那么被除数一定为32位，被除数的高位存放在dx中，低位存放在ax中，那么根据上述程序，除数bx&#x3D;1h，被除数为dx中高位的1和ax中存放的低位0，也就是10000H，那么10000H&#x2F;1H&#x3D;10000H，而由于最后的结果存放在ax中，但是10000H远远超出了ax能存放的范围，所以会溢出，会显示出的内容如下：（注意：这个除法溢出的中断要在虚拟机windows2003下执行，在win10的dosbox中不会提示Divide overflow）</p><img src="/2022/08/20/22-0820-09/image-20220904160052203.png" class="" title="image-20220904160052203"><p>这里将 Divide overflow 改成显示 geinaizigegeshaozhi</p><p>整体思路如下：</p><ol><li>除法溢出CPU拿到0号中断类型码去中断向量表找到我们程序的入口地址</li><li>我们程序执行向屏幕上打印naizigegeshaozhi</li><li>程序返回DOS</li></ol><div class="code-wrapper"><pre><code class="hljs txt">;内存中有一段安全空间，0:200~0:2FF ，下面程序将shaozhi标号处内容存储到内存的0:200处assume cs:codestack segment stackdb 128 dup (0)stack endsdata segmentdb &#x27;geinaizigegeshaozhi!!!&#x27;,0data endscode segmentstart:mov ax,stackmov ss,axmov sp,128mov ax,csmov ds,axmov si,offset shaozhimov ax,0mov es,axmov di,200Hmov cx,shaozhi_end - shaozhicldrep movsbmov ax,4c00hint 21h;向屏幕打印给乃子烧纸shaozhi:mov ax,1mov ax,1mov ax,4c00hint 21hshaozhi_end:nopcode endsend start</code></pre></div><p>编译上述程序，并且debug调试程序：</p><p>开始在内存地址为0:200上全是0，没有数据</p><img src="/2022/08/20/22-0820-09/image-20220904160257886.png" class="" title="image-20220904160257886"><p>然后 -U 调试</p><img src="/2022/08/20/22-0820-09/image-20220904160313336.png" class="" title="image-20220904160313336"><p>然后执行完程序</p><img src="/2022/08/20/22-0820-09/image-20220904160319741.png" class="" title="image-20220904160319741"><p>然后再次d查看0:200处的地址的内容</p><img src="/2022/08/20/22-0820-09/image-20220904160325978.png" class="" title="image-20220904160325978"><p>然后查看0:200对应的指令，发现我们确实把 <code>shaozhi</code> 标号处的4条指令放到了内存 0:200 处</p><img src="/2022/08/20/22-0820-09/image-20220904160332798.png" class="" title="image-20220904160332798"><p>然后我们把<code>shaozhi</code>标号处的内容换成<code>geinaizigegeshaozhi</code>，并且把 中断类型码为 0 的地址对应的内容改成 0:200，代码如下：</p><div class="code-wrapper"><pre><code class="hljs txt">assume cs:codestack segment stackdb 128 dup (0)stack endsdata segmentdata endscode segmentstart:mov ax,stackmov ss,axmov sp,128mov ax,csmov ds,axmov si,offset shaozhimov ax,0mov es,axmov di,200Hmov cx,shaozhi_end - shaozhicldrep movsb;将0号中断入口程序地址（除法溢出中断类型码是0）改成0:200地址的内容mov ax,0mov es,axmov word ptr es:[0*4],200Hmov word ptr es:[0*4+2],0;执行除法，使程序溢出mov ax,0mov dx,1mov bx,1div bxmov ax,4c00hint 21h;向屏幕打印给乃子烧纸shaozhi:jmp shaozhi_startdb &#x27;geinaizigegeshaozhi!!!&#x27;,0shaozhi_start:mov ax,0mov ds,axmov si,203hmov ax,0b800hmov es,axmov di,12*160+72show_string:mov dl,ds:[si]cmp dl,0je returnmov es:[di],diinc siadd si,2jmp show_stringreturn:mov ax,4c00hint 21hshaozhi_end:nopcode endsend start</code></pre></div><p>这里很奇怪，执行后，没有成功。。。实际应该是可以成功的。。。</p><h1 id="CPU如何判断是否中断"><a href="#CPU如何判断是否中断" class="headerlink" title="CPU如何判断是否中断"></a>CPU如何判断是否中断</h1><p>CPU怎么知道发生中断的，它是检测标志寄存器的TF位为1的话就引发中断过程，比如中断类型码为1，则中断过程如下：</p><ol><li>取得中断类型码1</li><li>标志寄存器入栈，TF、IF设置为0</li><li>cs、ip入栈</li><li>ip&#x3D;1x4 、cs&#x3D;1x4+2</li></ol><h1 id="CPU为什么提供中断功能"><a href="#CPU为什么提供中断功能" class="headerlink" title="CPU为什么提供中断功能"></a>CPU为什么提供中断功能</h1><p>我们知道CPU执行程序时候是从CS:IP指向某个地址开始，自动向下读取指令执行，如果没有这个功能，CPU一加电，就从预设的CS:IP开始读取指令一直执行下去，不可能说执行完一条指令，去做别的事情，只有CPU提供中断后，才能够执行完一条指令后，去做一些其他的事情（比如：debug和其他断点调试就是利用CPU的中断，dosbox的-t参数就是中断，debug使用-t命令时候将TF设置1，使得CPU工作于单步中断下，在CPU执行完这条指令后就会引发单步中断）</p><p>为啥要设置TF&#x3D;0 ？？</p><p>由于TF&#x3D;1，cpu执行完一条指令后会引发单步中断，转去执行中断处理程序。所以为了避免一直中断，那么在进入中断处理程序之前，设置TF&#x3D;0，从而避免CPU在执行中断处理程序的时候又发生中断过程导致一直中断，产生死循环</p><h1 id="中断例程"><a href="#中断例程" class="headerlink" title="中断例程"></a>中断例程</h1><p>中断处理程序也叫中断例程</p><p>int指令格式为：int n，n就代表中断类型码，功能是引发中断过程，和call命令类似</p><div class="code-wrapper"><pre><code class="hljs txt">assume cs:codecode segmentstart:int 0code endsend start</code></pre></div><p>编译上述程序，在windows2003下执行，然后就会报除法溢出错误（0号中断类型码为除法溢出）</p><img src="/2022/08/20/22-0820-09/image-20220904160804997.png" class="" title="image-20220904160804997"><p>编写一个中断例程，功能是返回一个word型数据的平方，编译如下程序为test.exe</p><div class="code-wrapper"><pre><code class="hljs txt">assume cs:codecode segmentstart:mov ax,1234int 7ch;调用7ch中断例程，拿到ax的平方mov ax,4c00hint 21hcode endsend start</code></pre></div><p>编写7ch中断例程，如下，然后编译成ayu.exe</p><div class="code-wrapper"><pre><code class="hljs TXT">assume cs:codecode segmentstart:mov ax,csmov ds,axmov si,offset sqrmov ax,0mov es,axmov di,200Hmov cx,offset sqrend - offset sqrcldrep movsbmov ax,0mov es,axmov word ptr es:[7ch*4],200Hmov word ptr es:[7ch*4+2],0mov ax,4c00hint 21hsqr:mul ax;mul乘法指令，即执行ax*ax，也就是ax²iret  ;call指令和ret配合，这里int和iret配合，iret的作用就是 1.pop ip  2.pop cs  3.popfsqrend:nopcode endsend star</code></pre></div><p>调试 ayu.exe 和 test.exe，先调试 ayu.exe ，如下：</p><img src="/2022/08/20/22-0820-09/image-20220904160854310.png" class="" title="image-20220904160854310"><img src="/2022/08/20/22-0820-09/image-20220904160857194-16622789373791-16622789382312.png" class="" title="image-20220904160857194"><p>然后调试 test.exe，引发7ch中断例程的IP为<code>7ch*4=1F0</code>地址处的值 ，CS为<code>7ch*4+2=1F2</code>地址处的值，即CS:IP&#x3D;0:200</p><img src="/2022/08/20/22-0820-09/image-20220904160907876-16622789481813.png" class="" title="image-20220904160907876"><p>然后一步步调试，十进制1234转为16进制也就是3C44，然后3C44*3C44&#x3D;173C44，存放在AX和DX两个寄存器中，高位在DX中，低位在AX中，如下：</p><img src="/2022/08/20/22-0820-09/image-20220904160940339.png" class="" title="image-20220904160940339"><h1 id="BIOS、DOS"><a href="#BIOS、DOS" class="headerlink" title="BIOS、DOS"></a>BIOS、DOS</h1><p>在系统板的ROM种存放着一套程序，称为BIOS（基本输入输出系统），BIOS主要包含以下内容：</p><ol><li>硬件系统的检测和初始化程序</li><li>存储着外部中断和内部中断的中断例程</li><li>用于对硬件设备进行I&#x2F;O操作的中断例程</li><li>其他和硬件系统相关的中断例程</li></ol><p>操作系统DOS提供了中断例程（如果操作系统为windows，那么windows系统API就类似中断例程），DOS的中断例程其实就是操作系统给我们程序员提供的编程资源 （我们可以直接int指令调用中断例程，类似上面的 int 7ch 直接得到 ax 的平方）</p><p>BIOS和DOS（操作系统）所提供的中断例程中包含了许多子程序（造好的轮子），这些子程序实现了我们在编程的时候经常要用的功能，所以我们要用这些功能的时候不用自己造轮子，直接int指令调用即可</p><p>BIOS和DOS中断例程安装过程：</p><ol><li>CPU一加电（开机），初始化CS&#x3D;0FFFFH,IP&#x3D;0,自动从FFFF:0单元开始执行程序，FFFF:0处有一条跳转指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序</li><li>初始化程序将把BIOS提供的中断例程的入口地址登记在中断向量表中</li><li>硬件检测和初始化完成后，调用19h(int 19h)进行操作系统的引导，从此之后计算机交由操作系统控制</li><li>操作系统（dos）启动后，除了完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量（提供的中断例程的入口地址登记在中断向量表中）</li></ol><h1 id="中断例程的多个子程序"><a href="#中断例程的多个子程序" class="headerlink" title="中断例程的多个子程序"></a>中断例程的多个子程序</h1><p>一个供程序员调用的中断例程中往往包含多个子程序，中断例程内部用传递进来的参数来决定执行哪一个子程序。BIOS和DOS提供的中断例程都用<code>ah</code>来传递内部子程序的编号</p><p>例如 int 10h 中断例程（int 10h是BIOS提供的）中包含了很多与屏幕输出相关的子程序</p><div class="code-wrapper"><pre><code class="hljs txt">assume cs:codecode segmentstart:mov ah,2;10h中断例程里的第2个子程序功能是设置光标;设置参数mov bh,0;显存第0页mov dh,5;第5行mov dl,12;第12列;参数设置完后调用中断例程int 10hcode endsend start</code></pre></div><p>编译上述程序，然后运行exe文件</p><img src="/2022/08/20/22-0820-09/image-20220904161236687.png" class="" title="image-20220904161236687"><div class="code-wrapper"><pre><code class="hljs txt">assume cs:codecode segmentstart:mov ah,2;设置光标位置mov bh,0mov dh,7mov dl,13int 10hmov ah,9;9号子程序，功能是在光标位置显示字符mov al,&#x27;X&#x27;mov bl,11001010b;00000100b颜色属性mov bh,0;第0页mov cx,5;字符重复个数int 10hcode endsend start</code></pre></div><p>编译中上述程序，执行</p><img src="/2022/08/20/22-0820-09/image-20220904161309656.png" class="" title="image-20220904161309656">]]></content>
    
    
    <categories>
      
      <category>16位汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编day8</title>
    <link href="/2022/08/20/22-0820-08/"/>
    <url>/2022/08/20/22-0820-08/</url>
    
    <content type="html"><![CDATA[<h1 id="CPU三种工作模式"><a href="#CPU三种工作模式" class="headerlink" title="CPU三种工作模式"></a>CPU三种工作模式</h1><ul><li><p>实模式：最早的PC机，没有windows系统，一开机就是dos窗口，缺陷就是不安全，程序可以随意访问任何的物理地址</p></li><li><p>保护模式：32位cpu带有保护模式，特权级 ，0~3，0为最高特权，是内核代码所运行的级别，3是最低权限，为用户程序的运行级别</p><p>PC加载操作系统的过程：开机—&gt;加电自检—&gt;从磁盘中寻找boot引导程序去加载内核—&gt;如果装的是windows系统（多任务系统），将由它把CPU切换到保护模式下运行</p></li><li><p>虚拟8086（dos）：比如：我们电脑中日常用的dos窗口、前面常用的dosbox都是虚拟出来的</p></li></ul><h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>中断分为内中断和外中断</p><h2 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h2><p>内中断：发生了需要CPU立刻要去处理的信息。CPU发生中断的情况也是不同的，会产生了4种不同的中断信息，那就需要进行不同的处理，如下：</p><ul><li><p>除法错误（除法溢出）</p><img src="/2022/08/20/22-0820-08/image-20220904154211857.png" class="" title="image-20220904154211857"></li><li><p>单步调试，我们在前面的学习中经常用到dosbox单步调试（-t命令）</p></li><li><p>执行into指令</p></li><li><p>执行int指令</p></li></ul><h2 id="中断类型码"><a href="#中断类型码" class="headerlink" title="中断类型码"></a>中断类型码</h2><p>中断类型码：CPU在接受到中断信息后，需要判断是啥类型的中断，中断类型码就标识了它是啥中断类型</p><ul><li>除法错误—&gt;中断类型码 0</li><li>单步执行—&gt;中断类型码 1</li><li>执行into指令—&gt;中断类型码 4</li><li>执行int指令（int n）—&gt;中断类型码 n</li></ul><h2 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h2><p>中断向量表：通过中断类型码作为表项号去定位中断向量表的表项，从而获得程序的入口地址，对于8086机器，中断向量表指定存放在内存地址0000:0000到0000:03FF之间（一共124个单元）</p><p>中断向量表大致如下：</p><img src="/2022/08/20/22-0820-08/image-20220904154522947.png" class="" title="image-20220904154522947"><p>中断向量表的一个表项占4个字节（2个字)，高位地址存放段地址，低位地址存放偏移地址，比如：0号表项的中断处理程序的入口地址为 CS:IP &#x3D; 0020:0100，那么0号表项具体如下：</p><img src="/2022/08/20/22-0820-08/image-20220904154621695.png" class="" title="image-20220904154621695"><p>作业：现在问：2号中断源处理程序的入口地址是啥？？？？</p><p>解答：</p><img src="/2022/08/20/22-0820-08/image-20220904154640150.png" class="" title="image-20220904154640150"><p>2号中断源处理程序的入口地址CS:IP &#x3D; 0070:0008</p><h2 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h2><p>用中断类型码找到中断向量（中断向量表中的表项），用它设置CS:IP，这个称为中断过程，由CPU硬件自动完成</p><p>整个中断的过程大致如下：<br>CPU收到中断信息—&gt;要对中断信息做处理—&gt;首先将引发中断过程—&gt;硬件完成自动完成中断过程—&gt;CS:IP会指向中断处理程序的入口，CPU就会执行这个中断处理程序</p><p>注意：程序执行完中断处理程序后，肯定还要回到原程序继续往后执行，所以硬件肯定会把执行中断前的CS:IP的值保存起来（通过将CS和IP入栈来进行保存），然后执行完中断处理程序后，再将CS:IP指向之前的CS:IP，使程序继续向下执行</p><p>中断过程6部区：</p><ol><li>取得中断类型码N</li><li>标志寄存器的值入栈</li><li>设置标志寄存器的第8位TF和第9位EF的值，将这两个值改为0</li><li>CS入栈</li><li>IP入栈</li><li>从内存地址中找到中断类型码<code>N*4</code>和<code>N*4+2</code>的两个字单元中，读取中断处理程序的入口地址，设置IP和CS</li></ol><h2 id="IRET指令"><a href="#IRET指令" class="headerlink" title="IRET指令"></a>IRET指令</h2><p>IRET指令：中断返回，中断服务程序的最后⼀条指令。IRET指令将推⼊堆栈的段地址和偏移地址弹出，使程序返回到原来发⽣中断的地⽅。其作⽤是从中断中恢复中断前的状态。</p><p>IRET作用大致相当于如下3条指令的功能：</p><div class="code-wrapper"><pre><code class="hljs txt">POP IPPOP CSPOPF</code></pre></div><h2 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h2><p>外中断 ：来自于 CPU 外部，CPU 检测到发送过来的中断信息，引发中断过程，处理外设的输入</p><p>主板和接口板上装有各种接口芯片，这些外设接口芯片里面有一些寄存器，CPU是把这些寄存器当作<strong>端口</strong>来访问。外设的输入不直接送入内存和CPU，而是送入相关接口芯片端口里面，cpu向外设的输出也是先送到端口，再由端口的相关芯片送到外设。（<strong>cpu通过端口和外部设备进行联系</strong>）</p><p>外中断源分为2种：</p><ul><li><p>可屏蔽中断，CPU可以不鸟你的外中断，搭不搭理你要看标志寄存器IF位的设置，IF&#x3D;1要搭理你，IF&#x3D;0不鸟你，不响应（几乎所有的外设引发的外中断都是可屏蔽中断）</p><p>如果IF&#x3D;1，那么中断步骤如下：</p><ol><li>取得中断类型码</li><li>标志寄存器入栈 pushf </li><li>TF&#x3D;0 IF&#x3D;0</li><li>CS IP入栈</li><li>设置cs和ip指向处理中断的程序</li></ol></li><li><p>不可屏蔽中断。中断类型码固定是2，见到这个，CPU必须要引发中断过程</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>16位汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编Day7</title>
    <link href="/2022/08/20/22-0820-07/"/>
    <url>/2022/08/20/22-0820-07/</url>
    
    <content type="html"><![CDATA[<h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1> <img src="/2022/08/20/22-0820-07/image-20220904115923463.png" class="" title="image-20220904115923463"><img src="/2022/08/20/22-0820-07/image-20220904115940443.png" class="" title="image-20220904115940443"><p>实现效果如下：</p><img src="/2022/08/20/22-0820-07/image-20220904120204099.png" class="" title="image-20220904120204099"><blockquote><p>这个题目好tm的难理解。。</p></blockquote><div class="code-wrapper"><pre><code class="hljs txt">作业解答:assume cs:code,ds:data,ss:stackdata segment    ;数据段    db  &#x27;geinaizishaozhi&#x27;      db  1000 0010B      ;闪烁(高亮)绿色    db  1010 0100B          ;高亮绿底红色    db  1111 0001B          ;高亮白底蓝色data endsstack segment stack   ;栈段    db 128 dup(0)stack endscode segment    start:        mov ax,stack        mov ss,sp        mov sp,128                ;数据从哪里来？？从data段中来        mov ax,data        mov ds,ax        mov si,0            mov bx,16                ;数据要到哪里去? 到显存中        mov ax,0b800H        mov es,ax        mov di,160*12+60        mov cx,3                ;处理数据    s0: push cx        push si        push di        mov cx,16            s:  mov dh,ds:[bx]          ;dx=dh+dl        mov dl,ds:[si]        mov es:[di],dx        inc si        add di,2        loop s                pop di        pop si        pop cx        add di,160        inc bx        loop s0                mov ax,4c00h        int 21h        code endsend start</code></pre></div><h1 id="call"><a href="#call" class="headerlink" title="call"></a>call</h1><p>day6 的学习中最后学习到了 <code>依据位移进行转移的call指令</code> ，今天学习下面的：</p><h2 id="转移的目的地址在指令中的CALL"><a href="#转移的目的地址在指令中的CALL" class="headerlink" title="转移的目的地址在指令中的CALL"></a>转移的目的地址在指令中的CALL</h2><ul><li><p>转移的目的地址在指令中的CALL：<code>call for ptr 标号</code>实现是段间转移</p><img src="/2022/08/20/22-0820-07/image-20220904143244067.png" class="" title="image-20220904143244067"></li><li><p>转移地址在寄存器的call：相当于只会push一个ip，然后跳转一个16位寄存器（比如：jmp ax）</p></li><li><p>转移地址在内存中的call：有如下两种格式：</p><ul><li><code>call word ptr [内存单元地址]</code> （相当于先把ip放到栈中push ip，然后跳转到内存单元 jmp word ptr 内存单元）</li><li><code>call dword ptr [内存单元地址]</code>（相当于先push cs，再push ip，然后跳转到内存单元 jmp dword ptr 内存单元 ）</li></ul></li></ul><h1 id="call、ret、retf的结合"><a href="#call、ret、retf的结合" class="headerlink" title="call、ret、retf的结合"></a>call、ret、retf的结合</h1><p>比如说我们对上面的作业设计成类似C语言的函数的结构，类似于先调用initReg函数，再调用showStr</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code,<span class="hljs-built_in">ds</span>:data,<span class="hljs-built_in">ss</span>:stackdata <span class="hljs-meta">segment</span><span class="hljs-comment">;数据段</span><span class="hljs-built_in">db</span><span class="hljs-string">&#x27;geinaizishaozhi&#x27;</span> <span class="hljs-built_in">db</span><span class="hljs-number">1000</span> <span class="hljs-number">0010B</span><span class="hljs-comment">;闪烁(高亮)绿色</span><span class="hljs-built_in">db</span><span class="hljs-number">1010</span> <span class="hljs-number">0100B</span>        <span class="hljs-comment">;高亮绿底红色</span><span class="hljs-built_in">db</span><span class="hljs-number">1111</span> <span class="hljs-number">0001B</span><span class="hljs-comment">;高亮白底蓝色</span>data endsstack <span class="hljs-meta">segment</span> stack   <span class="hljs-comment">;栈段</span><span class="hljs-built_in">db</span> <span class="hljs-number">128</span> dup(<span class="hljs-number">0</span>)stack endscode <span class="hljs-meta">segment</span><span class="hljs-symbol">start:</span><span class="hljs-keyword">call</span> initReg<span class="hljs-comment">;目的是初始化 </span><span class="hljs-keyword">call</span> showStr<span class="hljs-comment">;目的在屏幕上显示字符串</span><span class="hljs-symbol"></span><span class="hljs-symbol">initReg:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,stack<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>,<span class="hljs-built_in">sp</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>,<span class="hljs-number">128</span><span class="hljs-comment">;数据从哪里来？？从data段中来</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,data<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">16</span><span class="hljs-comment">;数据要到哪里去? 到显存中</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0b800H</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">160</span>*<span class="hljs-number">12</span>+<span class="hljs-number">60</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">3</span><span class="hljs-keyword">ret</span> <span class="hljs-symbol"></span><span class="hljs-symbol">showStr:</span><span class="hljs-symbol">s0:</span><span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><span class="hljs-keyword">push</span> <span class="hljs-built_in">si</span><span class="hljs-keyword">push</span> <span class="hljs-built_in">di</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">16</span><span class="hljs-symbol">s:</span><span class="hljs-keyword">mov</span> <span class="hljs-number">dh</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">bx</span>]<span class="hljs-comment">;dx=dh+dl</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">si</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">di</span>],<span class="hljs-built_in">dx</span><span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">2</span><span class="hljs-keyword">loop</span> s<span class="hljs-keyword">pop</span> <span class="hljs-built_in">di</span><span class="hljs-keyword">pop</span> <span class="hljs-built_in">si</span><span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">160</span><span class="hljs-keyword">inc</span> <span class="hljs-built_in">bx</span><span class="hljs-keyword">loop</span> s0<span class="hljs-keyword">ret</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span>code endsend start</code></pre></div><h1 id="mul乘法指令"><a href="#mul乘法指令" class="headerlink" title="mul乘法指令"></a>mul乘法指令</h1><p>mul乘法指令，要求两个数都是8位，或者2个数都是16做乘法，如果是8位乘法，一个默认放在al中，另一个在另外一个8位寄存器或者内存里面；如果是16位乘法，一个默认放在ax中，另一个在另外一个16位寄存器或者内存单元里面，8位的乘法结果在ax里面，16位乘法结果高位在DX，低位存放在AX中</p><p>比如：8位的乘法，10*5</p><img src="/2022/08/20/22-0820-07/image-20220904144158260.png" class="" title="image-20220904144158260"><p>比如：16位的乘法，64*2710的值，注意：这里的64和2710都是16进制，如果转为10进制的话就是<code>100*10000</code>，而8位寄存器最大值存放是255，这里显然必须要用到16位寄存器</p><img src="/2022/08/20/22-0820-07/image-20220904144208808.png" class="" title="image-20220904144208808"><p>高位存放在DX中，低位存放在AX中，两个合并后：F4240 即 1,000,000</p><h1 id="除法溢出"><a href="#除法溢出" class="headerlink" title="除法溢出"></a>除法溢出</h1><blockquote><p>关于除法指令div前面已经学过</p></blockquote><img src="/2022/08/20/22-0820-07/image-20220904144328640.png" class="" title="image-20220904144328640"><p>如何解决除法溢出，解决除法溢出的公式如下：</p><p><code>X/N = int(H/N)*65536+[rem(H/N)65536+L]/N</code>该公式其实就是把x&#x2F;n可能溢出的除法运算转变成多个不会产生溢出的除法运算</p><p>其中：X表示被除数，N表示除数，H表示X的高16位，L表示X的低16位，int()表示取商，rem()表示取余数</p><img src="/2022/08/20/22-0820-07/image-20220904144337906.png" class="" title="image-20220904144337906"><h1 id="标志（FLAG）寄存器"><a href="#标志（FLAG）寄存器" class="headerlink" title="标志（FLAG）寄存器"></a>标志（FLAG）寄存器</h1><p>标志寄存器的作用：</p><ul><li>存储相关指令的某些执行结果</li><li>用来为CPU执行相关指令提供依据</li><li>控制CPU的相关工作方式</li></ul><img src="/2022/08/20/22-0820-07/image-20220904145027592.png" class="" title="image-20220904145027592"><p>标志寄存器也是16位，也就是2个字节，标志寄存器存的信息通常被称为程序状态字（PSW），标志寄存器是按位起作用的，一共有16位，每个位的含义都是不同的</p><img src="/2022/08/20/22-0820-07/image-20220904145039141.png" class="" title="image-20220904145039141"><h2 id="ZF标志位"><a href="#ZF标志位" class="headerlink" title="ZF标志位"></a>ZF标志位</h2><p>ZF标志（零标志位）：记录相关运算结果是否为0，如果ZF为1，代表运算结果为0，如果ZF为0，代表运算结果不为0</p><div class="code-wrapper"><pre><code class="hljs perl">mov ax,<span class="hljs-number">1</span><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">ax</span>,1  </span>;<span class="hljs-function"><span class="hljs-keyword">sub</span>减法指令</span><span class="hljs-function">执行上面两条命令后，<span class="hljs-title">ax</span>=0，则<span class="hljs-title">ZF</span>标志位为1</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">2</span><span class="hljs-keyword">sub</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">1</span>执行上面两条指令后，<span class="hljs-built_in">ax</span>≠<span class="hljs-number">0</span>，则ZF标志位为<span class="hljs-number">0</span></code></pre></div><img src="/2022/08/20/22-0820-07/image-20220904145146424.png" class="" title="image-20220904145146424"><p>由于ZF标志位和运算结果相关，那么ZF标志位就会影响到标志寄存器，在8086CPU指令集中，如下指令都会影响到标志寄存器的某些位（这里应该就是影响zf标志位）：<br>add、sub、mul、div、inc、or、and会影响标志寄存器的某些位</p><h2 id="PF标志位"><a href="#PF标志位" class="headerlink" title="PF标志位"></a>PF标志位</h2><p>PF标志位（奇偶数标志位）：相关指令之后，其结果所有的bit位中1的个数是否为偶数</p><div class="code-wrapper"><pre><code class="hljs txt">mov al,1add al,10执行后的结果为11（注意：这里是10进制的11，但是dosbox这么写貌似是16进制的，实际应该写成mov 10h这种形式才更加规范的表示16进制，后面学习反正也不用dosbox。。），ax对应的二进制就是00001011B，一共有3个(奇数个)1，则pf=0</code></pre></div><p>如下 为dosbox中，和上面例子有些区别。。。这里是16进制，上面例子是10进制的。。。</p><img src="/2022/08/20/22-0820-07/image-20220904145305977.png" class="" title="image-20220904145305977"><div class="code-wrapper"><pre><code class="hljs txt">mov al,1or al,2执行后的二进制结果为00000011B，有2个(偶数个)1，则pf=1</code></pre></div><h2 id="SF标志位"><a href="#SF标志位" class="headerlink" title="SF标志位"></a>SF标志位</h2><p>SF标志位（符号标志位）：这个标志位是对<code>有符号数</code>结果的记录，注意这里记录的是有符号数，比如：对于<code>10000001B</code>而言，如果是无符号数代表129，但如果换算成有符号数则代表-127，计算过程如下：</p><div class="code-wrapper"><pre><code class="hljs txt">10000001b的反码为11111110b，补码为11111111b（此亦是原码），即十进制的－127。补充反码和补码计算过程：正数的反码与其原码相同;负数的反码是对其原码逐位取反,但符号位除外。正数的补码与其原码相同,负数的补码是在其反码的末位加1</code></pre></div><p>相关指令执行后，其结果是否为负数，则SF&#x3D;1，结果为非负数，则SF&#x3D;0</p><div class="code-wrapper"><pre><code class="hljs txt">mov al,10000001Badd al,1B执行后结果为1000 0010B，1000 0010B有符号数转化后就是10进制的-126,由于是负数，sf=1</code></pre></div><div class="code-wrapper"><pre><code class="hljs txt">mov al,10000001Badd al,01111111B执行后结果为0，则sf=0</code></pre></div><h2 id="CF标志"><a href="#CF标志" class="headerlink" title="CF标志"></a>CF标志</h2><p>CF标志：在进行<code>无符号运算</code>时，记录了2个数做加法的进位值，或是2个数做减法的借位值</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">98h</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">al</span>上述代码执行后，<span class="hljs-built_in">al</span>=<span class="hljs-number">30h</span>，cf=<span class="hljs-number">1</span>，cf记录了进位值</code></pre></div><p>两个数字做加法：</p><p>正常来说16进制的：98+98&#x3D;130</p><img src="/2022/08/20/22-0820-07/image-20220904145736058.png" class="" title="image-20220904145736058"><p>通过计算器我们发现两个十六进制98相加后，对应10进制为 1 0011 0000 显然已经超出了16位，那么我们只能将最高位的1放到标志寄存器中，所以最终的结果为 110000B ，也就是30h</p><img src="/2022/08/20/22-0820-07/image-20220904145749740.png" class="" title="image-20220904145749740"><p>两个数字做减法：</p><div class="code-wrapper"><pre><code class="hljs txt">mov al,97hsub al,98h执行后al=FFh，CF=1，cf记录了借位值</code></pre></div><img src="/2022/08/20/22-0820-07/image-20220904145809148.png" class="" title="image-20220904145809148"><div class="code-wrapper"><pre><code class="hljs txt">sub al,al  执行后al=0，cf=0</code></pre></div><h2 id="OF标志位"><a href="#OF标志位" class="headerlink" title="OF标志位"></a>OF标志位</h2><p>OF标志：记录<code>有符号数</code>运算时是否发生了溢出，溢出，则OF&#x3D;1，没有溢出，则OF&#x3D;0（注意和CF做区分，CF是针对无符号数的）</p><div class="code-wrapper"><pre><code class="hljs dns">比如：<span class="hljs-number">88</span>有符号数(<span class="hljs-number">16</span>进制)，对应二进制为<span class="hljs-number">10001000</span>，这里的<span class="hljs-number">10001000</span>是补码，先将补码转为反码<span class="hljs-number">11110111</span>，然后将反码+<span class="hljs-number">1</span>转为原码<span class="hljs-number">1111 1000</span>，该原码高位第一个<span class="hljs-number">1</span>是符号位，剩下的<span class="hljs-number">111 1000</span>就是<span class="hljs-number">120</span>，也就是-<span class="hljs-number">120</span>F0有符号数(<span class="hljs-number">16</span>进制)，对应二进制为<span class="hljs-number">11110000</span>，也就是-<span class="hljs-number">16</span>（转化过程同上）mov al,<span class="hljs-number">88h</span>add al,F0执行指令相加后，-<span class="hljs-number">120</span>+(-<span class="hljs-number">16</span>)=<span class="hljs-number">136</span>，但是<span class="hljs-number">8</span>位的al寄存器范围为-<span class="hljs-number">128~127</span>，显然这里溢出了</code></pre></div><img src="/2022/08/20/22-0820-07/image-20220904145938288.png" class="" title="image-20220904145938288"><h2 id="DF标志位"><a href="#DF标志位" class="headerlink" title="DF标志位"></a>DF标志位</h2><p>DF标志位（方向标志位）：控制si、di的增减</p><ul><li>df&#x3D;0时，si、di递增</li><li>df&#x3D;1时，每次操作si、di递减</li></ul><h2 id="debug中标志寄存器的表示如下"><a href="#debug中标志寄存器的表示如下" class="headerlink" title="debug中标志寄存器的表示如下"></a>debug中标志寄存器的表示如下</h2><table><thead><tr><th>标志</th><th>值为1的标记</th><th>值为0的标记</th></tr></thead><tbody><tr><td>of</td><td>OV (overflow)</td><td>NV(not overflow)</td></tr><tr><td>sf</td><td>NG(负数)</td><td>PL(正数)</td></tr><tr><td>zf</td><td>ZR(为0)</td><td>NZ(not zero 不为0)</td></tr><tr><td>pf</td><td>PE(偶数)</td><td>PO(奇数)</td></tr><tr><td>cf</td><td>CY(carry yes有进位或借位)</td><td>NC(not carry 没有进或借)</td></tr><tr><td>df</td><td>DN(向下)</td><td>UP(向上)</td></tr></tbody></table><h1 id="adc指令（add-carry）"><a href="#adc指令（add-carry）" class="headerlink" title="adc指令（add+carry）"></a>adc指令（add+carry）</h1><p>adc指令（add+carry）：带进位的加法指令，会把CF位上记录的<code>进位值/借位值</code>加起来</p><div class="code-wrapper"><pre><code class="hljs txt">mov ax,2mov bx,1sub bx,ax  ;由于是无符号数，且1-2肯定是要借位的，CF=1adc ax,1   ;等价于ax+1，然后再加上cf，也就是ax+1+cf=2+1+1=4</code></pre></div><div class="code-wrapper"><pre><code class="hljs txt">mov ax,1add ax,ax;这里没有进位或借位，cf=0adc ax,5;ax+5+cf=2+5+9=7</code></pre></div><div class="code-wrapper"><pre><code class="hljs txt">利用adc对任意大的数据进行加法，计算1EF0001000H+2010001EF0H1EF0001000H = 001E F000 1000H2010001EF0H = 0020 1000 1EF0Hmov ax,001EHmov bx,F000Hmov cx,1000Hadd cx,1EF0Hadc bx,1000Hadc ax,0020H</code></pre></div><h1 id="sbb指令"><a href="#sbb指令" class="headerlink" title="sbb指令"></a>sbb指令</h1><p>sbb指令：带借位的减法指令（应用类似于adc）</p><h1 id="cmp比较指令"><a href="#cmp比较指令" class="headerlink" title="cmp比较指令"></a>cmp比较指令</h1><p>cmp比较指令：功能相当于减法指令，但是不保存结果，cmp指令执行后，对标志寄存器产生影响</p><div class="code-wrapper"><pre><code class="hljs txt">cmp ax,ax;相当于ax-ax，但是并不保存结果在ax中，仅仅是为了影响标志寄存器的相关位，该指令执行后，标志寄存器中的zf=1，pf=1，sf=0，cf=0，f=0无符号数的比较cmp ax,bx如果ax = bx 相减结果为0，所以zf=1如果ax 不等于 bx，相减结果不为0，所以zf=0如果ax &lt; bx 必然产生借位，所以cf=1如果ax &gt; bx 既不会产生借位，结果又不可能是0，所以cf=0并且zf=0如果ax 大于等于 bx，不会借位，cf=0如果ax 小于等于 bx，可能会产生借位，结果也可能为0，所以cf=1或zf=1通过这点我们就可以看出这指令的设计思路：通过做减法运算，影响标志寄存器，标志寄存器的相关位就记录了比较的结果</code></pre></div><h1 id="检测比较结果的条件转移指令"><a href="#检测比较结果的条件转移指令" class="headerlink" title="检测比较结果的条件转移指令"></a>检测比较结果的条件转移指令</h1><blockquote><p>转移指令：即修改ip的指令，比如之前学过的jcxz指令</p></blockquote><p>cmp和检测标志位的条件转移配合使用，就像call和ret</p><div class="code-wrapper"><pre><code class="hljs txt">指令    含义     检测的相关标志位je   等于则转移   zf=1jne  不等于则转移  zf=0jb   低于则转移   cf=1 jnb  不低于则转移  cf=0ja   高于则转移    cf=0且zf=0jna  不高于则转移  cf=1或zf=1比如：实现条件判断……（相当于高级语言的if）如果ah = bh 则ah= ah+ah 否则ah=ah+bh实现的具体指令如下：cmp ah,bh;比较ah和bh的值je s;如果ah和bh相等，则跳转到s标号add ah,bhjmp ok;为了避免执行完add ah,bh后执行s标号处的指令，所以直接跳转到程序结束s:add ah,ahok:mov ax,4c00h;程序结束的地方int 21h</code></pre></div><h1 id="串传送指令"><a href="#串传送指令" class="headerlink" title="串传送指令"></a>串传送指令</h1><h2 id="movsb"><a href="#movsb" class="headerlink" title="movsb"></a>movsb</h2><p>movsb：每次传送一个字节，将ds:si指向的内存单元中的字节送入es:di中，根据df的值，将si和di递增或递减</p><div class="code-wrapper"><pre><code class="hljs txt">mov es:[di],ds:[si] df=0的话inc siinc didf=1的话dec sidec di</code></pre></div><h2 id="movsw"><a href="#movsw" class="headerlink" title="movsw"></a>movsw</h2><p>movsw：每次传送一个字，将ds:si指向的内存单元中的字节送入es:di中，根据df的值，将si和di递增2或者递减2</p><div class="code-wrapper"><pre><code class="hljs txt">mov es:[di],ds:[si] df=0的话add si,2add di,2df=1的话sub si,2sub di,2</code></pre></div><h1 id="rep指令"><a href="#rep指令" class="headerlink" title="rep指令"></a>rep指令</h1><p>rep指令：在CX不等于0的情况下，重复执行后面的指令，重复的次数也在CX中，重复一次后CX-1</p><div class="code-wrapper"><pre><code class="hljs txt">比如说:rep movsb 也就是一直执行movsb指令（当然还要看cx的值），等价于下面的指令：s: movsbloop s</code></pre></div><h1 id="cld、std指令"><a href="#cld、std指令" class="headerlink" title="cld、std指令"></a>cld、std指令</h1><p>cld指令：将DF位设置为0</p><p>std指令：将DF位设置为1</p><div class="code-wrapper"><pre><code class="hljs txt">作业：;将data段中的第一个字符串复制到它后面的空间中data segmentdb &#x27;geinaizishaozhi!&#x27;db 16 dup (0)data endscode segment;设置ds:si指向data:0mov ax,datamov ds,axmov si,0mov es,axmov di,16mov cx,16cld;设置df=0，每次si和di递增rep movsb;如果每次传送一个字cx改成8，movsb替换成movswcode ends</code></pre></div><h1 id="pushf指令"><a href="#pushf指令" class="headerlink" title="pushf指令"></a>pushf指令</h1><p>pushf指令：将标志寄存器的值压栈</p><p>当前栈的内容</p><img src="/2022/08/20/22-0820-07/image-20220904153245753.png" class="" title="image-20220904153245753"><p>执行pushf后栈的内容</p><img src="/2022/08/20/22-0820-07/image-20220904153256032.png" class="" title="image-20220904153256032"><p>7202是标志寄存器的值，转化成二进制即：</p><div class="code-wrapper"><pre><code class="hljs txt">111 0010 0000 0010</code></pre></div><p>这16位就对应如下图：</p><img src="/2022/08/20/22-0820-07/image-20220904153322175.png" class="" title="image-20220904153322175"><h1 id="popf指令"><a href="#popf指令" class="headerlink" title="popf指令"></a>popf指令</h1><p>popf指令：从栈顶弹出数据送入标志寄存器</p>]]></content>
    
    
    <categories>
      
      <category>16位汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编Day6</title>
    <link href="/2022/08/20/22-0820-06/"/>
    <url>/2022/08/20/22-0820-06/</url>
    
    <content type="html"><![CDATA[<h1 id="jcxz"><a href="#jcxz" class="headerlink" title="jcxz"></a>jcxz</h1><p>上节课学了段内和段间转移，但实际在操作中，我们直接使用 jmp s 即可，不需要写成 jmp short s 或 jmp far s 这样 ,不用考虑其它，那些都是编译器要考虑的事情</p><p>转移地址在寄存器里面，如：jmp ax，jmp bx</p><p>转移地址在内存中（段内转移），如下：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0123H</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>],<span class="hljs-built_in">ax</span><span class="hljs-keyword">jmp</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>]   <span class="hljs-comment">;就是jmp到ds:0123地址的地方，执行后ip=0123h</span></code></pre></div><p>转移地址在内存中（段间转移），修改cs和ip偏移地址，高地址的字是目的段地址，低地址处存放的目的偏移地址，如下：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0123h</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>],<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">2</span>],<span class="hljs-number">0</span><span class="hljs-keyword">jmp</span> <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>]   <span class="hljs-comment">;执行完后，ip=0123H，cs=0，即cs:ip = 0000:0123</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs TXT">作业：;要求执行jmp指令后，cs:ip指向程序需要的第一条指令assume cs:codedate segmentdd 12345678Hdata endscode segmentstart:mov ax,datamov ds,axmov bx,0mov bx,???mov [bx+2],??? jmp dword ptr ds:[0]code endsend start解答：第一个？为0,第二个是cs</code></pre></div><p>有条件的跳转指令 jcxz ，所有有条件的转移指令都是短转移，范围是 -128~127，if cx 等于0，那么就会执行 jcxz ，也就是会 jmp short 标号，如果if cx不为0，那么就啥也不干（程序按顺序向下执行），恰好和loop指令相反（loop是cx不等于0的时候执行）</p><div class="code-wrapper"><pre><code class="hljs txt">作业：利用jcxz指令，实现在内存2000H段中查找到第一个值为0的字节，找到后将它的偏移地址存在dx中code segmentstart:mov ax,2000Hmov ds,axmov bx,0s:___mov ch,0___           ;这里ch和cl合并就是cx，cx=0时，jcxz跳转到ok标号处___mov cl,[bx]______jcxz ok______inc bx___jmp sok:mov dx,bxmov ax,4c00hint 21hcode endsend start</code></pre></div><p>loop指令也是转移指令，所有循环指令都是短转移，在对应的机器码中包含转移的偏移地址，-128~127</p><p>loop 标号，cx &#x3D; cx -1，判断cx不等于0，转移到标号处执行指令，如果等于0什么也不做。</p><p>通过分析下面的程序，在运行前思考这个程序可以正确返回吗？？运行后再思考：为啥是这种结果？？？通过该程序加深对相关内容理解，注意jmp指令对应的机器码，cpu最终执行的是机器码</p><div class="code-wrapper"><pre><code class="hljs txt">assume cs:codesgcodesg segment        mov ax,4c00h        int 21hstart:  mov ax,0    s:  nop        nop        mov di,offset s        mov si,offset s2        mov ax,cs:[si]        mov cs:[di],ax    s0: jmp short s    s1: mov ax,0        int 21h        mov ax,0    s2: jmp short s1        nopcodesg endsend start</code></pre></div><h1 id="ret、retf、call"><a href="#ret、retf、call" class="headerlink" title="ret、retf、call"></a>ret、retf、call</h1><p>CALL、RET、RETF指令都是转移指令，其中CALL、RET修改ip，RETF同时修改cs和ip，可以通过这三个指令的配合实现子程序设计（相当于其它语言的函数功能）</p><h2 id="ret、retf"><a href="#ret、retf" class="headerlink" title="ret、retf"></a>ret、retf</h2><p>cpu执行ret指令时，把栈顶的数据赋值给ip，就等价于如下：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ip</span><span class="hljs-built_in">ip</span> = (<span class="hljs-built_in">ss</span>*<span class="hljs-number">16</span>+<span class="hljs-built_in">sp</span>) ,这里用括号表示<span class="hljs-built_in">ip</span>是<span class="hljs-built_in">ss</span>*<span class="hljs-number">16</span>+<span class="hljs-built_in">sp</span>地址对应的值<span class="hljs-built_in">sp</span> = <span class="hljs-built_in">sp</span>+<span class="hljs-number">2</span></code></pre></div><img src="/2022/08/20/22-0820-06/image-20220904114503770.png" class="" title="image-20220904114503770"><p>cpu执行retf指令时，把栈顶的数据赋值给ip，然后把第二次栈顶的数据赋值给cs，也就是pop两次，先pop ip，再pop cs，如下：</p><img src="/2022/08/20/22-0820-06/image-20220904114556768.png" class="" title="image-20220904114556768"><div class="code-wrapper"><pre><code class="hljs txt">作业:补全程序，实现从内存1000:0000处开始执行指令stack segmentdb 16 dup (0)stack endscode segmentstart:mov ax,stackmov ss,axmov sp,16mov ax,_1000h___push axmov ax,__0000h__push axretfcode endsend start</code></pre></div><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p>call指令：分为依据位移进行转移和转移目的地址在指令中</p><h3 id="依据位移进行转移的call指令"><a href="#依据位移进行转移的call指令" class="headerlink" title="依据位移进行转移的call指令"></a>依据位移进行转移的call指令</h3><ul><li><p>call 标号（将当前的ip压栈后，跳到标号处执行指令）</p><img src="/2022/08/20/22-0820-06/image-20220904114854730.png" class="" title="image-20220904114854730"><p>执行后ax的值为6，执行call s后，会把当前ip 0006放到栈内，然后跳到 s 标号处，执行pop ax命令，将栈顶的0006给ax，所以最终ax为6</p><p><strong>这里一定要记住：CPU执行命令的三部曲：</strong></p><ol><li>从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器</li><li><strong>IP+读取到的指令长度，指向下一条指令</strong>（所以上面执行call s前，当前的ip为3+3&#x3D;6）</li><li>执行指令缓冲器中的指令</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>16位汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编Day5</title>
    <link href="/2022/08/20/22-0820-05/"/>
    <url>/2022/08/20/22-0820-05/</url>
    
    <content type="html"><![CDATA[<h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><div class="code-wrapper"><pre><code class="hljs txt">作业：1.将datasg段中每个单词的前四个字母改为大写字母，（每个段大小是16字节，对齐方便寻址）assume cs:codesg,ss:stacksg,ds:datasgdatasg segment  db &#x27;1. naizi      &#x27;  db &#x27;2. madou        &#x27;  db &#x27;3. hackr      &#x27;  db &#x27;4. sec66       &#x27;datasg ends解答：assume cs:code,ss:stacksg,ds:datasgdatasg segment  db &#x27;1. naizi&#x27;  db &#x27;2. madou&#x27;  db &#x27;3. hackr&#x27;  db &#x27;4. sec66&#x27;datasg endsstacksg segmentstack db 128 dup()stacksg endscode segmentstart:mov ax,stacksgmov ss,axmov sp,128mov ax,datasgmov ds,axmov cx,4mov bx,0s:push cxmov si,0    mov cx,5s1:and byte ptr 3[bx][si],11011111B inc siloop s1add bx,16pop cxloop smov ax,4c00hint 21hcode endsend start</code></pre></div><h1 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h1><p>offset 是由编译器处理的符号，作用是取标号的<code>偏移地址</code></p><p>比如：</p><div class="code-wrapper"><pre><code class="hljs X86ASM"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codecode <span class="hljs-meta">segment</span><span class="hljs-symbol">start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,offset start    <span class="hljs-comment">;相当于mov ax,0</span><span class="hljs-symbol">s:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,offset s        <span class="hljs-comment">;相当于mov ax,3，由于前面的mov ax,offset start机器码占三个字节，所以这里偏移3，即mov ax,3</span>code endsend start</code></pre></div><p>如下：</p><img src="/2022/08/20/22-0820-05/image-20220904102253206.png" class="" title="image-20220904102253206"><p>注意：</p><div class="code-wrapper"><pre><code class="hljs txt">bx不能和bp加在一起寻址，如：[bx+bp]si不能和di加在一起寻址，如：[si+ds]可以用bx+si或di  bp+si或di</code></pre></div><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codecode <span class="hljs-meta">segment</span><span class="hljs-symbol">s:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">bx</span>           <span class="hljs-comment">;将mov ax,bx指令放到nop处</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,offset s         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,offset s0<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">cs</span>:[<span class="hljs-built_in">si</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">cs</span>:[<span class="hljs-built_in">di</span>],<span class="hljs-built_in">ax</span><span class="hljs-symbol">s0:</span><span class="hljs-keyword">nop</span><span class="hljs-keyword">nop</span>code endsend s</code></pre></div><p>详解：</p><p>上述代码目的如下：</p><img src="/2022/08/20/22-0820-05/image-20220904102603672.png" class="" title="image-20220904102603672"><p>调式代码：</p><img src="/2022/08/20/22-0820-05/image-20220904102612033.png" class="" title="image-20220904102612033"><img src="/2022/08/20/22-0820-05/image-20220904102616212.png" class="" title="image-20220904102616212"><p>注意：这里在-t的话，下一步也就是执行mov ax,cs:[si]</p><img src="/2022/08/20/22-0820-05/image-20220904102625227.png" class="" title="image-20220904102625227"><p>执行mov ax,cs:[si]，此时cs为076a，si为0000，也就是cs:si，076a:0地址对应的值如下：</p><img src="/2022/08/20/22-0820-05/image-20220904102633273.png" class="" title="image-20220904102633273"><p>而8BC3也就是mov ax,bx的机器码</p><img src="/2022/08/20/22-0820-05/image-20220904102641288.png" class="" title="image-20220904102641288"><p>然后我们 -T 执行，ax的值变成了C38B，然后再次-T，就会执行mov cs:[di],ax</p><img src="/2022/08/20/22-0820-05/image-20220904102647758.png" class="" title="image-20220904102647758"><p>注意：cs:di是076A:000E，而076a:000E默认对应的机器码是09，执行 NOP指令</p><img src="/2022/08/20/22-0820-05/image-20220904102655826.png" class="" title="image-20220904102655826"><p>执行完mov cs:[di],ax就会将ax的值C38B给076A:000E，那么076A:000E对应机器码就是C38B，NOP指令就会变成mov ax,bx</p><p>我们发现-T执行完 mov cs:[di],ax 后，本来下面应该是执行NOP指令，但是NOP指令已经变成了mov ax,bx，所以下面执行mov ax,bx</p><img src="/2022/08/20/22-0820-05/image-20220904102705040.png" class="" title="image-20220904102705040"><p><strong>注意：</strong><br>这里的cs:[si]，其中cs是指令寄存器的段地址，而[si]是指令寄存器的偏移地址，前面最常用的就是ds:[0]这种，注意这里的ds不能省略，不能写成 [0]，但是 ds:[bx] 这样的是可以省略ds，写成[bx]（因为汇编编译器和debug对指令的处理不同，详见：汇编day3）</p><h1 id="转移指令（jmp）"><a href="#转移指令（jmp）" class="headerlink" title="转移指令（jmp）"></a>转移指令（jmp）</h1><p>可以修改ip，或者同时修改cs和ip的指令统称之为转移指令</p><p>只修改ip，称之为段内转移，比如：jmp ax</p><p>同时修改cs和ip，称之为段间转移，比如：jmp 1000:0</p><p>偏移地址（寻址范围）最大ffff，转移指令对IP修改的范围不同，段内转移又分为：短转移和近转移</p><p>短转移修改IP的范围为：-128~127（也就是ff 256）</p><p>近转移修改IP的范围为：-32768~32767（也就是ffff 65536）</p><p>转移指令分为以下几类：</p><ul><li>无条件转移指令（如jmp）</li><li>条件转移指令（可以帮助我们做一些类似c语言中的if操作）</li><li>循环转移指令（如：loop）</li><li>中断（后面会学）</li></ul><p>依据位移进行转移的jmp指令，jmp short 标号 （实现段内短转移），short指明的是进行短转移，标号指明要转移的目的地，转移结束后，CS:IP应该指向标号处的指令，范围是8位（-128~127），ip+8位位移</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codecode <span class="hljs-meta">segment</span><span class="hljs-symbol">start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">123h</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><span class="hljs-keyword">jmp</span> short s<span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">1</span><span class="hljs-symbol">s:</span><span class="hljs-keyword">inc</span> <span class="hljs-built_in">ax</span>code endsend start</code></pre></div><p>调式上述代码，有如下疑惑 ？</p><img src="/2022/08/20/22-0820-05/image-20220904112838381.png" class="" title="image-20220904112838381"><p>正常的CPU执行指令的过程如下：</p><ol><li>从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器</li><li>IP+读取到的指令长度，指向下一条指令</li><li>执行指令缓冲器中的指令</li></ol><p>对于上述代码，则过程如下：</p><ol><li>当执行到jmp指令时候，也就是cs:ip &#x3D; 076a:0006 时，对应机器码为EB03</li><li>读取指令EB03进入指令缓冲器</li><li>IP+2&#x3D;<code>0008H</code>（EB03的长度为2），cs:ip指向076a:0008，也就是指向add ax,1</li><li>执行缓冲区指令EB<code>03</code></li><li>然后执行EB03后，进行跳转，跳转到000B，cs:ip指向inc ax（注意：这里的000B实际就是<code>0008+03</code>，EB03就是告诉CPU要转移的位移，当然这里就是转移3）</li></ol><p>jmp near ptr 标号，实现段内近转移，范围是16位（-32768~32767），ip+16位位移</p><p>jmp far ptr 标号，实现段间转移，又称为远转移。cs&#x3D;标号所在段的段地址，ip&#x3D;标号所在段的偏移地址，far ptr 指明了指令用标号的段地址和偏移地址修改cs和ip</p>]]></content>
    
    
    <categories>
      
      <category>16位汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编Day4</title>
    <link href="/2022/08/20/22-0820-04/"/>
    <url>/2022/08/20/22-0820-04/</url>
    
    <content type="html"><![CDATA[<h1 id="AND和OR指令"><a href="#AND和OR指令" class="headerlink" title="AND和OR指令"></a>AND和OR指令</h1><p>and：逻辑与，按位进行与运算，两个1才为1，不然为0</p><p>or：逻辑或指令，按位进行计算，有一个1就为1，不然为0</p><h1 id="字符串定义"><a href="#字符串定义" class="headerlink" title="字符串定义"></a>字符串定义</h1><div class="code-wrapper"><pre><code class="hljs livecodeserver">assume cs:code<span class="hljs-keyword">string</span> <span class="hljs-keyword">segment</span>db <span class="hljs-string">&#x27;ayu&#x27;</span><span class="hljs-keyword">string</span> <span class="hljs-keyword">ends</span>code <span class="hljs-keyword">segment</span><span class="hljs-built_in">start</span>:mov ax,<span class="hljs-keyword">string</span>code <span class="hljs-keyword">ends</span><span class="hljs-function"><span class="hljs-keyword">end</span> <span class="hljs-title">start</span></span></code></pre></div><p>然后调试</p><img src="/2022/08/20/22-0820-04/image-20220902095749648.png" class="" title="image-20220902095749648"><p><strong>疑惑：</strong><code>db &#39;ayu&#39;</code>，到底存储到代码段cs中，还是数据段ds中呢 ？（理论肯定是存在数据段ds中的）</p><p>这里采用mov ax,string来测试，发现mov ax,string就是mov ax,076a，所以显然<code>db &#39;ayu&#39;</code>被存放到了076a，根据上图中ds的起始地址为075a，而cs的起始地址为076b，所以经过分析<code>db &#39;ayu&#39;</code>确实被放到了数据段中</p><h1 id="PSP区"><a href="#PSP区" class="headerlink" title="PSP区"></a>PSP区</h1><p>程序加载后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为0，则程序所在的内存区的地址为  ds:0，这个内存区的前256个字节（256对应16进制0100）中存放的是PSP，DOS用来和程序进行通信。从256字节处向后的空间存放的是程序。</p><img src="/2022/08/20/22-0820-04/image-20220902102015177.png" class="" title="image-20220902102015177"><p>注意：上图中为啥不写SA+0100H呢？？？？而是用的SA+10H呢？？？</p><p>正常来说应该是<code>SA+0100H:0</code>那么对应实际物理地址就是<code>SA*16+256 = SA*16+16*16 = 16(SA+16) = 16(DS+16)   </code> (实际地址 &#x3D; 段地址*16+偏移地址，这里的段地址和偏移地址换算成10进制运算)。而真正CS:IP对应的实际物理地址为<code>CS*16+IP</code>，而偏移地址IP开始为0，也就是<code>CS*16</code>，所以<code>DS+16 = CS</code>，由于这里采用的是10进制运算，16 就是十六进制的10h，所以<code>ds+10h = cs</code></p><p>比如：上面的ds&#x3D;075a，那么psp的内容就是从075a:0到075a+10h:0，也就是075a:0到076a:0，而真正程序是从076a:0开始的，所以我们查看076a:0就可以看到我们定义的数据<code>db &#39;ayu&#39;</code></p><img src="/2022/08/20/22-0820-04/image-20220903160907793.png" class="" title="image-20220903160907793"><p>但是这里076a:0为啥并不是CS:IP？？？？</p><img src="/2022/08/20/22-0820-04/image-20220903160916449.png" class="" title="image-20220903160916449"><p>可能是因为<code>db &#39;ayu&#39;</code>是数据，但是CS寄存器存放的是指令，也就是说CS:IP指向存放指令的地方，而076a到076b这里面存放的是一些数据，就比如：刚才我们定义的段<code>db &#39;ayu&#39;</code>，类似如下图：</p><img src="/2022/08/20/22-0820-04/image-20220903160925092.png" class="" title="image-20220903160925092"><p>现在我们将程序删除string段改成如下：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codecode <span class="hljs-meta">segment</span><span class="hljs-symbol">start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span>code endsend start</code></pre></div><p>重新debug后，如下：恰好DS和CS差10H，那么上面的猜测可能就是正确的</p><img src="/2022/08/20/22-0820-04/image-20220903160955361.png" class="" title="image-20220903160955361"><h1 id="寄存器SI、DI"><a href="#寄存器SI、DI" class="headerlink" title="寄存器SI、DI"></a>寄存器SI、DI</h1><p>si和di功能和bx差不多的用法，但是不能和bx一样分成两个8位的寄存器</p><p>对于bx，经常的用法为：mov bx,0 或者mov bx,[0]，同理对于si、di也可以这样用：mov si,0 或者 mov si,[0]、mov di,0 或者 mov di,[0] 等</p><h1 id="寻址方式总结"><a href="#寻址方式总结" class="headerlink" title="寻址方式总结"></a>寻址方式总结</h1><ul><li>直接寻址，比如：[0]、[1] </li><li>寄存器间接寻址，比如：[bx]、[si]、[di]、[bp]</li><li>寄存器相对寻址，比如：[bx+1]、[si+2] 等</li><li>基址加变址寻址，比如：[bx+si]、[bx+di]等</li><li>相对基址加变址寻址，比如：[bx+si+1]、[bx+di+2]</li></ul><div class="code-wrapper"><pre><code class="hljs x86asm">作业:<span class="hljs-comment">;将naizi、madou、caiji、linhu首字母变成大写</span><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code,<span class="hljs-built_in">ds</span>:datadata <span class="hljs-meta">segment</span><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;1. naizi........&#x27;</span><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;2. madou........&#x27;</span><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;3. caiji........&#x27;</span><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;4. linhu........&#x27;</span>data endscode <span class="hljs-meta">segment</span><span class="hljs-symbol">start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,data<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">0</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">4</span><span class="hljs-symbol">s:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[<span class="hljs-built_in">di</span>+<span class="hljs-number">3</span>]<span class="hljs-keyword">and</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">11011111B</span>  <span class="hljs-comment">;将首字母变成大写</span><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">di</span>+<span class="hljs-number">3</span>],<span class="hljs-built_in">al</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">16</span><span class="hljs-keyword">loop</span> s:<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span>code endsend start用两个循环实现把所有字母变成大写<span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code,<span class="hljs-built_in">ds</span>:datadata <span class="hljs-meta">segment</span><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;naizi...........&#x27;</span><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;madou...........&#x27;</span><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;caiji...........&#x27;</span><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;linhu...........&#x27;</span>data endsstack <span class="hljs-meta">segment</span><span class="hljs-built_in">dw</span> <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>  <span class="hljs-comment">;设置栈用于存放cx</span>code <span class="hljs-meta">segment</span><span class="hljs-symbol">start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,stack<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>,<span class="hljs-number">16</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,data<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">4</span><span class="hljs-symbol"></span><span class="hljs-symbol">s0:</span><span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">5</span><span class="hljs-symbol"></span><span class="hljs-symbol">s:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[<span class="hljs-built_in">bx</span>+<span class="hljs-built_in">si</span>]<span class="hljs-keyword">and</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">11011111b</span><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-built_in">si</span>],<span class="hljs-built_in">al</span><span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><span class="hljs-keyword">loop</span> s<span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">16</span><span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><span class="hljs-keyword">loop</span> s0<span class="hljs-keyword">loop</span> s<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>code endsend start</code></pre></div><h1 id="ptr"><a href="#ptr" class="headerlink" title="ptr"></a>ptr</h1><p>下面的指令中，寄存器指明了指令进行的是字操作：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">1</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>]     <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>],<span class="hljs-built_in">ax</span><span class="hljs-keyword">inc</span> <span class="hljs-built_in">ax</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">1000</span></code></pre></div><p>下面的指令中，寄存器指明了指令进行的是字节操作（因为是al）：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">1</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">bl</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>],<span class="hljs-built_in">al</span><span class="hljs-keyword">inc</span> <span class="hljs-built_in">al</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">100</span></code></pre></div><p>在没有寄存器名存在的情况下，既都是在内存，得用操作符 X ptr 指明内存单元的长度，X在汇编指令中可以为byte，word或者DWORD。要不然内存是片连续的区域，操作就乱了</p><p>例如：</p><p>下面的指令中，用word ptr 指明了指令访问的内存单元是一个字单元：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>],<span class="hljs-number">1</span><span class="hljs-keyword">inc</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>]<span class="hljs-keyword">inc</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>]<span class="hljs-keyword">add</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>],<span class="hljs-number">2</span></code></pre></div><p>下面的指令中，用byte ptr 指明了指令访问的内存单元是一个字节单元：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>],<span class="hljs-number">1</span><span class="hljs-keyword">inc</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>]<span class="hljs-keyword">inc</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>]<span class="hljs-keyword">add</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>],<span class="hljs-number">2</span></code></pre></div><p>在没有寄存器参与的内存单元访问指令中，用word prt 或byte ptr 显性地指明所要访问的内存单元的长度是很必要的。否则，CPU无法得知所要访问的单元，还是字节单元。假如我们用Debug查看内存的结果如下：</p><p>2000：1000 FF FF FF FF FF FF ……</p><p>那么指令：<br>mov ax,2000H<br>mov ds,ax<br>mov byte ptr [1000H],1<br>将使内存中的内容变为：<br>2000: 1000 01 FF FF FF FF FF ……</p><p>而指令：<br>mov ax,2000H<br>mov ds,ax<br>mov word ptr [1000H],1<br>将使内存中的内容变为：<br>2000：1000 01 00 FF FF FF FF ……</p><h1 id="综合应用"><a href="#综合应用" class="headerlink" title="综合应用"></a>综合应用</h1><div class="code-wrapper"><pre><code class="hljs autoit">关于公司的一条记录如下：公司名称：<span class="hljs-built_in">DEC</span>公司姓名：naizi排名：<span class="hljs-number">250</span>收入：<span class="hljs-number">20</span>著名产品：pos</code></pre></div><img src="/2022/08/20/22-0820-04/image-20220903162344655.png" class="" title="image-20220903162344655"><p>现在进行如下操作：<br>修改排名为100<br>收入为50<br>产品变成amd</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">seg</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">60h</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">8</span>],<span class="hljs-number">100</span>  <span class="hljs-comment">;该指令也可写成mov word ptr [bx].8,100 </span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">10</span>],<span class="hljs-number">50</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">12</span>+<span class="hljs-built_in">si</span>],<span class="hljs-string">&#x27;A&#x27;</span> <span class="hljs-comment">;该指令也可写成mov byte ptr [bx][si].12,&#x27;A&#x27; 或写成mov byte ptr [bx].12[si],&#x27;A&#x27;</span><span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">12</span>+<span class="hljs-built_in">si</span>],<span class="hljs-string">&#x27;M&#x27;</span><span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">12</span>+<span class="hljs-built_in">si</span>],<span class="hljs-string">&#x27;D&#x27;</span></code></pre></div><h1 id="div除法指令"><a href="#div除法指令" class="headerlink" title="div除法指令"></a>div除法指令</h1><p>除法：有8位和16位两种，在一个寄存器或者内存单元中</p><p>被除数：如果除数为8位，被除数为16位，默认放在ax中，如果除数为16位，被除数一定为32位，在dx和ax中存放，dx存放高16位，ax存放低16位（注意：被除数一定比除数值大，除数是16位，则被除数一定是32位）</p><p>结果存放：如果除数为8位，则AL存放除法操作的商，AH存放除法操作的余数；如果除数是16位，则AX存放除法的商，DX存放余数</p><p>div byte ptr ds:[0] 的含义：由于在这里div后面是byte字节，也就是除数是8位，那么被除数一定为16位，AL存放ax÷(ds×16+0) 的商，AH存放ax÷(ds×16+0)的余数</p><p>div word ptr ds:[0] 的含义：由于在这里div后面是word字，也就是除数为16位，那么被除数一定为32位，AX存放的是 (dx×10000H+ax)÷(ds×16+0)的商，DX存放的是 (dx×10000H+ax)÷(ds×16+0)的余数</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-comment">;计算100001/100</span><span class="hljs-comment">;100001大于65535，所以用ax加dx两个寄存器联合存放，100001转化成16进制为186A1H</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,<span class="hljs-number">1</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">86A1H</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">100</span><span class="hljs-keyword">div</span> <span class="hljs-built_in">bx</span><span class="hljs-comment">;ax=商，dx=余数</span></code></pre></div><h1 id="伪指令-db-、dw-、dd"><a href="#伪指令-db-、dw-、dd" class="headerlink" title="伪指令 db 、dw 、dd"></a>伪指令 db 、dw 、dd</h1><p>dd 定义两个字型数据：double word</p><p>dup指令：进行数据重复</p><p>db 3 dup(0) 相当于 db 0,0,0</p><p>db 3 dup(0,1,2) 相当于 db 0,1,2,0,1,2,0,1,2</p>]]></content>
    
    
    <categories>
      
      <category>16位汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编Day3</title>
    <link href="/2022/08/20/22-0820-03/"/>
    <url>/2022/08/20/22-0820-03/</url>
    
    <content type="html"><![CDATA[<h1 id="bx-、loop指令"><a href="#bx-、loop指令" class="headerlink" title="[bx]、loop指令"></a>[bx]、loop指令</h1><h2 id="bx"><a href="#bx" class="headerlink" title="[bx]"></a>[bx]</h2><p>前面day2天学习中，我们了解到了[0]的用法，如下：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">1000H</span> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">bx</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[<span class="hljs-number">0</span>]</code></pre></div><p>但这里中括号中的0是常量，我们还可放变量，比如：[bx]</p><div class="code-wrapper"><pre><code class="hljs X86ASM"><span class="hljs-comment">;如果ds已经是2000H</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">10</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,[<span class="hljs-built_in">bx</span>]<span class="hljs-comment">;这个指令就相当于mov ax,2000H:10,也就是把2000H:10这个字型数据给ax</span><span class="hljs-comment">;如果是mov dl,[0]，那么这个是把字节型数据给mov，因为dl只有8位</span></code></pre></div><p>inx bx 指令的作用是让bx+1，相当于bx&#x3D;bx+1或者是bx++</p><h2 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h2><p>loop 指令，在汇编里面代表循环，类似于c语言的while、for循环。</p><p>loop 指令的使用格式：<code>loop 标号</code>，CPU 执行 loop 指令时，首先执行 CX &#x3D; CX-1，然后判断 CX 的值，CX的值如果不为0，就会跳到标号处执行程序，如果为0，就按顺序向下执行。</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-comment">;比如：如果要用指令实现2的三次方，可用如下方法</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">2</span><span class="hljs-comment">;ax=2</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">ax</span><span class="hljs-comment">;ax=2+2=4  </span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">ax</span><span class="hljs-comment">;ax=4+4=8</span><span class="hljs-comment">;但是这里如果要实现2的12次方呢？？？用上面的方法一直加下去就不太好，这里就用循环实现，用如下代码实现</span><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codecode <span class="hljs-meta">segment</span>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">2</span>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">11</span>    <span class="hljs-symbol"></span><span class="hljs-symbol">s:</span>  <span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">ax</span>    <span class="hljs-keyword">loop</span> s            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span>    <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span>code endsend</code></pre></div><p>对上面2的12次方debug下，-u后我们发现ayu.exe会先执行mov ax,0002，然后再执行mov cx,000B，一直向下执行下去，然后到loop指令的时候，会再跳回到上面的add ax,ax指令</p><img src="/2022/08/20/22-0820-03/image-20220830212722071.png" class="" title="image-20220830212722071"><p>然后我们可以-t来一条条的指令看下</p><img src="/2022/08/20/22-0820-03/image-20220830212728134.png" class="" title="image-20220830212728134"><p>注意，上面的第二条指令<code>mov cx,000B</code>，这里000B实际就是十进制的11，也就是源程序中的<code>mov cx,11</code>，当然mov cx,11也可以写成<code>mov cx,0BH</code>，这里必须是0BH，不能写成BH，在汇编中数据不能以字母开头，所以在前面加个0</p><img src="/2022/08/20/22-0820-03/image-20220830212735344.png" class="" title="image-20220830212735344"><p>cx存放的是程序（机器码）长度（字节数），一共15个字节，也就是十六进制的F</p><img src="/2022/08/20/22-0820-03/image-20220830212744246.png" class="" title="image-20220830212744246"><div class="code-wrapper"><pre><code class="hljs txt">作业:编程，用加法计算123*236,结果存在ax中123*236就是236个123相乘，即123×123×123×123...代码如下：code segmentmov ax,123mov cx,236s:add ax,axloop smov ax,4c00hint 21hcode endsend</code></pre></div><h1 id="Debug和汇编编译器处理指令的区别"><a href="#Debug和汇编编译器处理指令的区别" class="headerlink" title="Debug和汇编编译器处理指令的区别"></a>Debug和汇编编译器处理指令的区别</h1><p>用debug输入如下指令</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">2000h</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[<span class="hljs-number">0</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">bl</span>,[<span class="hljs-number">1</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,[<span class="hljs-number">2</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>,[<span class="hljs-number">3</span>]</code></pre></div><img src="/2022/08/20/22-0820-03/image-20220902093058566.png" class="" title="image-20220902093058566"><p>然后用编译器编译和debug如下程序</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codecode <span class="hljs-meta">segment</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">2000h</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[<span class="hljs-number">0</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">bl</span>,[<span class="hljs-number">1</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,[<span class="hljs-number">2</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>,[<span class="hljs-number">3</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span>code endsend</code></pre></div><img src="/2022/08/20/22-0820-03/image-20220902093112633.png" class="" title="image-20220902093112633"><p>那么，我们如何解决上面的问题呢？？把代码改成如下，添加上段前缀<code>ds:</code>，然后编译器就会把[0]当成地址处理了</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codecode <span class="hljs-meta">segment</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">2000h</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">bl</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-number">1</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-number">2</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-number">3</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span>code endsend</code></pre></div><p>或者用类似如下的形式也可以mov al,<code>[bx]</code>，中括号里面为变量，而不是常量0，如果要用ss段寄存器，那么前面必须有<code>ss:</code>[bx]，而默认中括号前啥都没有就是ds寄存器</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codecode <span class="hljs-meta">segment</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">2000h</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[<span class="hljs-built_in">bx</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">ss</span>:[<span class="hljs-built_in">bx</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span>code endsend</code></pre></div><p>注意：我们以后写代码用200:2FF这段空间，这个空间是没有用的，向别的内存空间中写入可能直接会导致死机或者其他的事情。。。</p><img src="/2022/08/20/22-0820-03/image-20220902093157911.png" class="" title="image-20220902093157911"><div class="code-wrapper"><pre><code class="hljs txt">作业:将内存ffff:0到fff:c的单元中的数据复制到0:200到0:20c单元中，注意：0:200到0:20c等价于0020:0到0020:c，因为合成后物理地址都一样assume cs:codecode segmentmov bx,0mov cx,0CHs:mov ax,0ffffhmov ds,axmov dx,[bx]mov ax,0020hmov ds,axmov [bx],dxadd bx,2loop smov ax,4c00hint 21hcode endsend;除了上述方法，还可以用es这个段地址寄存器来实现assume cs:codecode segmentmov bx,0mov cx,0CHmov ax,0ffffhmov ds,axmov ax,0020hmov es,axs:mov dx,[bx]mov es:[bx],dx   ;es不可省略，分号是汇编的注释符号add bx,2loop smov ax,4c00hint 21hcode endsend</code></pre></div><p>上面的程序中是只有一个段的<code>code segment</code>，也就是代码段，但是有的包含多个段，比如，同时包含代码段和数据段，那么数据段肯定要在内存中占用一定的空间，操作系统就会给数据段分配一定的空间，注意：操作系统给程序分配的空间都是安全的，因为操作系统不会让一个程序所用空间和其他程序或操作系统自己空间相冲突</p><p>程序获取所需要的空间有2种方法：</p><ol><li>加载程序的时候为程序分配内存</li><li>在程序执行过程中向系统申请（c语言的malloc）</li></ol><h1 id="Start用法"><a href="#Start用法" class="headerlink" title="Start用法"></a>Start用法</h1><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codecode <span class="hljs-meta">segment</span><span class="hljs-built_in">dw</span> <span class="hljs-number">123h</span>,<span class="hljs-number">0456h</span>,<span class="hljs-number">0abch</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0ffffh</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span> code endsend</code></pre></div><p>编译，调试上面的程序，我们发现并不是从mov ax,0ffffh开始执行的，如果想从正常从mov ax,0ffffh开始执行的话，需要加上start</p><img src="/2022/08/20/22-0820-03/image-20220902094335774.png" class="" title="image-20220902094335774"><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codecode <span class="hljs-meta">segment</span><span class="hljs-built_in">dw</span> <span class="hljs-number">123h</span>,<span class="hljs-number">0456h</span>,<span class="hljs-number">0abch</span> <span class="hljs-comment">;定义字型数据，数据之间有逗号隔开</span><span class="hljs-symbol">start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0ffffh</span>  <span class="hljs-comment">;这里的start可以定义成任意名称</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span> code endsend start</code></pre></div><p>重新编译，调试，就是从mov ax,0ffffh正常开始执行了，并且我们发现cs:ip变成了076A:0006，偏移地址ip变成了0006，恰好我们定义了三个字型数据，也就是6个字节</p><img src="/2022/08/20/22-0820-03/image-20220902094608872.png" class="" title="image-20220902094608872"><p>查看076a:0的地址内容，就发现了我们的字型数据</p><img src="/2022/08/20/22-0820-03/image-20220902094810500.png" class="" title="image-20220902094810500"><h1 id="定义栈段"><a href="#定义栈段" class="headerlink" title="定义栈段"></a>定义栈段</h1><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code,<span class="hljs-built_in">ds</span>:data,<span class="hljs-built_in">ss</span>:stackdata <span class="hljs-meta">segment</span><span class="hljs-built_in">dw</span> <span class="hljs-number">0123h</span>,<span class="hljs-number">0456h</span>data endsstack <span class="hljs-meta">segment</span><span class="hljs-built_in">dw</span> <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>  <span class="hljs-comment">;栈的内存空间</span>stack endscode <span class="hljs-meta">segment</span><span class="hljs-symbol">start:</span>     <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,data<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,stack<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>,<span class="hljs-number">10h</span>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span>    <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span>code endsend start</code></pre></div><div class="code-wrapper"><pre><code class="hljs txt">课后作业：1.编程向内存0:200~0:23F依次传送数据0~63(3FH) 备注：只能使用9条指令 包括mov ax,4c00h int 21h解答：assume cs:codecode segmentmov cx,3Fhmov ax,0mov ds,axmov bx,0s:mov [bx+200],blinc blloop smov ax,4C00hint 21hcode endsend2. 下面程序的功能是将&quot;mov ax,4c00h&quot;之前的指令复制到内存0:200处，补全程序用debug调试，跟踪运行结果assume cs:codecode segment    mov ax,__cs___ ;注意复制的是指令，指令在cs寄存器中    mov ds,ax    mov ax,0020h  ;注意：0:0200等价于0020:0，合成后物理地址一样    mov es,ax    mov bx,0    mov cx,__17h__ ;这里为啥是17h，看下面解析s:  mov al,[bx]    mov es:[bx],al    inc bx    loop s        mov ax,4c00h    int 21hcode endsend  3.编写code段中的代码，将naizi段和madou段中的数据依次相加，将结果存到feiwudidi段assume cs:codenaizi segment db 1,2,3,4,5,6,7,8naizi endsmadou segment db 1,2,3,4,5,6,7,8madou endsfeiwudidi segment db 0,0,0,0,0,0,0,0feiwudidi endscode segmentstart:   ?code endsend start解答：assume cs:codenaizi segment db 1,2,3,4,5,6,7,8naizi endsmadou segment db 1,2,3,4,5,6,7,8madou endsfeiwudidi segment db 0,0,0,0,0,0,0,0feiwudidi endscode segmentstart:mov ax,feiwudidimov es,axmov bx,0mov cx,8s:mov ax,naizimov ds,axmov dl,[bx]mov ax,madoumov ds,axadd dl,[bx]mov es:[bx],dlinc bxloop scode endsend start4.编写code段中的代码，用push指令将a段中的前8个字型数据逆序存储到b段中assume cs:codea segment    dw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fha endsb segment    dw 0,0,0,0,0,0,0,0b endscode segment    start: ?code endsend start解答：assume cs:codea segment    dw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fha endsb segment    dw 0,0,0,0,0,0,0,0b endscode segment    start:mov ax,b    mov ss,ax ;设置栈    mov sp,16 ;设置栈偏移地址 ;10进制的16        mov ax,a    mov ds,ax    mov bx,0        mov cx,8  ;控制循环次数    s:push [bx]  ;入栈    add bx,2    loop s            code endsend start</code></pre></div><p>第2题解析：</p><img src="/2022/08/20/22-0820-03/image-20220902094927400.png" class="" title="image-20220902094927400">]]></content>
    
    
    <categories>
      
      <category>16位汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编day2</title>
    <link href="/2022/08/20/22-0820-02/"/>
    <url>/2022/08/20/22-0820-02/</url>
    
    <content type="html"><![CDATA[<h1 id="内存中字节的存储方式"><a href="#内存中字节的存储方式" class="headerlink" title="内存中字节的存储方式"></a>内存中字节的存储方式</h1><p>8086 CPU是用16位寄存器来存储一个字，内存单元是以字节划分的，如下：0,1,2,3， 0,1两个内存单元存放的就是4E20H</p><img src="/2022/08/20/22-0820-02/image-20220830202004406.png" class="" title="image-20220830202004406"><h1 id="DS段寄存器和-address"><a href="#DS段寄存器和-address" class="headerlink" title="DS段寄存器和[address]"></a>DS段寄存器和[address]</h1><p>在CPU要读写内存单元的时候，我们必须得给出内存单元的地址才行呀，那么在8086 CPU里，内存地址由段地址+偏移地址组成，里面有一个DS的段寄存器来存放段地址</p><p>比如：我们这里要读取10000H内存单元的内容，如下：</p><div class="code-wrapper"><pre><code class="hljs X86ASM"><span class="hljs-keyword">mov</span>  <span class="hljs-built_in">bx</span>,<span class="hljs-number">1000H</span>   <span class="hljs-comment">;将1000H给bx通用寄存器</span><span class="hljs-keyword">mov</span>  <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">bx</span>      <span class="hljs-comment">;将bx的值赋值给ds段寄存器，也就是此时段寄存器存放着1000H</span><span class="hljs-keyword">mov</span>  <span class="hljs-built_in">al</span>,[<span class="hljs-number">0</span>]     <span class="hljs-comment">;注意：因为cpu读取数据时要知道段地址+偏移地址的，ds:[0] == 段地址:偏移地址，而中括号里面的0表示的就是偏移地址，中括号表示的是内存单元，上面读取10000H，如果要读取10001H，那么偏移1即可</span></code></pre></div><p>通过上面的三个指令，就可以让al寄存器读取到10000H内存单元的数据，但是如何反过来让寄存器的值赋值到内存单元？？？？通过<code>mov  内存单元地址:寄存器</code>  即可</p><p>注意：这里一定不能把1000H直接赋值给ds段寄存器，而是通过另一个寄存器bx间接将1000H赋值给段寄存器</p><h1 id="代码段和数据段"><a href="#代码段和数据段" class="headerlink" title="代码段和数据段"></a>代码段和数据段</h1><p>我们可以将<code>一段内存定义为一个段</code>。用一个段地址指示段，用偏移地址访问段内的单元。这完全是我们自己可以决定的。</p><p>代码段：用来存放代码（通过用来存放程序执行的指令），段的基地址放在寄存器 CS 中，指令指针寄存器 IP 用来表示下一条指令在段中的偏移地址</p><p>数据段：用来存放程序处理的数据（通常用来存放程序中已初始化的（非 0）全局变量和静态局部变量），段的基地址存放在寄存器 DS 中。对数据段中的某个数据进行操作时，直接在汇编代码中通过立即数或寄存器来指定偏移地址</p><div class="code-wrapper"><pre><code class="hljs x86asm">作业:写几条指令，累加数据段中的前<span class="hljs-number">3</span>个字型数据，段地址为<span class="hljs-number">123BH</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span>   <span class="hljs-comment">;先把ax的数据置空</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">123BH</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,[<span class="hljs-number">0</span>]   <span class="hljs-comment">;也可以写成add ax,ds:[0]</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,[<span class="hljs-number">2</span>] <span class="hljs-comment">;这里为啥是2呢，因为这里是“字”型数据，所以为16位，也就2个存储单元（2个字节），所以每次增加2</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,[<span class="hljs-number">4</span>]</code></pre></div><p>作业解析：</p><img src="/2022/08/20/22-0820-02/image-20220830203705980.png" class="" title="image-20220830203705980"><p><code>add ax,[0]</code>也就是把3412这个数据给ax，然后<code>add ax,[2]</code>把7856这个数据给ax，<code>add ax,[4]</code>把6622这个数据给ax，这样就累加了前3个字型数据</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈是特殊的访问方式的存储结构，CPU都有栈的设计，CPU提供相关指令以栈的方式读取内存空间，我们编程的时候可以将一段内存当作栈来使用，栈可以用于存储临时数据。</p><p>栈的结构如下：</p><img src="/2022/08/20/22-0820-02/image-20220830203831861.png" class="" title="image-20220830203831861"><p>栈有点类似于杯子，如果以a、b、c进栈，然后出栈的时候就是c、b、a，同时始终有一个标记指向栈顶，如果c出栈之后，那么标记就指向b</p><h2 id="入栈、出栈"><a href="#入栈、出栈" class="headerlink" title="入栈、出栈"></a>入栈、出栈</h2><p>有两条指令可以操作栈，PUSH（入栈）、POP（出栈），入栈和出栈都是以<code>字</code>为单位</p><p>如：比如：<code>push ax</code>就是将ax的值放入栈，<code>pop ax</code>将栈顶的值出栈放入ax</p><p><strong>栈中数据的存放位置</strong></p><p>比如ax&#x3D;1000H，然后我们 push ax，把ax的值压栈，注意：这里最下面是高地址，所以存放1000H时候，下面10，上面是00。然后让ax&#x3D;2000H，再次 push ax 压栈，如下：</p><img src="/2022/08/20/22-0820-02/image-20220830204440835.png" class="" title="image-20220830204440835"><p>现在，我们要取出ax的值1000H，是不是只要执行pop ax 即可呢？？肯定不是，如果我们pop ax的话取出的值实际是2000H，pop指令肯本不知道ax是啥东西，只会取出栈顶的数据，那么我们如何取出ax的值呢？？？</p><p>可以先pop取出2000H，然后放到bx寄存器中，然后再取出1000H即可</p><h2 id="SS、SP寄存器"><a href="#SS、SP寄存器" class="headerlink" title="SS、SP寄存器"></a>SS、SP寄存器</h2><p>上面了解了栈，虽然在内存中是可以方便的定义一个栈了，但是，我们为什么要定义这么一个栈呢？自然，是为了操作方便，同时提供给 CPU 使用的，既然 CPU 要使用的话，自然，CPU 又必须根据一定的方式找到这个栈，而这就需要使用 SS 和 SP 寄存器了 </p><p>栈顶的段地址存放在 SS 中，偏移地址在 SP 中，<code>任意时刻</code>，SS:SP就可以知道栈顶在哪里</p><p>如下：栈顶就是073F:00FD</p><img src="/2022/08/20/22-0820-02/image-20220830205442039.png" class="" title="image-20220830205442039"><p>再举个栗子，如下是内存中的栈</p><p>执行AX &#x3D; 1122H，然后 PUSAH AX，执行后如下图，这里的栈顶SS:SP为1000H:000EH，那么这个栈顶是看出来的呀？因为SS是栈段地址，SP是栈的偏移地址，由于段地址×16+偏移地址就是实际的物理地址，而物理地址为1000EH，所以拆解1000EH即可得到SS为1000H，而SP为000EH</p><img src="/2022/08/20/22-0820-02/image-20220830205523642.png" class="" title="image-20220830205523642"><p>然后再次压栈，bx &#x3D; 6677H，push bx，执行压栈后，SP的值发生变化，sp &#x3D; sp-2，原本sp&#x3D;000EH，减2后，sp&#x3D;000C。而这里段地址SS肯定是不发生变化的，那么SS:SP &#x3D; 1000H:000CH，如下图：</p><img src="/2022/08/20/22-0820-02/image-20220830205647442.png" class="" title="image-20220830205647442"><p>然后执行出栈操作，pop ax，注意：这里pop出ax的值为6677H，然后再执行SP &#x3D; SP + 2，执行后sp的值由000CH变成000EH，如下图 ：</p><img src="/2022/08/20/22-0820-02/image-20220830205654587.png" class="" title="image-20220830205654587"><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">作业:</span>将10000H-1000FH这段空间当作栈，初始状态栈是空的，此时SS=1000H，SP=？？ （特别注意）0010H</code></pre></div><p>解析：</p><p>如下图，栈是空的</p><img src="/2022/08/20/22-0820-02/image-20220830205826726.png" class="" title="image-20220830205826726"><p>如果这里我们压入数据 1122H，这里那么毫无疑问，如下图：</p><img src="/2022/08/20/22-0820-02/image-20220830205835841.png" class="" title="image-20220830205835841"><p>但是这里问题是没有任何数据，那么我们直接把刚才写入的数据出栈即可，sp由000EH减2，如下图：</p><img src="/2022/08/20/22-0820-02/image-20220830205845476.png" class="" title="image-20220830205845476"><p>最终得到SP&#x3D;0010H</p><h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><p>如果栈内存大小就是4个字节，那么我们向里面压入数据，1122H、3344H，如下，已经放满了数据了</p><img src="/2022/08/20/22-0820-02/image-20220830205956602.png" class="" title="image-20220830205956602"><p>但是如果我们持续push压入数据的话，那么就会覆盖掉其它的数据，如下，并且如果压入的指令的话，并且把指令压入了CS:IP指向的内存空间，而8086 cpu任意时刻都会从CS:IP指向的内存中读取指令，那么程序就直接执行我们压入的指令了</p><img src="/2022/08/20/22-0820-02/image-20220830210005867.png" class="" title="image-20220830210005867"><p>pop可能造成栈顶越界，栈顶到了其它的内存空间</p><img src="/2022/08/20/22-0820-02/image-20220830210014390.png" class="" title="image-20220830210014390"><p>为了防止上面的溢出或者越界，CPU最好能够记录栈顶的上限和下限在哪里，这样一直pop就不越界，但这里学习的16位cpu没有该功能，32位的是有这个功能的。（金丝雀保护机制，后续再学习）</p><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">作业:</span>补齐下面程序，使他可以将10000H-1000FH中的8个字，逆序复制到20000H-2000FH中mov ax,2000hmov ds,ax- - -在此处补充指令- - - pop [E]pop [C]pop [A]pop [8]pop [6]pop [4]pop [2]pop [0]<span class="hljs-section">解答:</span>mov ax,2000hmov ds,ax- - - mov bx,1000h  mov ss,bx  //设置栈顶SSmov sp,0   //设置栈顶SP- - -pop [E]  //出栈把值放到内存地址中，这里的内存地址前面mov ax,2000h、mov ds,ax设置好了段地址2000h，[E]即偏移地址，两个一合成，段地址2000h×16+偏移地址000E得到内存中物理地址2000EHpop [C]  pop [A]pop [8]pop [6]pop [4]pop [2]pop [0]</code></pre></div><h2 id="对栈的分析"><a href="#对栈的分析" class="headerlink" title="对栈的分析"></a>对栈的分析</h2><p>向2000:0写入11,22,33,44,55,66</p><img src="/2022/08/20/22-0820-02/image-20220830210632162.png" class="" title="image-20220830210632162"><p>然后把ss:sp设置成2000:0</p><img src="/2022/08/20/22-0820-02/image-20220830210639111.png" class="" title="image-20220830210639111"><p>设置后，类似如下：</p><img src="/2022/08/20/22-0820-02/image-20220830210646646.png" class="" title="image-20220830210646646"><h3 id="POP出栈分析"><a href="#POP出栈分析" class="headerlink" title="POP出栈分析"></a>POP出栈分析</h3><p>然后-a设置来执行pop ax指令</p><img src="/2022/08/20/22-0820-02/image-20220830210708912.png" class="" title="image-20220830210708912"><p>-t执行后，sp的值加了2，并且ax的值变成了2211</p><img src="/2022/08/20/22-0820-02/image-20220830210716264.png" class="" title="image-20220830210716264"><p>pop出栈后，我们再次查看2000:0这里的数据，发现了11,22已经出栈了</p><img src="/2022/08/20/22-0820-02/image-20220830210723248.png" class="" title="image-20220830210723248"><p>然后再次执行pop ax操作，ax的值变成了4433，并且原本的33,44也已经出栈了</p><img src="/2022/08/20/22-0820-02/image-20220830210730955.png" class="" title="image-20220830210730955"><h3 id="PUSH入栈分析"><a href="#PUSH入栈分析" class="headerlink" title="PUSH入栈分析"></a>PUSH入栈分析</h3><p>同样2000:0处数据如下：</p><img src="/2022/08/20/22-0820-02/image-20220830210933972.png" class="" title="image-20220830210933972"><p>然后把ss:sp改成2000:4，图解如下:</p><img src="/2022/08/20/22-0820-02/image-20220830210941315.png" class="" title="image-20220830210941315"><p>然后把ax的值改成0000，并且push ax的值，然后sp的值由4变成了2</p><img src="/2022/08/20/22-0820-02/image-20220830210947907.png" class="" title="image-20220830210947907"><p>同时我们查看d2000:0的数据</p><img src="/2022/08/20/22-0820-02/image-20220830210954995.png" class="" title="image-20220830210954995"><p>压入ax的值0000后，如下：</p><img src="/2022/08/20/22-0820-02/image-20220830211001586.png" class="" title="image-20220830211001586"><p>然后再次压入ax的值0000</p><img src="/2022/08/20/22-0820-02/image-20220830211008964.png" class="" title="image-20220830211008964"><p>图解如下：</p><img src="/2022/08/20/22-0820-02/image-20220830211016110.png" class="" title="image-20220830211016110"><p>在这里压栈要注意下，经常容易有个误区：</p><p>当sp为4时，如果mov ax,0，然后push ax的话，之前一直以为压入栈内的0在如下位置，实际并不是。这里可以结合上面的作业题（当栈为空的时候，求解sp的值）多加理解</p><img src="/2022/08/20/22-0820-02/image-20220830211027991.png" class="" title="image-20220830211027991"><h1 id="汇编源程序执行过程"><a href="#汇编源程序执行过程" class="headerlink" title="汇编源程序执行过程"></a>汇编源程序执行过程</h1><ol><li>文本编辑汇编代码</li><li>使用汇编语言编译程序对源程序进行编译生成目标文件</li><li>再用连接程序对目标文件进行连接，生成可在操作系统中直接运行的可执行文件</li></ol>]]></content>
    
    
    <categories>
      
      <category>16位汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编Day1</title>
    <link href="/2022/08/20/22-0820-01/"/>
    <url>/2022/08/20/22-0820-01/</url>
    
    <content type="html"><![CDATA[<h1 id="进制基础"><a href="#进制基础" class="headerlink" title="进制基础"></a>进制基础</h1><ul><li>bit（比特） &#x3D; 一个bit是一个0或1，叫做一个二进制位</li><li>byte（字节）&#x3D;  1byte 是 8 个比特</li><li>16进制 &#x3D; 4个2进制</li></ul><h1 id="汇编语言组成"><a href="#汇编语言组成" class="headerlink" title="汇编语言组成"></a>汇编语言组成</h1><ul><li>汇编指令：由CPU执行，是机器码的助记符，有对应的机器码</li><li>伪指令：由编译器执行，没有对应的机器码，计算机不执行</li><li>其它符号：比如：+－*&#x2F; 由编译器识别执行，没有对应机器码</li></ul><h1 id="CPU组成"><a href="#CPU组成" class="headerlink" title="CPU组成"></a>CPU组成</h1><p>一个典型的CPU大概由运算器、控制器、寄存器构成。外部总线实现CPU和主板上其他器件的联系，内部总线实现CPU内部各个部件的链接</p><h1 id="寄存器、存储器、内存的区别"><a href="#寄存器、存储器、内存的区别" class="headerlink" title="寄存器、存储器、内存的区别"></a>寄存器、存储器、内存的区别</h1><ul><li>寄存器：是cpu组成部分，作用是将寄存器内的数据执行算术及逻辑运算，是操作数据的地方（当然也可以存储数据和指令）</li><li>存储器：在cpu外，一般指的是硬盘、U盘等可以在切断电源后保存资料的设备，是存放数据的地方。</li><li>更通俗的解释如下：（参考自知乎）<ul><li>解释一：<ul><li>寄存器就是你的口袋。身上只有那么几个，只装最常用或者马上要用的东西。</li><li>内存就是你的背包。有时候拿点什么放到口袋里，有时候从口袋里拿出点东西放在背包里。</li><li>辅存（外存）就是你家里的抽屉。可以放很多东西，但存取不方便。</li></ul></li><li>解释二：如果把被储存的东西比作能量<ul><li>寄存器就是 ATP，可以随时拿来用，性能高，但数量有限；</li><li>内存就是葡萄糖，性能一般，但是存量可以比较多；</li><li>外存（比如硬盘）就是脂肪，容量可以非常大，性能很差，要先转化为葡萄糖（存进内存），然后转化为 ATP（放到寄存器）才能直接利用（存取）。</li></ul></li><li>解释三：按最简单的数据的存储和操作距离来理解它们的区别：<ul><li>CPU（数据的操作）&lt;- - - &gt;缓存（数据的存储）&lt;- - - &gt;寄存器（指令等存储）&lt;- - -&gt;内存（需要等待的所有数据的存储）&lt;- - -&gt;外部存储器（硬盘、光盘等）</li></ul></li></ul></li></ul><h1 id="8086-CPU"><a href="#8086-CPU" class="headerlink" title="8086 CPU"></a>8086 CPU</h1><p>8086 CPU （Intel 8086 是一个由Intel于1978年所设计的16位微处理器芯片，是x86架构的鼻祖）有14个16位寄存器 AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW，其中AX，BX，CX，DX 这4个通常用来存放一般性数据，被称为通用寄存器</p><p>注意：8086 CPU 的上一代，也就是8086 CPU 的老爸实际是8位的，当然8086是16位的兼容8位的，所以为了兼容上一代的CPU， AX 寄存器（16位）可以分为两个<code>独立</code>的8位寄存器 AH，AL。同理，BX可分为BH、BL。CX分为CH、CL。DX分为DH、DL。</p><p>8086 cpu可以一次处理2种尺寸数据：<code>字节(byte)和字(word) ，一个字等于两个字节</code></p><h1 id="简单汇编指令"><a href="#简单汇编指令" class="headerlink" title="简单汇编指令"></a>简单汇编指令</h1><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">18</span>    <span class="hljs-comment">;将18送入寄存器AX    AX = 18</span><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-number">88</span>    <span class="hljs-comment">;将88送入寄存器AH中   AH=88</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">8</span>     <span class="hljs-comment">;AX = AX+8</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">bx</span>    <span class="hljs-comment">;AX的值 = BX</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">bx</span>    <span class="hljs-comment">;ax = ax+bx</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">bl</span> <span class="hljs-comment">;这条指令是不正确的，ax是16位寄存器，bl是8位的，前后必须保持一致</span></code></pre></div><p>作业：</p><div class="code-wrapper"><pre><code class="hljs x86asm">程序段中的指令     指令执行后<span class="hljs-built_in">AX</span>中的值    指令执行后<span class="hljs-built_in">BX</span>中的值<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4E20H</span>      <span class="hljs-number">4E20H</span>                   <span class="hljs-number">0000H</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">1406H</span>      <span class="hljs-number">6226H</span>                   <span class="hljs-number">0000H</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">2000H</span>      <span class="hljs-number">6226H</span>                   <span class="hljs-number">2000H</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">bx</span>         <span class="hljs-number">8226H</span>                   <span class="hljs-number">2000H</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-built_in">ax</span>         <span class="hljs-number">8226H</span>                   <span class="hljs-number">8226H</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">bx</span>           ?                     <span class="hljs-number">8226H</span>注意:后面的H字母表示十六进制数（Hex）计算：<span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">1406H</span><span class="hljs-comment">;也就是16进制4E20+1406=6226，直接用计算器</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">bx</span><span class="hljs-comment">;也就是16进制ax=6226+2000=8626</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">bx</span><span class="hljs-comment">;也就是ax=8226+8226=1 044C</span>注意：这里最后？计算出来的结果为1044C，但是由于<span class="hljs-built_in">AX</span>是<span class="hljs-number">16</span>位寄存器，所以最前面的<span class="hljs-number">1</span>溢出了，得到的？值为044C</code></pre></div><h1 id="8086-CPU寻址能力"><a href="#8086-CPU寻址能力" class="headerlink" title="8086 CPU寻址能力"></a>8086 CPU寻址能力</h1><p>8086有20根总线，可以传送20位地址，每个地址都可以存放0或1，寻址能力即<code>2^20=1048576 bit</code>，即寻址能力为1M，cpu和内存之间通过20条地址总线相连接，可以传送20位地址，寻址能力达到1MB。但是16寄存器寻址能力是2的16次方，也就是65536bit，只有64KB，这显然是不合适的</p><p>那么内部寄存器为16位，那么如何来寻找20位地址？？采用地址合成（两个16位进行地址合成得到20位）</p><img src="/2022/08/20/22-0820-01/image-20220829104830861.png" class="" title="image-20220829104830861"><p>例如，1230和00C8进行合成，步骤如下：</p><img src="/2022/08/20/22-0820-01/image-20220829104840678.png" class="" title="image-20220829104840678"><p>寻址123c8H的内存单元  地址加法器采用段地址 x 16 + 偏移地址的方法合成<code>物理地址</code>，其实就是用一个基础地址加上一个偏移地址</p><p>注意：</p><ul><li>这里的段地址×16，段地址是1230，这是十六进制，但是16是十进制，所以我们把1230转为十进制，也就是4656，然后再用4656×16&#x3D;74496，而76696转为十六进制就是12300</li><li>或者这样想也行，段地址*16相当于这个 “16进制数” 左移1位，后面补个0，1230就变成了12300</li></ul><h2 id="段地址和偏移地址的理解"><a href="#段地址和偏移地址的理解" class="headerlink" title="段地址和偏移地址的理解"></a>段地址和偏移地址的理解</h2><blockquote><p>转载：<a href="https://blog.csdn.net/qq_18360881/article/details/107225697">https://blog.csdn.net/qq_18360881/article/details/107225697</a></p></blockquote><p>如果让你去一个地方，这个地方叫野猪窝（哈哈，这是个地名），那你知道怎么走吗？如果你不知道地址，你是不是会把中国遍历一下。也挺好，你可能会找到若干个野猪窝。如果我告诉你，这个地方在陕西省西安市蓝田县汤峪镇。你是不是很快就能找到目标?</p><p>先别急，让我们一步一步来，假设你的定位范围是整个地球，首先我告诉你在中国，那么你就可以过滤掉美国，日本，英国等一系列国家，从而在我们中国内部进行检索。这时我又告诉你在陕西省，那么你离目标是不是又近了一步？然后是西安市、蓝田县······一步一步的，你就找到了这个地方。</p><p>在上面的介绍中，中国可以认为是一级段地址，通过他可以过滤掉一系列其他国家，进行下一级行政单位（省份）的确定，陕西省是中国的偏移地址，进入中国范围后，可以通过陕西省过滤掉我国的其他省份，同样陕西省也是他下一级行政单位（西安市）的段地址，依次递推。这是不是就明了许多了？</p><p>我们将这个概念再带回计算机上，假设你现在有1024字节的内存，你将他们分为四个段，每个段有256个字节。把这四个段分别编号为A，B，C，D。当你想要唯一的定位一个字节时，你应当先找到他所在的段地址，然后就可以排除其他三个段地址了。这样你的检索范围就会大大缩小。比如说你要检索的数据在C段，那你就可以只检索C段内的256个字节，如果再告诉你偏移地址，比如说是第123个字节，那么就很容易定位了。</p><h2 id="物理地址-x3D-段地址-16-偏移地址的含义"><a href="#物理地址-x3D-段地址-16-偏移地址的含义" class="headerlink" title="物理地址&#x3D;段地址*16+偏移地址的含义"></a>物理地址&#x3D;段地址*16+偏移地址的含义</h2><blockquote><p>转载：<a href="https://zhuanlan.zhihu.com/p/443067188">https://zhuanlan.zhihu.com/p/443067188</a></p></blockquote><p>“段地址 x 16 + 偏移地址 &#x3D; 物理地址” 的本质含义是：CPU在访问内存时，用<strong>基础地址</strong>（段地址 x 16）和基于基础地址的<strong>偏移地址</strong>相加，给出内存单元的物理地址。</p><p>比如：</p><img src="/2022/08/20/22-0820-01/image-20220830093931526.png" class="" title="image-20220830093931526"><p>此时 你从家出发前往图书馆，你询问我如何前往，我可以告诉你两种方式：</p><ol><li>从家出发，走2326m到达图书馆。这2326m就可以看作图书馆的物理地址。</li><li>从家出发，走2000m到达饭馆，吃个饭在走326m到达图书馆。这里的2000m可以看作相对于家的基础地址，第二个326m相对于基础地址的偏移地址（以基础地址为起点的地址）</li></ol><ul><li>第一种方法直接给出物理地址。</li><li>第二种方法是用基础地址和偏移地址相加得到物理地址。（进一步展现了物理地址&#x3D;段地址*16+偏移地址）</li></ul><p>此时我们为以上描述增加一些限制条件，比如，只能通过纸条来传递信息</p><p>你问我去图书馆怎么走，显然我需要一个可以容纳4位数据的纸条，才能写下2326这个数据。</p><img src="/2022/08/20/22-0820-01/image-20220830094506657.png" class="" title="image-20220830094506657"><p>可是不巧的是， 我没有能容纳4位数据的纸条，仅有两张可以容纳3位数据的纸条。那么我只能以这种方式告诉你</p><img src="/2022/08/20/22-0820-01/image-20220830094948537.png" class="" title="image-20220830094948537"><p>在第一张纸上写上 232（段地址），在第二张纸上写上006（偏移地址）。假设我们事先对这种情况有过约定：<br>你得到两张纸后做这样的运算：232（段地址）×10+006（偏移地址）&#x3D;2326（物理地址）</p><h2 id="段的最大长度"><a href="#段的最大长度" class="headerlink" title="段的最大长度"></a>段的最大长度</h2><p>一个段中每个内存单元的地址表示为 段地址:偏移地址</p><p>其中，段的长度是偏移地址可以取的数值规定的，在8086cpu中，偏移地址使用一个16位的二进制数表示，其表示范围是（0000H:0FFFFH），总共有2^16(2的16次方)&#x3D;64K个不同的取值，一个内存单元使用1个偏移地址，故一个段的大小是64K</p><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">作业:</span>1.给定段地址为0001H，仅通过变化偏移地址寻址，CPU的寻址范围为____0010H___到___1000F_____。2.有一段数据存放在内存20000H的单元中，现给定段地址为SA，若想用偏移地址去寻址到这个单元，则SA满足的条件是：最小为___1001_____，最大为______2000H_______<span class="hljs-section">解析:</span>1. 由于CPU的范围是“段地址×16”+偏移寻址，由于偏移寻址是16位，那么最大就是FFFF，最小就是0啦，所以最小范围就是0001H×16，最大就是0001H×16后再加FFFF2. 这里和第1题恰好反过来了，这里知道物理地址是20000H，所以先减去FFFF得到1 0001，再把10001转为十进制再÷16得到4096，再把4096转为十六进制就是1000H，但是1000H如果是段地址，那么进一位（×16），也就是10000H，但是应该是1001H才行，所以前面的段地址最小应该是1001H最大为2000H</code></pre></div><h2 id="8086-CPU读取指令过程"><a href="#8086-CPU读取指令过程" class="headerlink" title="8086 CPU读取指令过程"></a>8086 CPU读取指令过程</h2><p>段地址实际就是由段寄存器提供，8086 CPU有4个段寄存器：CS 、DS、SS 、ES </p><p>其中CS和IP它们指示了CPU当前要读取的地址，CS叫代码段寄存器，IP为指令指针寄存器，比如：在<code>任意时刻</code>，8086 CPU将从CS中的内容×16+IP的内容单元处开始读取一条指令（可以将CS理解为段地址、IP理解为偏移地址）</p><p>如下图：B8、23、01这些都是机器码，后面的20000、20001、20002这些是内存地址，后面是B8、23、01机器码对应的汇编指令（注意：<code>每个内存地址对应一个存储单元，每个存储单元大小为1字节</code>，恰好这里B8、23、01这些十六进制都是1个字节）</p><img src="/2022/08/20/22-0820-01/image-20220830100304478.png" class="" title="image-20220830100304478"><p>8086 PC读取和执行指令的相关部件以及过程如下：</p><p>步骤一：</p><img src="/2022/08/20/22-0820-01/image-20220830100330281.png" class="" title="image-20220830100330281"><p>步骤二：</p><img src="/2022/08/20/22-0820-01/image-20220830100750071.png" class="" title="image-20220830100750071"><p>步骤三：</p><img src="/2022/08/20/22-0820-01/image-20220830100801500.png" class="" title="image-20220830100801500"><p>步骤四：</p><img src="/2022/08/20/22-0820-01/image-20220830100809487.png" class="" title="image-20220830100809487"><p>步骤五：</p><img src="/2022/08/20/22-0820-01/image-20220830100826437.png" class="" title="image-20220830100826437"><p>步骤六：</p><img src="/2022/08/20/22-0820-01/image-20220830100835114.png" class="" title="image-20220830100835114"><p>步骤七：</p><img src="/2022/08/20/22-0820-01/image-20220830100846225.png" class="" title="image-20220830100846225"><p>步骤八：</p><img src="/2022/08/20/22-0820-01/image-20220830100854359.png" class="" title="image-20220830100854359"><p>步骤九：</p><img src="/2022/08/20/22-0820-01/image-20220830101101510.png" class="" title="image-20220830101101510"><p>步骤十：</p><img src="/2022/08/20/22-0820-01/image-20220830101110907.png" class="" title="image-20220830101110907"><p>步骤十一：</p><img src="/2022/08/20/22-0820-01/image-20220830101121777.png" class="" title="image-20220830101121777"><p>步骤十二：</p><img src="/2022/08/20/22-0820-01/image-20220830101129951.png" class="" title="image-20220830101129951"><p>步骤十三：</p><img src="/2022/08/20/22-0820-01/image-20220830101136970.png" class="" title="image-20220830101136970"><p>步骤十四：</p><img src="/2022/08/20/22-0820-01/image-20220830101145687.png" class="" title="image-20220830101145687"><p>步骤十五：</p><img src="/2022/08/20/22-0820-01/image-20220830101154735.png" class="" title="image-20220830101154735"><p>步骤十六：</p><img src="/2022/08/20/22-0820-01/image-20220830101201719.png" class="" title="image-20220830101201719"><p>经过上面的步骤，可总结CPU执行指令的步骤如下：</p><ol><li>从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器</li><li>IP &#x3D; IP+读取的指令的长度，指向下一条指令</li><li>执行指令，执行完成转到步骤1，重复这个过程</li></ol><h2 id="如何修改CS-IP的值"><a href="#如何修改CS-IP的值" class="headerlink" title="如何修改CS:IP的值"></a>如何修改CS:IP的值</h2><p>8086 CPU加电启动或复位后，CS和IP的值被设置为CS&#x3D;FFFFH、IP&#x3D;0000H，开机后执行的第一条指令的内存地址就是 CS&#x3D;FFFFH、IP&#x3D;0000H</p><p>如何要同时修改CS:IP的值，那么可以通过jmp（跳转）指令来实现，比如：<code>jmp 0fffh:0100h</code>，把CS修改为0fffh，IP改为0100h</p><p>如果仅仅修改IP的值，jmp 某个寄存器，比如：<code>mov ax,0fffh,jmp ax</code>，可以将这个分开理解，<code>mov ax,0fffh</code>就是ax&#x3D;0fffh，后面的<code>jmp ax</code>可以理解为<code>mov ip,ax</code>，也就是ip&#x3D;ax&#x3D;0fffh，这样ip就成了0fffh，为啥修改ip的值要这么麻烦呢？？？因为语法就这么规定的。。。</p><div class="code-wrapper"><pre><code class="hljs txt">作业：mov ax,bxsub ax,axjmp ax这3条指令执行后，CPU几次修改IP？都是在什么时候？，最后IP的值是多少？解答：注意：sub是减法指令mov ax,bx  读取到指令缓冲器mov ax,bx 修改自己ip+2  执行sub ax,ax  读取sub ax，bx 修改ip+2   执行jmp ax     读取jmp ax ，修改ip+2  执行注意：jmp ax，这里由于sub ax，ax后，ax为0，也就是jmp 0，所以还会修改ip，ip还会修改1次所以ip一共修改了4次</code></pre></div><h1 id="Debug调试方法"><a href="#Debug调试方法" class="headerlink" title="Debug调试方法"></a>Debug调试方法</h1><blockquote><p>注意：这里要在windows 2003中使用，win10版本太高，无法直接使用</p></blockquote><p>cmd下直接输入debug即可</p><img src="/2022/08/20/22-0820-01/image-20220830104037882.png" class="" title="image-20220830104037882"><p>-r 查看和改变寄存器内容</p><img src="/2022/08/20/22-0820-01/image-20220830104056968.png" class="" title="image-20220830104056968"><p>-d 以数据方式显示寄存器的内容</p><img src="/2022/08/20/22-0820-01/image-20220830104104567.png" class="" title="image-20220830104104567"><p>-u 以汇编指令的方式显示寄存器的内容</p><img src="/2022/08/20/22-0820-01/image-20220830104509769.png" class="" title="image-20220830104509769"><p>-t 执行一条机器指令</p><img src="/2022/08/20/22-0820-01/image-20220830104519704.png" class="" title="image-20220830104519704"><p>-a 用汇编形式写入指令，这里是向0AEF:100这个地址写入mov ax,100（两次回车退出）</p><img src="/2022/08/20/22-0820-01/image-20220830104528150.png" class="" title="image-20220830104528150"><p>然后-r查看寄存器的内容如下，AX的值是0，我们现在是想把ax值变成100，如果后面执行-t的话，下图中绿色划线的指令mov [96C7],AL，我们只需要让其-t执行mov ax,100即可把ax的值由0变成100</p><img src="/2022/08/20/22-0820-01/image-20220830105122544.png" class="" title="image-20220830105122544"><p>所以我们需要修改IP的值，把IP的值修改成100即可，这样段地址（CS）：偏移地址（IP） &#x3D; 0AEF：0100，这个地址也就对应-a写入时的地址</p><p>通过-r ip修改ip的值，修改后，再次-r查看寄存器内容，指向的就是ax,100</p><img src="/2022/08/20/22-0820-01/image-20220830172405342.png" class="" title="image-20220830172405342"><p>然后-t执行后，ax的值就改成了100</p><img src="/2022/08/20/22-0820-01/image-20220830172414669.png" class="" title="image-20220830172414669"><p>-d 0aef:0170从0aef:0170开始查看数据</p><img src="/2022/08/20/22-0820-01/image-20220830172421247.png" class="" title="image-20220830172421247"><p>如果要查看0aef:0170到0aef:0177之间的数据，如下划红线的数据：</p><img src="/2022/08/20/22-0820-01/image-20220830172429001.png" class="" title="image-20220830172429001"><p>使用 -d 0aef:0170 0177</p><img src="/2022/08/20/22-0820-01/image-20220830172436745.png" class="" title="image-20220830172436745"><p>-e修改数据内容，比如：修改0aef:1000开始的数据，没修改前，数据46,EB,EB，修改成00,11,22</p><img src="/2022/08/20/22-0820-01/image-20220830172444557.png" class="" title="image-20220830172444557"><p>修改后如下：</p><img src="/2022/08/20/22-0820-01/image-20220830172451282.png" class="" title="image-20220830172451282"><p>也可以按字符串修改</p><img src="/2022/08/20/22-0820-01/image-20220830172459440.png" class="" title="image-20220830172459440"><p>修改后如下：</p><img src="/2022/08/20/22-0820-01/image-20220830172505840.png" class="" title="image-20220830172505840"><p>也可以通过-a写入数据，比如通过-a向1000:0这个地方写入mov ax,bx，然后查看</p><img src="/2022/08/20/22-0820-01/image-20220830172512107.png" class="" title="image-20220830172512107"><p>通过-u查看更明显</p><img src="/2022/08/20/22-0820-01/image-20220830172518360.png" class="" title="image-20220830172518360"><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">作业:</span>查看内存中的内容，PC主板上的ROM上有一个生成日期，在内存FFF00-FFFFFH的某几个单元中，请找到这个生产日期并且试图改变他<span class="hljs-section">解析:</span>物理地址=段地址*10+偏移地址，这三个地址都是16位数字，数字后面的H可以写，也可以不写，都表示的是16位的数据；16表示的是十进制的，转换成16进制就是10。段地址占用4个字符，即：fff0，因为物理地址=fff00，所以偏移地址=0，计算过程即：fff00=fff0*10+0；同样的道理，物理地址fffff，段地址是fff00，便宜地址是ff所以，查看内存的指定物理地址的数据，就直接使用命令，d fff0:0 ff即可得到该内存中fff00-fffff的数据。</code></pre></div><img src="/2022/08/20/22-0820-01/image-20220830191832791.png" class="" title="image-20220830191832791">]]></content>
    
    
    <categories>
      
      <category>16位汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>转载：理解 分段 | 分页 机制</title>
    <link href="/2022/08/13/22-0813-02/"/>
    <url>/2022/08/13/22-0813-02/</url>
    
    <content type="html"><![CDATA[<h1 id="分段-分页的产生"><a href="#分段-分页的产生" class="headerlink" title="分段|分页的产生"></a>分段|分页的产生</h1><blockquote><p>转载自：<a href="https://blog.csdn.net/low5252/article/details/106068865/">https://blog.csdn.net/low5252/article/details/106068865/</a></p></blockquote><p>分段和分页都是为了利用和管理好计算机的资源—内存。在分段技术没有出现之前，程序运行是需要从内存中分配出足够多的连续的内存，然后把整个程序装载进去。举个例子，某个程序大小是10M，然后，就需要有连续的10M内存空间才能把这个程序装载到内存里面。如果无法找到连续的10M内存，就无法把这个程序装载进内存里面，程序也就无法得到运行。上面这种直接把整个程序装载进内存的方式是有一定的问题的。</p><ol><li><p>地址空间不隔离</p><p>举个例子，假设我有两个程序，一个是程序A，一个是程序B。程序A在内存中的地址假设是<code>0x00000000~0x00000099</code>，程序B在内存中的地址假设是<code>0x00000100~x00000199</code>。那么假设你在程序A中，本来想操作地址<code>0x00000050</code>，不小心手残操作了地址<code>0x00000150</code>，那么，不好的事情或许会发生。你影响了程序A也就罢了，你把程序B也搞了一顿。</p></li><li><p>程序运行时候的地址不确定</p><p>因为我们程序每次要运行的时候，都是需要装载到内存中的，假设你在程序中写死了要操作某个地址的内存，例如你要地址<code>0x00000010</code>。但是问题来了，你能够保证你操作的地址<code>0x00000010</code>真的就是你原来想操作的那个位置吗？很可能程序第一次装载进内存的位置是<code>0x00000000~0x00000099</code>，而程序第二次运行的时候，这个程序装载进内存的位置变成了<code>0x00000200~0x00000299</code>，而你操作的<code>0x00000010</code>地址压根就不是属于这个程序所占有的内存。</p></li><li><p>内存使用率低下</p><p>举个例子，假设你写了3个程序，其中程序A大小为10M，程序B为70M，程序C的大小为30M。你的计算机的内存总共有100M。这三个程序加起来有110M，显然这三个程序是无法同时存在于内存中的。并且最多只能够同时运行两个程序。<br>可能是这样的，程序A占有的内存空间是<code>0x00000000～0x00000009</code>，程序B占有的内存空间是<code>0x00000010～0x00000079</code>。假设这个时候程序C要运行该怎么做？可以把其中的一个程序换出到磁盘上，然后再把程序C装载到内存中。假设是把程序A换出，那么程序C还是无法装载进内存中，因为内存中空闲的连续区域有两块，一块是原来程序A占有的那10M，还有就是从<code>0x00000080～0x00000099</code>这20M，所以，30M的程序C无法装载进内存中。那么，唯一的办法就是把程序B换出，保留程序A，但是，此时会有60M的内存无法利用起来，很浪费对吧。</p></li></ol><p>为了解决上面的问题就引入了分段和分页技术</p><h1 id="分段的理解"><a href="#分段的理解" class="headerlink" title="分段的理解"></a>分段的理解</h1><p>为了实现分段技术，需要引入虚拟地址空间的概念。那么什么是地址空间呢？简单的说就是可以寻址的一片空间。如果这个空间是虚拟的，我们就叫做虚拟地址空间；如果这个空间是真实存在的，我们就叫做物理地址空间。<strong>虚拟地址空间是可以任意的大的，因为是虚拟的。而物理地址空间是真实存在的，所以是有限的</strong>。</p><p>分段这个技术做了一件什么事情呢？它把虚拟地址空间映射到了物理地址空间（<strong>未开启分页情况下，从虚拟机地址空间到物理地址空间的转换是段基地址+段内偏移地址</strong>），并且你写的程序操作的是虚拟地址。假设，程序A的虚拟地址空间是<code>0x00000100～0x00000200</code>。此时，不仅需要一块连续的物理内存来存放程序A，还需要把程序A的虚拟地址空间映射到（转换为）物理地址空间。可能，程序A的虚拟地址空间从<code>0x00000100～0x00000200</code>映射到了物理地址空间<code>0x00000000～0x00000100</code>。</p><p>分段技术可以解决上面1、2两个问题。</p><p>在问题1中，假设程序A的虚拟地址空间是<code>0x00000000~0x00000099</code>，映射到的物理地址空间是<code>0x00000600~0x00000699</code>，程序B的虚拟地址空间是<code>0x00000100~0x00000199</code>，映射到的物理地址空间是<code>0x00000300~0x00000399</code>。假设你还是手残，在程序A中操作了地址<code>0x00000150</code>，但是英文此时的地址<code>0x00000150</code>是虚拟的，而虚拟化的操作是在操作系统的掌控中的，所以，操作系统有能力判断，这个虚拟地址<code>0x00000150</code>是有问题的，然后阻止后续的操作。所以，体现出了隔离性。（另一种体现隔离性的方式就是，操作同一个虚拟地址，实际上可能操作的是不同的物理地址）（<strong>注意，实际上，很可能程序A和程序B的虚拟地址都是<code>0x00000000~0x00000099</code>。这里的举例只是为了方便理解。</strong>）</p><p>问题2也很好的解决了。正是因为这种映射，使得程序无需关注物理地址是多少，只要虚拟地址没有改变，那么，程序就不会操作地址不当。</p><h1 id="分页的理解"><a href="#分页的理解" class="headerlink" title="分页的理解"></a>分页的理解</h1><p>但是问题3仍然没有解决。因为第三个问题是换入换出的问题，这个问题的关键是能不能在换出一个完整的程序之后，把另一个完整的程序换进来。而这种分段机制，映射的是一片连续的物理内存，所以问题3得不到解决。</p><p>而问题出在哪呢？就是<strong>完整和连续。</strong></p><p>而分页技术的出现就是为了解决这个问题的。分页这个技术仍然是一种虚拟地址空间到物理地址空间映射的机制。但是，粒度更加的小了。单位不是整个程序，而是某个“页”，一段虚拟地址空间组成的某一页映射到一段物理地址空间组成的某一页。（如何理解这个“页”的概念，这个问题见下面）</p><p>分页这个技术，它的虚拟地址空间仍然是连续的，但是，每一页映射后的物理地址就不一定是连续的了。正是因为有了分页的概念，程序的换入换出就可以以页为单位了。那么，为什么就可以只换出某一页呢？实际上，不是为什么可以换出某一页，而是可以换出CPU还用不到的那些程序代码、数据。但是，把这些都换出到磁盘，万一下次CPU就要使用这些代码和数据怎么办？又得把这些代码、数据装载进内存。性能有影响对吧。所以，我们把换入换出的单位变小，变成了“页”。（实际上，这利用了空间局部性），问题3是不是就解决了呢？<br>所以，分段和分页的区别在于：<strong>粒度</strong>。</p><h1 id="分段和分页的概述"><a href="#分段和分页的概述" class="headerlink" title="分段和分页的概述"></a>分段和分页的概述</h1><p>分段就是将一个程序分成代码段，数据段，堆栈段什么的，如下：</p><img src="/2022/08/13/22-0813-02/image-20220821104720506.png" class="" title="image-20220821104720506"><p>分页就是将这些段，例如代码段分成均匀的小块，然后这些给这些小块编号，然后就可以放到内存中去，由于编号了的，所以也不怕顺序乱，如下：</p><img src="/2022/08/13/22-0813-02/image-20220821105207174.png" class="" title="image-20220821105207174"><p>然后我们就能通过段号，页号，页内偏移找到程序的地址，如下：</p><img src="/2022/08/13/22-0813-02/image-20220821105323219.png" class="" title="image-20220821105323219">]]></content>
    
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题总结</title>
    <link href="/2022/08/04/22-0804-01/"/>
    <url>/2022/08/04/22-0804-01/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="TCP、UDP"><a href="#TCP、UDP" class="headerlink" title="TCP、UDP"></a>TCP、UDP</h2><p>tcp和udp的区别 ？？？</p><ul><li>tcp：面向连接</li><li>udp：无连接，比如说：QQ发送消息就是UDP，速度要比TCP更快</li></ul><p>为啥是三次握手而不是四次，三次握手过程 ？？？</p><ul><li><p>因为三次是可靠的，而四次比较多余，不高效</p><img src="/2022/08/04/22-0804-01/image-20220923202721437.png" class="" title="image-20220923202721437"></li></ul><h2 id="http、https"><a href="#http、https" class="headerlink" title="http、https"></a>http、https</h2><p>http和https的区别 ？？？</p><h2 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a>cookie和session</h2><p>cookie和session的区别</p><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>以下状态码的含义</p><ul><li>302</li><li>403</li><li>404</li><li>502</li></ul><h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p>以下服务的端口是啥 ？？（标*为重点）</p><ul><li>IIS   * </li><li>SQLServer * </li><li>Oracle *</li><li>MySQL *</li><li>FTP *</li><li>SSH *</li><li>redies</li><li>Tomcat *</li><li>webshpere</li><li>JBOSS</li></ul><h1 id="常见WEB漏洞"><a href="#常见WEB漏洞" class="headerlink" title="常见WEB漏洞"></a>常见WEB漏洞</h1><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><ul><li>判断有无注入</li><li>注入的类型</li><li>判断对应的数据库类型</li><li>sql注入写shell的方法，利用条件</li><li>sql注入绕WAF技巧</li></ul><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><ul><li>文件上传拿shell的限制 （比如：我们成功上传一个图片马，一定能够连接吗 ？？？）</li><li>文件上传常见绕过方法（黑白名单）</li></ul><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><ul><li>xss的三种类型、区别</li><li>httponly的绕过</li></ul><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><ul><li>disable_function绕过</li></ul><h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h2><ul><li>csrf和ssrf的区别</li><li>哪里容易出现ssrf</li><li>ssrf的作用</li><li>ssrf的gopher协议</li></ul><h2 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h2><p>* </p><h1 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h1><h2 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h2><ul><li>sqlmap常见的使用命令</li><li>sqlmap os shell的利用条件、原理</li></ul><h2 id="Burpsuite"><a href="#Burpsuite" class="headerlink" title="Burpsuite"></a>Burpsuite</h2><ul><li>burpsuite常见使用</li><li>burpsuite挂二级代理的方法</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo入门+Fluid主题美化|汉化</title>
    <link href="/2022/08/03/22-0803-01/"/>
    <url>/2022/08/03/22-0803-01/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="3dfce2f8b127a541d0c2e1adc88e91537c6937b7cc9bc02cc5a6c56c2f875fb0">bb37e7fa29ac998f9193b7733de58c59ffc2b770bd4b3ca6766c4a815de02498dd8b8942b29d39c8ed3b409f56abe4e128b0249ce13cd82f61d8c298b3d5519a7bc1156cf69017e5bea19176f9b0f83d4e95b5786020d4e65b0d1e2040d0b79b74dcdfc008b34d418aee23a771749c96ee2cc6cece445057cf256e36abc6072baacdb3d1fe78c91711408711658320bd665b0d72a0779158520dbe8d720671ac6602c57509d21d22e039c43d83175ff4d0089ae749edf2890b3d91384ac199d25cdf3ecca5cac598c1abdc4f6e7b422261c31c4866f1fd131798c935babcfb9d8e310ec04cb6c9d7e9c165247e884c82904927f3d13a8fea109e60758e9acd32b7c04600b0bb6b480392d8ae82d52581628396c8e45151aeeaa4ab9460a96173c07f487854624adee1a81c964cbe94011243a9186a4b0a5e14a6bac9fb0b7f9d23127ebbf72a2213e326f8a149f322f6b427ad178b9336f3efe60d2742124c69a387fad411e91647967de0cf8e6e395d809473b8fb919ca2ead3b940eccfa57d10d34ca34761b86fa672e1ce96b24ec262516cc26be01e55b1116cdd4485f51864fc6102cda48a0aa7adcff324bb4fa2dc50d7cd1bc4aa8c755a6c75e6e62c5e9db3e166e57a9d6e8724439a9f5378f3ee0b27794dacb37be2b1eddd5da9091e2d9805099ccc5775470de79c56dd3f035da2499a36b71c925c3379698e8722582141b8aa474e2cc24525e8d1a45895df5b0d900211ae8250cc82be9f63211310e55358e2a89d8f83550b6d387ac3e85975f7cc0b719393669b76037082f8b8d7e0264e4cbc1655bd44bf1af7d699c86f6b8e1f195e00a306321cddc555c4df7d26820572b6ab7786015fd0180776b2c31cc4c3b451a1fbd26648f252650934c5312c55944803bb5331c69d64d1724e8eefd647aa3a360206d7c75df7664ae5fb23005f4c8fec8050ec294888a12d42f55e786bce1bce5522601bad4cd15f40644ecb5862c0bcd12521e360bc2cb92001c19dabefd43d989bf69c7ac5a2aa1a13ff268d5ff83545a6f059897b23142ff1e66728fce2da2dab7141fbb9808ffb6ce62ca11503836bf6b1209d4d0e10a4c27e0399da6633eb5cb12de08ddba353ee8e659c5bbb861badf8559f689a5fbff59fd65368ef810d964e4dbd2e170af55fed069d62727cff19724568d59d42e73cab66c6085ddad69e86b59e96823dad25e045436d094d26a59caca0e51d85350c43eea74f4f1c6c9cd4ba2e16a85dedea3922b41a0ab941609558e42c181030249acba22e719bede57c2cb8f4b68e6838e457c8f48086fb265377f863bffc4449b3954c5c3a9a62996c6e909ce1011d356ec49c86e2a9902846d6ae251f80fc57ed93f2e8f9d9ab58bef6ba9ef5a5cb5ac570c65104320ede06458cccb16a2f09b175e00ff34705767dd250949cd7f01d1a3e8f1cf146d518fc688d983b7bb662c6109804fd473866f1e9e484f28774863b06e0a0ee57bd987b49426cfe647d0edbc14d59ecd9dfd4076a39a447dcca7c7ada7b3db216c2da5536887220cdf248258c7635d257e608a54baf0c6e9921da8dd84e886988995ba5b00e3f08512c450c15e498bdfdb8684a69558798c8875f97c5edb4f52ae5f49142fad0db188b63933c149cbdfdf37c16defbfc47f03cf5afbeba52afb8c98cd3918c9f60f9a5ddf12400c05fbdfdff970ce14c2a59158a7ae9f819f7efd8908aae1f70379140683dd031a05d27df867a1e94b43038bb1991a4f583f57dd3e4078c3f9f7d0305c95ea93a8bcf4b4d97ad0711e9a4dc5c49d228041071272619f02fdcf453d4a5eaf35fe495a78de4cb26994d517ce49f5d3930bebc90e3223b56df802df4f3d591e3234d5f29ed3697b0bfa3422c728fe6e340218d80fab11394f4ccfd5912328f23ce60f4a205ff1ddc4e6f6d567a6751a5e1e9bdaace3bee0f90967766f179a781e4658c617b88ef7b875fb57ae53b441ed5a2622493ce6b2b1d054de7644c5c836e465b5c9824d307cf661e24564cc20a57a3f5e935850531a3f2389a2bd24546a7091548a2f3367309d86936cb82645af3aa2e2df17ad13256c68d654e8451a24d6b5461ffec41bf81006426fdce5bab440bff8de001ec56f983fdc492aa76c52f0aaa6e86f4e41bd1ee5539ac28bcd1d1b5b6d12fa08a93f4d3fd7fca3bd1d322d7546fafaf01bccf80c07f496640230edab8aa7bae26c31b94ecb6eba5e2f7142c66ea1dd617ee13c7d7ed5bab9884c8eb6ff519fc5fb00dd26065b10c541d41859540165df53afde5609cd0d374374a1fd985e1b50e8f5732ac89de27cdbfc8966212f2e549a9f12b548a88d32a504c7070ae3ca11e452284e9209361c075b80ea378eaa1d2ad557a20eb10139d3f4bd016e4c5dc7a9d8341b2b1662b67ac033088e1eec5ac8a1ac66d4063bdc5b233d0f49579a31793b2b39e358f3aee10e8777760009b1da6e99125979a1582227a52f2c278363295d60b64d3e48fa5e1d048c3e1c61a5999dbdf54db0c2c4246195798f5e12680d9144edfc9f81a7dc605e0483b46cd61a3f5b0410af725321a51474af900a4574686ee0065995e53f98b12ee00af7780b32928c3f2339914e58c9f23af448fe8e7cc0a6c8b9548a87d38fe912b6745056b65e016d99cdb33016a0f7e60ea7a4b6af5435ad9c2353e574f9e102013dbd39017aeec957471555f93c400054d2eb09ef9ed5f94d412b1ee9a63365f8b72bc3104c60f19ce3ace97b188a049b382d0df33dc06cf8f5ecb9ac07c7eb92f973ab3649385ec5c334120cf690c5c28bda18d225a468641578e77fd806e52085950147ab00d1ae5a7ff165a3bc9bb094eb6b4c7b6e77a918745bcc0e40ab6becaf5bf2cddde590ba5350a8511e8f859b99d702c192ae03dda6db15f7cb62652d20d7b20a4f9ee0522f5011968c5c9000c66ecd61b41253dc6f23e6182402470cd3b0e96f47bd787167de58840ded4a7c9304be758ed467cbeb80fedd750a41178115c125285beeb337c02467796996a45adc226c41caa531f7a93c4f9dfab19bb034a25629dd8dc532499d5f0732ddca23599d94c67ff0c661d684713ceb059a4cbe20ece43f27e7e1ed057bd60870c68cc782dbaa257b09ed8a25326abfa1f44224a1867fd7b2b86ba57b4abb8f54f881c81767dfc3eab2c0909d451a40e86cf61c1647a262488cec62a08c134b3fec6a8a405622e4974f497927e51374a5974b0fc9ee6396f63adcde2865d806f2cafc32e3fafd8d2044b4ef11d2d297db0fad2292524cd5e3381b1bafd0d1ec7b43812662d9a7768b5f9812d083d2fed35511cf64980b1609d278175e32a15db43b3fd489f990bd363f37460fbbadb1702fc905b2b013cc57e01eaeb216e98b500579e6ff192ade38922dc289ac279ef23581af58d2415c00a7a0dce466e20b80df8c06789de83b173bf9be76dee2bab04cb88eea9907aabe0858eb191922dc0a4f2637c3e61a943a33b8d155d9c9ec89efbb5cc6637599776ba6dc40d4a20203e60fde6db0b9cb54d1bac4aaabcf9ab52c6600e0db15ab2f08c0145bc3a00eb5177251edeb6296fd409acc8dcfc11855e0db594074368d202f4718679ca05e8bbe58afc3534fd069b5c00439b2cfab53d66d3ea47e04eddcef545c125a7ebc46abd9ae53c394d62fe42ac59a2d50016a7594de3ecb26653c64b25bcaff4bf1bbae466c33b7b54a3b0c32f9c8627c8bac93aab894dcba9cbf7506635d58d92ff338e342cdab275b19421dda5e48950e9cbd884fb20549946ab99c04aee9e82bbd12fa303b9c37d33ca428c93dff3ced5276dbd65e49811b61cb098b80e454cf760b4d1344bc54ab58cb6ae3edfa27b9965324245c38fa921851dda004b3dc5077638cb5cd21722921e948cb8d596051013de6172e3558465559f52b320ad89e2edf0e161e239a07d988a5735b7afd7f40efb0251def4283d33fb47ef071cd6a44aa9d864724c5a6f23e3777de15ef9241c778d20b0a1936ee984e8efdf3e23e181bd9f8b6dd8ce1b4a98dbbda8cda7056fc6cb01e5f089892fdbe23c974c5ace03d859dfe17c3caf2ad5c4a09700318ba1451b1f2222126baa9d9d266eaa4a5fb38daf5fd10f50581bd58adb934a43880f987284eab97bf43383d75b1e5a57a83b74bb68ed2d35aaa51a5ef094f9a237db6fa6a4b596150ce9e4ed7325667dc4bca2473b0d2e26c7fd2df8a503ff01d2cb1aa7ed4c45d0e71449969a7c4f2671ae0d57a4333770354170d81bbb4d906a67c61af1ccba40a513b52e504d18253992d7a1346f1cd16f9179845886b3f859d0149df81b0cd20a01d9eec589a802ecfcb587eff31f016e84109b8ffacab275a9a015b8ce536871e3a92d4ee62c8b1da97f59a97d56a95571d4e018e85cb7f3d1f717e4f65044b59bbaa192e74b3e9e92d4e0baece2698fc910e8f84c2182ac341805d4ed9c0ef3cd407f683f948beb477eb3f91e25867db3fce4f5f0a9b21952f353e07d60154ce69bbb001923bba2cc6532f67c7851f8b9b636e9a24e6462d05521ca01f6796b6593d1980a8aeba29796e71e1c0b64caca18ef34680374b2bd70b499d5ab11e7502a069dff51f113bcf78a1d6d221142e84130997a820d42ffb1bf323d76c2ce30804d737c8b7b4389125807538d83c7e07b35ed1522c96d66f7d42b2ddaf3f6549839fffa575023417350e74fbad9eb4caed433d357567d7331d943ae399958b6c6015b2e285a476db9492c16c9f2760ef6b82ff846229756ac0aca9287f5d6a3c39321156dba345095bc4fbcd4b844b7b224e0e881d43259108144b76018a6d5947f6c8595024b12415bddba23f7ea72af17cdaab0ffeee0082f3733a1b261a16a16103b2689f4546950227f4ced395410c4dff0068ec6c487dc4b83dd188eb90c62249683e681f172703139e693048342eba954bb0d5bd23fbc4e59965a11284da67d0f11b0b3b6d0a366b26ee6fad87def6ac314a4d799dbc54a6260da35efc7c63fe01d4f5c8134dffe20363793a9645ac86050c0748100272613391662d00320a35937f6fa5b85b09c56ab9fd1938bbc2620becedc44d7ee7676b343658d9bc22d894f65d1e7efda7691b4062880e27f2b361040b381c13a43a04aac2e999125284cbe0f7fe99562c0c55037b4886b3405a2c01f7a3a201cbca1f3023f4b8f1e6487ad5effb778a55d52896d6f83bd16046ea9ab2ccebfe79eb9b008036a25139b2fcad5c283ee30479509d0218a9ee14ccf686e06d08250b3fefdc314fbddc78cd4cd38d63e2b757bfa4d3db6811fd42432ab84d6029ddcef25fab965cc788a6fcbfb9fba05ba037200d9a466e71fcfea2491294da80f478de89b69242d2165d228f01448917040b87eb62f150362abdfb794d82ca4c7576b38321f7705e620eae159b5ddfd9511bde4112f83ad519088b62f8d515f97dec006c83aa71979a869af39703bfc5f9f25bf9f91eb2cf3252dd58ae14e840c37159b2fd41d7b9881464efc89888a501834550d7137c4c7dcddc5e01e9a0b643339417e0831e4576cf51a941d66a36c8d740e8d05c1091d54f8c6f73d786cd8acb90406567edbb6163f5a909ef840da4e423762f3ee296154b98fa69ea9e740dee81a28b43a9267b98226ddba2f5db055278cc36bb2049f76776511d772deac49338a9b081e823aeaabd0532de4d8408662f82c8f2ca163396ab194fb2615195a107329d02a14da2fa9532fb4cfae419ccf5572c8b0169113578956305adc947b74be12cbce7dc5a40a307827d50d1750b68b0e8297d0482d774ecd6224e1ee3b3f4cf4829c2c73cc44019004c2571a6b4ed7ec0c1a5e81d36c3f91510597c4e87cfb65a3e48547ebe96510cba1c25320041752e0d4386c0bf3765d08aa0dae1a099545c07addafde5cff3742674ef2160dc1f77f242ea720d340faf24558b730de4fc5a46c4fdfd29824dfd9d52c6585b6bbf9ca8840bd9d8da0f960a33008eb0bb2e8f94dfc4974388cb9f4d2d523b4434b51fa02ab49e6ae4ce1fc6bc4668ed5ca61d2f31ef20df4e90e94292027d1c1a579f8a1611825e22a8c5ae4b8324e6c32c11e5c0f8f78d8de40ca0b0ae47465536d59cee64036de1d8846a73b5e337483dc084b02e53ceb8744c9d82c96adf1e3a2ebd0f55d4b566337617bc0b722039ef60aa4351af7a94bb00fca774dc4f1bf266fa95c3becfbcf5d7c9ce677d7a95d0cfe86cb31ac77f5d918b0cc7e72abd9e46750fff364e8a75f36a05e749af74059f6d5a458ae79245b6772603409188fa60ec7f5ce4a981ec6ba4eaae1bf144a1b967d4b92597901e69c0b3000e0fad748a499a4fcf99240b4b4ad169c710106460daf635dabe40af5b0af2dfe9ecf485510b61cbc85fd92f5775214ad527412163093ff900521898db0a6d4f1f1822f0e1ba90a87f85cf3bfee5892d3df31df1e029eb8b252d0026f83024adfef142dbc5e2e1489c8323dc8ac6820a880bbd8db5a0f8c4c06db2c70b212a118c6729d115c6f634ff172f19058f9bdefd5d26f4ffb26fd4bab13ff68fa670e636e8bc60f99f823f097e859714b212a4b5925d969831e93457b3cc1eec1723d0991a88eb02239a87ebe1ce52ce8b14331f810cfcc5c77071acfe7d5c3a2bc2e653db8f781900454f3829c4845cda64f4c6bbc405847d34bdbb300e5659064055fb471d861a62d626a1f81e9eb01443335c0ad3e0e703990309b94e3e9070cd092e2b847fdea6c455332d06f487382621db57636440b5aca73652a036fe56ad2c1c7222f3dc3ee96bf8b4b2647d4009e3b86517b32e06e6a64507a46bd104b3405f5b32426d2194ceda2c1f3152c7165e47eb14856d7cec8e93cdba35ca854f7a3e592651a3db268236794bdb9e763e54842ded2eb3a7d13484e20c95eea1fb763460f4e969c524bd08a06eabf7882dfaa1aa2a20cf824e4ecb78f5612cd5f935a79d72aec1562b20465926d4bf1a8f0f7f5ec16f52ae64ceb2317caba86f08e2ee55fd06881de237271f52de7fabb341cc8f7951052c094225c92de2a533a062d61e5d5f7be10d44e10d4f1c01d8cebd2b2d74ba774a05bb7569f6ff10ec4c3138df28739cb18672e936bd6b9efe6d0418caece8f86f072a18ffd19779dbde96e571ab627bf9e9f4a0397008f450acc8ebe912c3fcc4635ee3c8a63854a799c0cdb34a64d9ba788cdde4209f14f8b505c214832e0919679cdbb40076eb0d3913a266084b45dbbc821c5e72710c01f191efd0a656260a407da48b2a5f3ac458500c0cb64235291109a91668051689c36fd4b5835902660c6054c13b7c12e9d4b0203c087ca58eb54611fcd804295dbdd0af79d57b1015ee8ec1026ed39919dd241a4b66b3d8b47db41f5fb5ddd9fc53365694b25a383c83c467a872d27cf03a8c0f093678f78ba859f28f9825ffa488ebdfffd6c287eb518145e1df76e368a4804f3d591bc27d8b0cd2d00e2c5aed6d2eeb56a66912d22326a787ac9aec730d0d2c055721a55e79eaf794ae32bae21c9aee844ec279a2f862751a98f16dcbe36d8364bfb718166c8e70a94f85de8ebdb165810b4ad59960300b3d82b5f3119f20b4320cd97318ee90e93c35b32db5d53dffa8d56778b9d7d5bb47387cc5f206a6f656f05e0ee7f1307edf501e63350c5749bbe09a0233bee01bf6d237e1364929a99cfca62b1c3d4a34ca25de50901ace1098d4c99d6634cf473d86284ca3fd52143aebb447664add522bf20870b7d50c7147ef91f8f3381205fb1675b20ec30d9bf9bf8ddd6762f0c7b8c1e79d59f18fa709e31ea9188d9d1eecf5e540f59e67754e04aad2c9345725c05f626d318fed3a67bf81dc93d1f6589ec38f1ed7b2d4c75b10e5c4a72d33c478cf819d3568322ed401af2b049b5dfcae36d72a4d5da73152d065ae545d27da837fa64c88d492fa98c665dd926ad8f4fac517604eceda64edefea7badc8ee8158fee52dd6492ed4b50f4191d53b6798aff9bdde287348a71449fd9bb9a0cb7023a6ea819f01f065bdfa1102e3ecb757a493562f922dfda84a3083aac9dc07bacd52dfc1dc2a850b81a75b57c7f315257a3e521bc078dcdd46e5c01069799e455ba4690167b41d0fab9c957b7ec29fc6d80b7a9d4f9323769429afbdf0e46e3d9cd6134c64ba4774136933dbab3932498567814aa68a4636e5172230e3c45036c82dbd22b852ddff83bfbb1e692fec2339159e2351331cc0f6ad9cb0b51685554f3ffaf19f5833fa974c24cb4e8278e895e0c8e92574031967addf75f1ece03f93a25fe061844563559c4154b965f336f3c51b3af9df0ebf3fd7b7f254919c992b5db23c6e78d3d1a7489833316573be29e7325659103f2ccbf4c5bd6e650584142cf4c2f7452162abc4051515489f633857ad7c3f07864ead00a869235b07084926a957e88996bd18d3ef079b02492055b90664df93521be7eb2499064034a57932f21ae6da4b4e5fb1f768d5a1f256fef2a27a14e380b9c38bf29bd70a5dda124f25b0bd1ea4058ba5ce494daa38cd8eb4b069039cf55c8b49aa1a214bd0bbc34488b19289104fd1dae22d1f784eaf197cf2523f44f9b084d620097feebd77761ad3e835e713a6851aed2e46cd6b591c780ff179f5462d2caf265f4baaf2943741370c38fc91eafca472b8d9078aa470ece40ced5e39ba80e4659ef93f275e81165cdb5015e5ac728b5108366ba7731c2f1e713cc013d6285bac4b61232807ee69d3e05d6282087ca139d8be959616b1fc2ce2da9240190005cc455e91623bf43259b5b1f7c3881a7a26f697a2a6bfbb187aba6c767f39b28581c4ff9172bd5b9d7c7f0599c9f4385f7f1f10a099ae66a5cc33b690120e58ce12d45593a8aaa152ec12a339165bd3b1a9b00f19521f45c8086d9eceb854016b2a593594e1670a757b3ccc66bc4e64714fc3454a00b3b92c150e23b8a206d572be85cb2cc000e876990cb026e0488707ba6ce455ebe8249dfbffa37dbf1c81c8fdf4f12ab2c854ebba3aad1ae6d50795552e13a2700d960e470ef708d817e06c387e2328d7fb5e3c8c02926bf1d6098857c18cbe36c0e7f01baf5f6be7ac4d6e43996855c1ef2a6012d8af4839175b230f04e184889755744c5c5672cd99b1f2e43491acba13b20e286b3078f526544eb9bc018e8798cb9552515368a9bc3c25d00eb45f88e9c3da190d03efb05e31caa2015cb43b774a54ac16c22f9264e70fd31f21267f6cabd5c9256efcf7589a82317295d182f09afb7b142403cbf49af07c76d6280a6ec98982798529aa501639925451dbd45b349829c35b73af8f01de4748e460aed08ed7d278a2215d603c0885f04bb58b974944d31bf45592b6eb480da30c62eaddc31c27ac5ec0078baf009074abfd9c104d3798f06ae824d596e6079dd022dea174f157a174b0d8033c7d221503214deffd46f10c695ede3d61df3f3e8dc854cdd5639ece17171992e62ded4929474b3b040e3abdba412f0c66dc8e9ff7ae658d4c27a2d968ad8f788cc0d315394ee37b651587e17b55cb9e3a27ab3ed38b3682ab4a597510fa13efc96d4de744c2062134e64a88d7d4804cc594aa868af30b78becd18129ca11205de68c3a72944039c39b1d661624138654e95fcc0321584df7753541dde768dc5590b8e205306b8286788b49d44644fb208650c222e44dc934fb7ea60d4750afbaef988ff0f6e1fbf3350022d8e905a964dd05448ccb5dfe254c78a9a9a3e613982cdda3e75b7c35aa18927475e2aa9e2bf3331c23929ae22512a26a63347327abd71dfcf94e55b4cae79915d7f85de79d68bdec3e0f23d3feaf4f328b41fd31ea3969258c7acff70d6afdc79878945880b32b2e8d553bfd837d6885036aa92ee94b95faa9907b2c03b7ef6f6861a6d414a7bfe53d753c9fd5de863b7bc2fcb05ffced473ed326186afe625a69c4de225a3b604e082ca6def7c74c83a561ea2a04256f4a0b9e78635d7d6542272cc88fc1d523ee521df86811725558173e71c0a75c465900278c91950e5d403600a400d5bfa1e9ba42c872766a4a3dd1b4748e66536543295882dee3f1ebe37ff7f0c0744afb0fceb72839d82f6750d8f713a1caa81456b24331114b2f23fd378e8b2313d8802c71c34b7610a2252b3f6bfa769d233983907afa76dd668979425418f9ea637d4da559bfe8603bb392e3a8cc6736d22cc92d63376efc8ee5fc579b14532d8290e546cb839fb5a1e15b6a5f301c1c020d7348d13e7567f5abbbc7d6a4215ae9b9d1491db03bc4ca62c8e4b259164fbb2d57b626a63d39c3c07a5f6868513c38e7193920939e6937ed709cdbc713dbbf79f9030c4d0aeb19d119f3439af141327c65b2dd12bdeea5c796ce8620cc7b71cc331d131eef1053e21254eb11909c03507936dc369476a97a8b82b0bc46bf336d0e553b923efeb1cc1e7237afe648d7ab28e36ec992062479198d31c9abea2a5294334ff44a843b989c2db6c97c5013a45f47fd921165a500d88329eba7f3263294ebb4ff540fdb71a52eeec7efe91e8f5cb849bfa4820a9b31b3a83c4bba7f5eb120a098ccd803f5a727afe89099a871b754748a192559c402ceb6b9c337426508d82eacc59ce5f509468830f637a4f456d496c850d1992a387fd9453a0ec3c0c7b500a80f2f2df4479c76c10e9e317b45db6cae8f5b9aa9ea5d071ccb0677699a4461ad99d77c6dc9692d4a304b4d29c9f1010f6c3e32fcdc43bdd0d05923053d35da1125c0d9df4ede2b4061c1ab9206543ab535049e80e1f6c96c73d43fd49c56a367926118c760b5904679954aa1bb7f53a6c04847a556d2259d956e702cc3b2ecaf4912b6bbdb7a59fcd948127c293a980f8296ba53f0731df7e33555b1d547ee9279d84e9cb1305bf6a89ecba9b6ea4ee78c0a92e15f63c4f852674278620fb6c4b45f89bce96223000083b073e56e2025464838c2fb9822891694ad9fe8501c0d787b097339a20adabe5c863226f113d148ff99e6f37e102f4603a9f2654a0c98b7fcac61234712732a3c870709a55bd965ba671411be4ce671e845e2c81c571af06c2729b6d814be9b20092d1e6aea15a62feed6c120081025fd95c2d4050b7b5803856754017eb3c90ab4480100af5473ad8635de5236bf1f90dcca47f79f0ca2dc2a5876c67f7277dbbaa3b6c2f84a3151f2b53782d58b6a5a1e2e6aa530158bb0e3469ef6b155535a1dc4b79e52caf37521f15d55d23bbbae2277f62c0d0c8aad43fa908b8c208b00032b478756ded5ff037b50695d46cc2b143c9d532b1f60f598da4784f8e1bc12bdefcfbc82f4bdc3b1c5bef6f31e841bbba2fc30d2a5e5e266984dda22fc0dcf338ed468615cb6bce59f195e21967afba47e3afb3835f720f66ef0d942c0f93136268d2e4f9786c6373dd1676a018fbb9e96993c17aaafa72819ac6e96eb7b72dd53b1a4de6ec8d9bcea413870169fb3e75685e855dc35e172318e408b90c96e7716fc37bca5e8256567dbac0600587f835d6c7730ffc64585aa9f1d8b1e26e6b6eeac306586159429bf523814e4abdc0a2a6603f891207e1ad53f174b5da6934a443d340380f5068c06f7662e4bec59d04d1b2783069bf6d28936015040fb639449e5d56f4b48cfd91b62726715b39bc55c9045539542ed92ed04e13c15630f7a948ebe37ef83a95a8296db867c3a7436c7e415c8f3a01c01510b1d8c823a64ce0b2c970474a8bfc051c1d01d51631b523191351c8e991a76b6c9ff5422d53279eeede17ed69982f63776fa2a4103ed953e4800b1ffa877dd16bab94c7ebb20cd9dac573cdf8e90749dd10fcefd6dc039ac8d20798f373e5d9ece522a4e305d56a0f7cd9912ea53a02ee0cf21df58183784a09f722f682f53b232d2b65b07292d30533a800e8a6332a6b9c9c450a63d82ab20816d3cfe13e76f024de930fc03efbe76d82a563124ed6b904547e57f40f074be68608a8c98d7235a700a4483f638453af8513ae82001a0293deea93500a235edb27042db58d01d9e9dd5938efbaf889247041533beb209918a1bbbb2ab2f2dba9f0f05b90fae03b4d3218ea0364d9a23e7bac6614bf5a3dfece9f336f51bf36dacef13a611d8fc564f7f480e5442af58572a3845787b1fedafb1c00476750947e10d42e50c603028b034abfbef288dabfcfb3bc7347ab42b76eb214f5cabf9ba89542dcafcc49a0ae42c5d33fd7d91aaa70534cc39cc8696b04ab81f3c323b39b9f67eac97441f06516bd8676fc07a51fd6305813a8b2c12cac887dfed90c1f295ec066d728caa802306e7a6ad3e91c13f8707794d62f6bd5a11db83a0b57886a6b47657a6631bdb7c9e9e71c02a634b050851cb8481efcf20c07a8b545be5780fcc3e77e8b3feb22831c9e0589a85c66be35b5797a05cbfc9bcae7aaacd95026222c4a606acae04e3b1a89f3242146c17d2da9f340ee7f662d72fa43bf899761e892d3e2f91336c47e629c59dde03ec1323279ed64fbe54cd222361be55db94d4bdc69ab820bf1a1ff7f9879afa95b763563ec514c6c9e9875fba90b45dc6483830d890b7314b1d1a2a7ec70147c19cc46f71d18491bb1046832cd9de2499a9de1ea58f8871d81b9b9dc130ff5732945063348b761a0d5f545a3917a3b57e23d7a9f839334615cdcdc829e285c83f95d52736f638f548206de8d2d69e920c2d2f7f8133d999d6fb08d1b80852d7058ddde227b01e04cd3e6c5c2a843afaad0d9f40e673f6b85f9b36a7b0f8edba176c0d1e712b6442e7813f60c28efdc225313279a6bf5db88ff7cdecb1083e2b5617a3afcccef1b309ad0dc0e8a342db7536248de7a929841b88869d3a06e5d65efac81c405d2915cb1307fdc3e48ed01a2afe50011aae0e8737ff9e02f75c0081d2acc0197b0158d654a95a4cd712c35d56e8cf3f2cb784682af8515410c8e1b549ad3b99ecbbd0e642fb85579e94377f3fbfd0f2fdb655411c6f3432a4267852f2747d32cf19b0319865df33f115b2d9af33a715ccb599a0a564b576988e2f6dd6b619089759963f18520ecdfbb12032f75ac98bcd0e5d915189c8bc933d25374f715c4904445e40d9f563f685d6567f435045a48ddbefe30081f0d8fbe1e1851742db6f9fb838004867d355bd09e155da707849459353585ba8610ef8281bb78eae3e26618e70c54cfa479188522d1e83d628fa683ec6804c8de4faab0bc8c9398fa13fdd3e5690803ce219b98877a61408479380cd71181bfdea13b6c0a9fd80e63402484383adb50296f0ec0b49e789b9b59a47fcd16cfeefbb1c7ad5f7121b361ead18b2894a496deb9de01d5a15565617dbfb3a60ba8f01919809cf1072fdefc1bc126490d1a733bc27a2f9a94f9cf50419a4a3db85eb99fe9dedc92fe7d98e96a1a29b8cb362acef4313703eb5a1383b592b836e07d3a6d3f356e73ef285766a60f11e4f122fde407b030a22bb1998024a983f73770b29d61b4581b41eff325ec725454f3ca04de4787d89cda9c7681c82d1f4c7bb4a96887c290a41a3b6297fc8690dc888c7c84dc0231766d1a22ff5f836dcd78576454ba7099f0aaa866a1726cf637448235b1229d421bf214c1943abca20411f86cc888efbbc50d02a296f7dbb42e2adef5dcdb34814193d6d1e72a4afa8fc576d4e1626bc7770f09adea7d9cbf6bd0706abe338b4e450fbaf3069979ebcb95fb9533d49160e095219cc576196b474d71a7e8d69fef85ad2210b5ffc55a835f5585bee59c3b7bb42808dc85e49e34b9f4930e31a684358791a8883d53b7ae6906591470b1adf555e4e1a925a3d4e7470ffe6b06da9237217e031218a1b2070ebbabf546f2ff862e75efb0b702b900946455cffad6eca5f9b38a1cd64ac5a6712db6201a28cda0d8f0b13e6004dd8a8d4a319b70ed5f46dd3122b1a36911b9df2fcd654aecc5ff9a31bdea6a2c44e33459fdf4a63c3d5e160f60a9bdde8aca0386f4379fe73f885dfca27fe0b29bbc06fca642b2f160ab1023040460f67553de041a57f3bf8625d22ce9ce2811720ad73ca5c3ca2a3113b87ca27653cdbe4fd4a4e0845eca24c9721cb235d769d007d7669ec07831ce2daa210b3617c366bd0155342a5ddefb9726daf5673394a0c048533bd28c037d92cb3b7990c8a2c60da31b5620dd76d727185b6524c897f87c12185d670201e6d72e75b26a8e030b4699ee1d9b3ac3a231d70f9529706706f9901799328773fef1e387d6b9a7f3584e34a35f789e091341ed61f591ed4f9d2268309c575afbc2c0ce42eb50bf9d9fb5275182b8b19ec443c014d557fccb1d227e74c235148b6c3c6e6cb57ee5777ac4d67acda24a3df03b186c3b4657ba7b1fddd299e7c1adb947e429a6c179614e660e2662048cd206e3e62ac147ccd449848dcaecfcaca71d662eedc3ec1fd703f928f65e6bbe535d00543d5f04b1d10c82bf0ace65d24531231ce6626042a1093f9248b41c8c9853f7cd6aa68d66be9dd46816113931c1bdf3d44048d7bdb2a95b280c74a05b36565580f73721194beb93634c79aba7a2c34ce73a9e5ab36918057b771082b14c7d34750d8f3a20f00704e20e7383e6e984f92e366d1d660842402e0ebb8f5440280bff1ce18ea92d78c498573aa8d9bc1e0c8e326429fa5295d69a4ede64934f5a5d7be783ea247cd52220c301119724d3c5f5f076af9319f8fbac6102ebd5623247b3d41e38bdbb1ec70e1171e00f5df2538aa2f83acb1ed6da17f8d448c51d2edf85a1357788f497fbbe3c9057a6e47f3cbffe02c7b8488018a0caeca4ccb0fc5222723059c22d92dd188026541563982c96e9c35b4bdef4e988c1384110c71afba078d37b4f1f012304e78081557bd8679e93f8360a5b8c24d07a5e2d2f43d3636a83a5064b9550cc9c994ec87ea0cd225877dd257e94f139b23997c83b0f933d0c5c4692f9883c326c183b844451715677ffc72749635e6cb38eb36041404128d5f909165f4ef7b53fd60bd65746d7a3858c251be2ab5d4dc16bc48175d6b83459f265e45e049b18e61c2cca37766c95874a0f2e6d20b87723dbb371599c15ffa835e4c7ccc50fa6d4062cc328b08ff15cde9d6908e3a52428543bec5bb04b8a055a9e83f090fd9e8bf689f76216de63154868dc2ffa930ead1683f7d9331bcc9b8dc7eee3a91f2a5a340e691f221140811daafdfb836c23d17227a6a354916ec3e0869d5ca09b52c4c7d82d616ef7f80c690595fba2a2de5dd45032fc2a9d5caaef8514ccc1cf50ed66e5aba9e7ea9175c5c8e15df10e607e31e55c4698b9b23bb6c1dd86b8a5e9b3f8e058c16cc3afb5c99917c2781e328eaeab9fc9d08ba99536236ae8f2ba876c796b9a179ed50a9eb9b91090b611c2ea69b872b812d9943ca8d252fc2cf7eec795d66cade2823a04687fa05ca358585e00094b4b2c0de5267fe500ec7a9762a30d108a757d9d94bd94f837f9dcc5b9db36a47b3afdd56a43c2888052aa5b51c56f3212efb579ddf2c67d14497da0bb36f56b04c181d6108d3c97adb2c714b17010a5fafd680548c4819ef9e0bc15cb73c9d75931d763296de8048bb7ccd6b7496346d449d49f8878ab5d7f506b4618f1b32effb9304441d27336ae42675806bd189bf7c8d195bd9961383982a6250c3e743b5feee46ab14670b7068c9e3db3947fbad06e5a881d66514b25d59918b6d389f5627276beb32c47fbe47cb625a4c5eff948280f85e2bf80f371c30d7fe7bad4095647a5bc866e4a263977d07584e9752182bac0b5b76a36330cc9bfe3fc024c49afb27b0ced383a12ec9ae9a25b796afe9b2b4b46802c84157fb3c92e51aabcb3c0b810f61f22e014f374b838ad6d346382f3e620fad10b3187b649e1c8e5889a421437f029a604ebebaeb0ccbfeec27ac878368b94c70649c5ed9da16757ff5ec97dc01410cf746fb246d461509da24c83fe1a78ca267050f695dd097497fed28772a57064a5471caab99d2b7fc27270e74969d2c4dbd1a90ca53605440dc6b85d8841a2d68a87805a00309ec657765afe4b818e4950fcafa25c612d3fbb3d8995aa9ff685ddf2c64e1e758d12f363c38d19b8ac52610d5734e2707c1ceee85be65f7d4bf144eb35c4f85e4b2a53dcafabf85785389ff14c1aeb2142ff1a05e3455d2a7a7b09498ed032a82e1a91e9f1bff44903640740cc954683c3d4041d3a709670b034546c4afa7c73c1fe71ebc001036439edd7e12b3c04494bc525c72a31ab3f4716a476621d1f32f520efcac3db5eb71acfdd48aa3bbc02eb200d86483fdfc244ca6b04d638b15820cc260d9862ef161e26a0baf90f2cf605cd177d2fe54d494db312cb2fa7e9fc11fa72aab927dc35ee30d5ae2940784f02bf6b6fb5fce86c8622c8c498ed42703ed3de9fe1688fabaeefe0c71bad443873ea5662359d445f2bdd22a38e1a076eb5b1ada02ce70001da67f7dae44e93b6e6e5654350589e82deee9c4137b67fa21b82c21f336c41af739fc61998e68de6c2ba75e2b7aaa58aee0141ee47b1d657ca7f767fb37cb7a474c4324c998d70070d3683a8af77f59c1b998595e16c3453a288a64aad171088a1caee623584e0e29e6beb0c650a257c317fbf7b345569c26ffbb964b0c3171b33e02964c060dbd92425734970958a809b3daa57affd08504e260d98a06003f2630f369c0d03ea0aed8d9101efc894a3f376652b769dc2e06442253d90d532e2661238b5374d812b83f964e659b60338dd2ef0880acef1a81ab03a96b2f531c6c93ee1699a5fabb3171f822f35eebb66eb55b992e31e488897b69919bf2355ee067117b96515991701e9785ad95f132b981451ee0a665625f4c72040ae5ea0389d54dc8db90a71e593a02c3fcb587d69a0a9c42e09388c68e810695e91e1e91ff52519988655b16214c1bed77f4f6efd0cc6bc48babadb559dc87ddd2db54c3a1b3af3455596734e36b9a059ea37be0586204fb3c6f09f5a059cd25631f77b8be790ad62bbad8278f93464b80c4c3e53782ffcb228e2fa512205f99c2b94642a4243071ec695b2bd291d5201d151a4f85ef7e0703c4de47ed8f9417e6c63c406701e84aeafdeff2ba21f3372fe0e7d40b11ede960c0d757141796bde35c47c92e2032917c22cd83da286a8bb830c16cac59c1d31a08242b676fe015abb734126b88662536aac31ad98f67ef5ac98d868db874821f05ed2cfe163b2d1a2bde04a182329f54105a290342406d1aaaa18939b11d6958999f60ab216f3e106cde5df27ef060b94c14a1c493e919b6c2dae7772428fb9ac5204e7ee5c5e85297c348d5842ee6ed016aad1897eabbb5319f9fd44724df5eaeb1a0ae662cc5a7f1ff52839098d04c06092146cde0956c4b971fb5647d31a9827e81ab8af9eaca6c520d55d1e329f79565ff6308d693b8729e5c34b9ed184964bdc33fa5fe8e6808331a6c5f0920283a4ddadb83358bad9e56552f18ce5bb0a6558983b37c76c3ee53344d4931ef569048f434f587b33522e606bdca3e90103f519f1877747ddffd38ab51c2983bd7499217eed3a7b7c1eeb5e691b3766b30d83d6f73aefb2fd05ea577cf312ced63f38c9d045295bdae11a8cfcdab7dcfc207b69213aeedfd844911169040b40b1769393c1b4fadaa11325e5a6911035808d125687f306bbacd9538630a3bfea85a0b57bdebe5fc9b27d783c11a3d7ede2215670737b07080ed2658c4019410b8f4ae401c2ae2fc48bf0b7a3b8eb726e81b7aa7d2e1d7e4903c746e0ce3013f53fa1be1049e393fb62c7d43bc27d7444100ed8879919003df5acf44a67a8bff6efe0dc49278a698cb4e205d10970c1854e3f50b7f3e84bdd0c03af6691d7c84edec63177955122a4380f4c3791a71a843e344e79ade24f8ae8925fd8f5053738639e6548622116b0e03bd99b46356594f33dcdad267475e56290cf93ab5ed4ccc5f6dfe7dbd475e7342f773495cd499b1241905a23f949ad14a3ea35930193243be20b6fa299767335712c4e10ae28bd606dc644b57d86b5ad064d5bfb98b4f26d539fa1c5b88dc4dd79002a027045bfc4d46d1c24e55ad65cd9ed115bad529f21a31cc266b062dd9ecd88d85fae2b2444e5a44ea0c9a835e1dd88b3fb323fbd5d0f0590c23fe862e6f248ec43780581c4b63b17e4ffa1dab55bac8a8ebf3651ce2ab16d7686a535bcdbf76fbcda07025918b71f669eec724ad8b1c40dc83174f0952243a128d492a772c194e59b1f544f8e47960f989e7236678c4f008d03e9c68fd198fc75df495a9f151a4cfc886a041514c9d50d457fccc7fe42be4eae11ae3ba949a74e63a2e5f8856aa7bf8e926d4b9ce84b5f93d6e83e89d213e72ae43b5ce121f121683e4c536d09338982ef49f9439be3b225070da6209ab2e4f29913ce8db3ad3a51e19eb8a6c4617f60264900cebfa419346230fd482ccf56adb9e4f808fa907e8d0602e1f96e8dd5aac48040810b8cf1eda4020d4a2283db1014432ae6a59693f5fd96927215b6f461e5a640e91d1623616655d93216edcb1d7e01afeb98ff1d7fa21b1a33a212bef352d46d0978d33ad54e890c48e0005784a43d92bf8f1107d18ba00687f55f852d10a0b56711ef11187cd2111b23d0032ea0206f78615d47a2d245f95db229455cb0abc3340573b142d33ca07a08e2ac2494f3260051606455f82c1bc6213373facbecb3a9c0b0645f79f5e47f7f24b3569056b19c6b84a1f8459b8e3517fbf8122bc2ee6bb4a0af64a0b04265bac76e8e0497e7384f6aa3a693b930aea958779e0d5a56bdf77ff96c6c2595fe5e00d7582c23c00b726228d3d5c9dfd7711cf9a93a4411fc256d92678bc0beb68176b25077eb414d1f4275e420e4f9a5ce2690ccc48aba3368c79f021fe038ddc0ad34e82fd155851c910b66b64f9706b8ab40b447e7b8341b894d7f950269c27f4186a6fb7adcd7b7099d83992c2a1e87330fda70d7c52c51176356202645cc2f6376800d7fd18291db96566b152d6d7fd4a3b9d446bc3dae6a59a87a8138865bb2ec416bc8edb33094909823cf7c81ec95946f92548c3f61467ca1cbd58830f79c98265261d603b6c44eb9cd7b139760cb287c2e363cccec7cfe760c4c0ebc5ed4abead18d16c3a54d3e27df7a12842b5a31c3c4f167fbfeb2b769a12610222f47ee280e003bda9e7e98b7028657b4e003fce92654abfa04f17ee8baef001dee45d77535e2fecd5c1cd48dc1973876d4c52ffd2fd59d632c7509267faf5988e5f1ff4845381a341ca5f7bd6fdff465605ef50656a3ab83e5aab26a0c419d35f8442a2d0c92a8f60e70a0348933561c2c1e289eb9d9613b531e1289dd804d5cd74b17462add7de593d373a6919a4d61f8f616465ca9603af7ce139772c697db0004b2b52d49415d8e35e4c57c6b4700d610c7d1d3922b8976dc90fc366939146b77954b1d357501baad00e34b2c3997d2efa7a682be9bcaee6f0e6e45e121a7bdf5d8309d07d4ecd893da419086c8a577d811d674ae0784d644783ef378719e414a92e9dd70c62fe535798fdea4fea3b4879b561e4c989b83bdaae59d2a8747b0989cd02d350ff093e01fc2c8cd995caea297658815c3909560ef778ed6f95b77bbf0a54ce05b7d3cd230706a85b0eea6b0069d414a437a9c282a629a40093bf3969ba05285d3e1a9234180b5707249b4389115ff70478c08cf6e1cfbb5b212b82084f8b9b84fb4c58c472e0e1e918570b1bce4fc652091d4fe242dc81b3c1f32b21bb4d0b9a19eaa65bac6d1980306d33771876b2223369eac6b92d65f4e6fdcf8dd0bec9b04d9426564ab30d3a3c0f7766e46d687d898be444eaff2ee5f8d9eda82ffbdd29d09648f9be8730feaaea5f22526eca564b9578281cff88cd4e417b18d95878b7c3fbecb500ed7422911d18f99b9ffaabd56d6a5139c7c0b51ec72689af1121791d44dea6878aab2ac59bd9695e48dfe42419d30de6869d468fc249a22eed5e89af0830121b46377f3283a8d8485fb42dddaf8a3929d4bf17c0ff424d70eb00814a44dac494d335325c66b06ec424aa498b79428253f297c729d1ce220437589c2ec344490cbec4f3791e72c343a99139584b7b8124b9d158206457f6097077ed152f4b6c4b585872c8d3ef4932f6a229034c4f0cbc80abc38c1393d295cc318662e15ad8852681b9c1f00a3a66be657f6b7df017bf46b8f0d82285e870482c994a5913d2ee6eff40181c37cc62e3e3e22dd7732c375da6542eea07944c320edf3b6f424c6ea30c1aa2abff86b465c2353345e8fd33f2359a0c4bb0b268275004f6f6619b176a74ff2ca33c213e9948987700fe6855110e1a7adc8f7dca7ec00aa0fc8c28e8f01495d5958e3519797847236879d0777d1a515ac2f71dba4b9de2497c90f88b0bdb29567729b63d7e8a60c64658700ae46a017853763e5b7431e5f10c16383d6591bae950fab9949d2933ea57f030489f1cf3acbd2504282b21645ca69edb29839a39b7ef8a3beb12cf532ad66d015bcaea25facdf086876b6deb00fb48c2521d7cbf1854f21715b3efee6574eec7f5f62f160f6a8da57bcf628089955e4227d96e30b443b8e1c59222459b2ffffcc1f92a2e1d3cb776d69acb0129efd8989f5f600ab8057a06e2a0fce0307bfa56f52b8f5237338e11a37a0232aff12c47a2885c82676fe632919daffcb84f62eaafeea9c7c9175d81a3147d306679eefd4afe3da476d314491995783fadf771351d0629c6e2ddd14ba065686758d13c994bc32e01e7e7f0247cda9137a66f521c6dc23a33e4ae1848481fee7820e597c107330b4b39f7989c276ce2f018e6035ab2e4d96ef35ba9af11d8e7e90b1e5fd85c41a3ab9301ea8513f40ae5408c7db7691d63e1f85b834010b19e2b63f820ae2f23f297a35dea74359f439c0884f83b4e2092519bdd0a1307301059492686f28f93a39f5ccd24c8324989e43f2cd56cddaca80d37ad6ae1a285f796f2b040de77dd2f2e34468d0dfb8ccca155571855e42bc32ed599a5427e638c87172eb6ac470e4adc775eb62bea7a8746b89059f78d3283035d492d51f52d53169cc796ffe7452f1b90ee1c0b7d9647025966946a0e2c74a5ddac467c432a13e912ca4445be3c17744660cd88ec88afab71dce91583be66a2b2c3e857bf95c4704b948e14eb075e8bdb09772c2e58a76e4eb2cf97cd0ce6b0fea1d27e1f66a01e8821c436237f50c5d916e066cfe954224d49cebfab0bb50a77251f0c3836b330eef0706b259dd237e5cdb781e5f98b2c1767b52f3496fba62d04b0d8e7bd1cf1fa35a7aa8f7ed86d1bfc95dc7ae5ba6d07874a54c0728751ab8bc26873474c02803f2b646f343c8454e94feeca82c27ed57f1ba54253dccb1ff5800bc9c773de7fa3312eda6c61a15b92ac7ecfd7d374708b63c01b89f807c05ab90ce864369ccd0d03515aca39dd415666d6bac5bd8436823adb1e0d4db6a9f90f393c0735f865bfc75702c020df9a60e34a61101de67825549091da6f95de98f6a40dd11b80a3c6e095806db7e0e16e4b6ae67af59e9c612b1f8611c308a00a0bdfa95df8dbb32aad8437682f9454e373975142ccd4d1ddca1dd60e242dd5c67c9c6f92706f447f8d9ade16850d0d3cba63d4663d45e6c88d7e798651374605fde80fd7f15f6b0bae67b2f4de334dfb10bd7d66d33daccdc2dd9a4060cab2dd2974da07271de663f4e7d03b6685b1b2d1fadb28545bb2b962cbed5e5b06ac755892149a4d013b89251e55221aa93362f19a1482dd3ad772d78ff2d31702f7d8f115f8b24e0c78c9f4c8ad8112b01f672d4292beff2ee16b76dc24849632f92b825cf5f687881e8bc7ca70492e8c2ca3f754fa20804cc31f35b7666f2631342cadc153b0ddf3e91baf944cdd77a7a45110c270ba972a292c7ae3b9ce3104378c1659ffbdd506babef61b8cb0cd1cc40f132bb171b0cff60e38a89da6cee3978447bced887b6b3d42184ad8829f4ac9bddd942d6a97c28047166f5fce906e2a50e3168b0790ca18fda989498e678876e66b226987a6e6ca449c3a2372f7a630fa488a54726e68566492d51144bc2949b3e9a17dc46635940c83ebdc0e500c9be8c7eb1efbe37f2f434a0836383ac64bc26c5ed45df3d9a762dce947778e3f51ddfb210592863ad607ae8833ac7f8ae92aca898b9b560b806bedd569066f660da6fd568969929aa0ed8e86935614cda9e37fe32c89114e568619fa24c59262377675970616684db850b72ef4dca0ee116cea4c4d4ede4fd9aa3acc0eea35e21cce5230a0d18b2ba984f0a8ac81def8728dd01d95c697eeee2d5c6dece61ead4359a0cd9b04254d9858b4fed61b9db7ac290099c1fbd7a15bed4291c33798d37f7a1e63da4c2803fe86c80f3484f518c1d5769236f30dcdd75eb98149c418bb8bfbf31b66371e6017582564432487a974de7c5b99a0e7bf6d838c0eff5773fcaff6e42a7f42a1e7ac5f7c8a0ffb2b48696d35c3a5738b366a9855dbb07db70115c9d10a465facc5b7f52c9fd4550bcbcf8433ace68d257c98fd995d807b6830053766906d04648eb17eac8ab34361045256a29659c794371c749f61b584401bf3a9d30e99fea0807218051400d9cb50185cf957c481bf39857b47f4f6a72aeb4bfee1b65c7e8506943334aa0fcdd9284084ddb805bbaebc984fbaab377e60fc0ddb213ad0c7d417a7bc3abcb6054fb46396e853270f471d53b0b26e6628d3598b9f36f0595709116ac57f44ecefa84b61925eaf4e460a79b4b98b8ee6c166cb765a0b6ffd1b6d4eddc954ab6fc74a8ba6632a56d02a8717cad2be2569c05296af427ba2ac3fba47688fe02ad2cf6d983817240c849ae67038119e20c6af984e34433bd3744c36fe31d2893c268239317eb19811e04ead8cd07bf4ec14e530ff5a4bbc54d41108a52fe666291c38408b36fddab4202c51810573dd36010b4aa1f22f960411b76600afecd181750c6839a7eef74b53cf43b27eb8328bab0457f5e620512980a2ebb443c2e41c4f13d04535e1f9187ddf3e13832d4ce52599fa1e9fe8589d8e97acf8980f07def275334997b3cb9a2ca9f0dad4d9a8311ddf5f3a1c1eab4def093388a10e970576c78c89f6fc5a20dbc1dba5aecf7d4cd527483b085cef43dcaa7813e4966da831d5895dc79c2449327a8be4a58bc38d9a89395bcc545e39a482ca69219afc26d7758f0a25dba2bdb321cf32f6aca6237385bd111377af9b06e1c151a700d233f19a7e9123c991e7b18b12799086199bb11fdc2b164504a3da11bccd4924b4c1d5093203b4f8047d597a1fc3f8b324c528f1de357c1801e900cacbc9bc2080f24170560df771b2eac5abc7e74001d9b3696710c2521dcd6f76cf8c2711ed4f7ae4504ace648d4f1c35a2fc08c53962ce65</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
    <tags>
      
      <tag>博客搭建优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
