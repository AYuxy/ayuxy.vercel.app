<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2大撒旦撒大事大撒旦撒大事大撒旦撒大事大撒旦撒大事大撒旦撒大事的撒大事的撒旦撒的大撒旦撒大事的撒</title>
    <link href="/2022/09/03/2/"/>
    <url>/2022/09/03/2/</url>
    
    <content type="html"><![CDATA[<h1 id="️"><a class="markdownIt-Anchor" href="#️"></a> ✏️</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1</title>
    <link href="/2022/09/03/1/"/>
    <url>/2022/09/03/1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>9月份计划</title>
    <link href="/2022/08/28/22-0828-01/"/>
    <url>/2022/08/28/22-0828-01/</url>
    
    <content type="html"><![CDATA[<p>7月初开始去南京实习，因为必须要返校的原因，只能早早的回到学校，实习期间经历了HW、现场和远程渗透测试、以及某攻防演练，认识了一些好朋友(•̀ᴗ• )，对安全服务有了更多的了解，对自己水平有了更加清晰的认识（啥也不会 - - .）</p><p>9月份要一方面准备秋招，另一方面认真学习免杀，在过年前达到独立免杀 ，同时学习各种钓鱼的姿势 ◔.̮◔✧，同时刷htb，学习渗透测试思路，距离毕业还有不到一年的实习，希望能在秋招或者春招找到一份合适的工作 (≧▽≦)/</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>x86保护模式day5</title>
    <link href="/2022/08/21/22-0821-02/"/>
    <url>/2022/08/21/22-0821-02/</url>
    
    <content type="html"><![CDATA[<h1 id="现代处理器的结构和特点"><a class="markdownIt-Anchor" href="#现代处理器的结构和特点"></a> 现代处理器的结构和特点</h1><h2 id="流水线"><a class="markdownIt-Anchor" href="#流水线"></a> 流水线</h2><p>在8086处理器时候，就已经有了指令预取，当指令执行时，如果总线是空闲的，那么就可以在指令执行的同时，预取指令并同时译码</p><p>执行一条指令需要如下过程：<br />取指令—&gt;需要从内存中拿出指令—&gt;然后对指令进行译码—&gt;访问操作数和结果—&gt;并且进行移位、加法等其他任何操作</p><p>流水线可以提高CPU的执行效率，流水线把一条指令的执行过程分解成若干个细小的步骤，并分配给相对应的单元来完成，各个单元执行独立的，并行的</p><p>正常的指令执行的时长如下：</p><img src="/2022/08/21/22-0821-02/image-20220821160333343.png" class="" title="image-20220821160333343"><p>如果采用流水线的方式，在取指令的同时可以译码，在译码的同时还可以继续取指令（压榨CPU，让CPU不断工作，提高速度），如下：</p><img src="/2022/08/21/22-0821-02/image-20220821160518407.png" class="" title="image-20220821160518407"><h2 id="高速缓存"><a class="markdownIt-Anchor" href="#高速缓存"></a> 高速缓存</h2><p>除了流水线会影响处理器速度外，影响处理器速度的另外一个因素是内存（即我们所说的存储器）。从处理器向外看，分别是寄存器、内存、硬盘，寄存器的速度非常快，其次是内存，最后是硬盘，硬盘速度相对要慢很多，在这种情况下，CPU的速度很快，这样就需要等待内存和硬盘这种速度比较慢的设备，CPU就无法全速运行，为了解决这个矛盾，高速缓存就出现了</p><p>高速缓存就是处理器和内存中的一个静态处理器，容量比较小，位置在处理器中，高速缓存会缓存程序在运行时具有的局部性规律（比如：判断程序经常执行一些指令和数据）</p><img src="/2022/08/21/22-0821-02/image-20220821160729512.png" class="" title="image-20220821160729512"><p>如果CPU要读取0x10，如果L1一级缓存中没有0x10，一级缓存会先去内存中读取数据0x10所在的页，然后CPU从高速缓存中读取0x10</p><img src="/2022/08/21/22-0821-02/image-20220821160742964.png" class="" title="image-20220821160742964"><h2 id="乱序执行"><a class="markdownIt-Anchor" href="#乱序执行"></a> 乱序执行</h2><p>为了实现流水线技术，需要将指令拆分成更小的可独立执行的部分，即拆分成微操作，比如：加法指令，如果参与加法的数据不依赖前面指令的结果，那它可以完全提前把这加法指令执行了，把结果保存到缓存中，等到真正轮到这条指令执行的时候，再把缓存中的结果写入到内存中</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>转载：CPU的熔断幽灵</title>
    <link href="/2022/08/21/22-0821-01/"/>
    <url>/2022/08/21/22-0821-01/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载：<br /><a href="https://blog.csdn.net/xuanyuan_fsx/article/details/106052513">https://blog.csdn.net/xuanyuan_fsx/article/details/106052513</a></p></blockquote><h1 id="自我介绍"><a class="markdownIt-Anchor" href="#自我介绍"></a> 自我介绍</h1><p>我叫阿Q，是CPU一号车间里的员工，我所在的这个CPU足足有8个核，就有8个车间，干起活来杠杠滴。</p><p>我所在的一号车间里，除了负责执行指令的我，还有负责取指令的小A，负责分析指令的小胖和负责结果回写的老K。</p><img src="/2022/08/21/22-0821-01/image-20220821125419547.png" class="" title="image-20220821125419547"><p>CPU的每个车间都有一堆箱子，人们把这些箱子叫做<code>寄存器</code>，我所在的一号车间也不例外，我们每天的工作就是不断执行指令，然后折腾这些箱子，往里面存东西取东西。</p><p>由于我们四个人的出色工作，一号车间业绩突出，在年会上还多次获得了最佳CPU核心奖呢。</p><h1 id="缓存"><a class="markdownIt-Anchor" href="#缓存"></a> 缓存</h1><p>我们每天都需要跟<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&amp;spm=1001.2101.3001.7020">内存</a>打交道，不过由于内存这家伙实在太慢了，我们浪费了很多时间等待他给我们数据传输。</p><img src="/2022/08/21/22-0821-01/image-20220821125541494.png" class="" title="image-20220821125541494"><p>终于有一天，上面给我们下了命令，说竞争对手CPU的速度快赶上我们了，让我们想办法提升工作效率。这一下可难倒了我们，我们平时干活绝没有偷懒，要怪只能怪内存那家伙，是他拖了我们后腿。</p><p>一天晚上，我们哥四个在一起聚餐，讨论起上面的这道命令来，大家都纷纷叹气。</p><p>就在一筹莫展之际，老K提出了一个想法：“兄弟们，我发现了一个现象，<strong>咱们和内存打交道的时候，如果访问了某个地址的数据，它周围的数据随后也大概率会被访问到</strong>”，说到这里，老K停顿了一下。</p><img src="/2022/08/21/22-0821-01/image-20220821125634033.png" class="" title="image-20220821125634033"><p>我一边听一边想着，小A倒是先开口：“然后呢？你想表达什么意思？”</p><p>老K继续说道：“咱每次数据都找内存要，太慢了，我寻思在咱们车间划一块区域，结合我发现的那个现象，以后让内存一次性把目标区域附近的数据一起给我们，我们存在这块区域，后面在需要用到的时候就先去这里找，找不到再去找内存要，岂不省事？”</p><p>听老K这么一描述，感觉靠谱，我也赶紧附和：“好办法！你们看啊，这内存老是拖咱后退，但是这家伙一时半会也快不起来，要不咱先用这招试试，看看能不能加快一点工作效率，给上面也有个交代。”</p><p>说干就干，我们很快就付诸实践了，我们还给这技术取了个名字叫<code>缓存</code>，效果居然出奇的好，后来为了进一步优化，我们还把缓存分为了两块，一块离<a href="https://so.csdn.net/so/search?q=%E5%AF%84%E5%AD%98%E5%99%A8&amp;spm=1001.2101.3001.7020">寄存器</a>很近叫一级缓存，剩下的叫二级缓存。一级缓存中进一步分了指令缓存和数据缓存两块。</p><img src="/2022/08/21/22-0821-01/image-20220821130113626.png" class="" title="image-20220821130113626"><p>我们车间的工作效率那是飞速提升，但不知道是谁走漏了风声，其他几个车间也知道了这项技术，纷纷效仿。</p><p>这天，为了业绩，我们决定再加第三级缓存，这次把空间弄大点，不过咱们车间地盘有点局促，放不下，我们偷偷给上面领导反馈了这事儿，想让领导帮我们协调一下。</p><p>领导倒是同意了，不过告诉我们他得一碗水端平，平衡各车间的利益。但是咱厂里空间也有限，不可能给每个车间都分配那么大的空间，于是决定由厂里统一安排一块大的区域，让各个车间来共享。没有办法，我们也只好同意了。</p><img src="/2022/08/21/22-0821-01/image-20220821131713172.png" class="" title="image-20220821131713172"><p>现在，我们用上了三级缓存技术，内存那家伙拖后腿的现象缓解了不少，相当部分时间我们都能从这三级缓存里面找到我们需要的数据。</p><h1 id="乱序执行"><a class="markdownIt-Anchor" href="#乱序执行"></a> 乱序执行</h1><p>随着技术的发展，咱们CPU工厂的工作性能也是不断攀升，慢慢的，我们几个又开始闲下来了，因为我们实在太快了，尽管有了缓存，但我们还是有了不少闲暇时间。</p><p>这天我还是像往常一样，小A取指令去了，我们知道这得要点时间，于是我和小胖还有老K我们仨斗起了地主。</p><img src="/2022/08/21/22-0821-01/image-20220821133410193.png" class="" title="image-20220821133410193"><p>打了好几把，小A才气喘吁吁的回来，“小胖，该你去指令分析了，你起来让我来打几把”。小胖赶紧起身干活，换上了小A上桌。</p><p>就这样我们几个轮流工作，一直保持着三个人的斗地主牌桌。</p><p>没想到的是，没过多久，厂里领导过来视察了，正好撞见我们几个打牌，狠狠的训斥了我们一顿。</p><img src="/2022/08/21/22-0821-01/image-20220821133444813.png" class="" title="image-20220821133444813"><p>“你们几个上班时间玩得挺嗨啊”，领导的脸拉的老长。</p><p>“领导，我们没有偷懒，这取指令、译码、执行、回写几个步骤都得分步执行，但是我们工作太快，存储器跟不上我们，我们等得无聊打发时间嘛”，我上前解释到。</p><p>“干等着你们也可以提前做一些后面的准备工作嘛，不要浪费时间，让生产效率更上一层楼”，领导说完就离开了，留下我们几个面面相觑。</p><p>不过领导的一番话倒是如一记重锤敲在我的头上，对啊，我们有这打牌的时间不如提前把后续指令的准备工作先做了，肯定能提升不少效率呢！</p><p>我开始组织兄弟几个商讨方案，“兄弟们，我们最主要的时间都浪费在等待内存数据上了，如果我们能在等待的时间里把后续指令需要的数据提前准备到缓存中来，那可就节约不少时间了，不用每次都等那么久。”</p><img src="/2022/08/21/22-0821-01/image-20220821133557943.png" class="" title="image-20220821133557943"><p>老K听后很赞赏我的思路，并补充到：“<strong>不仅是准备工作，像有些指令，比如加法，如果参与加法的数据不依赖前面指令的结果，咱们完全可以提前把这加法指令执行了嘛，把结果保存在缓存中，等真正轮到这条指令执行的时候，再把缓存中的结果写到内存中，这不也是节约了时间吗</strong>”</p><p>大家开始头脑风暴起来，原来可以做的事情还这么多，之前光想着等靠要，现在要主动出击了，因为打乱了顺序提前会执行后面的指令，我们把这个技术叫做<code>乱序执行</code>.</p><p>“这次大家要保密哦，不能让隔壁车间知道咱们的这次讨论内容”，会议结束前，我提醒大家。</p><h1 id="分支预测"><a class="markdownIt-Anchor" href="#分支预测"></a> 分支预测</h1><p>按照这次会议讨论的结果，咱们第二天准备实行，不过刚一开始，就遇到了麻烦。</p><p>按照计划，我们在空闲时间里，会提前把后续要执行的指令能做的工作先做了，但麻烦的是我们遇到了一条判断指令，因为不知道最终结果是true还是false，我们没法知道后续是应该执行分支A的指令还是分支B的指令。不敢轻举妄动，怕一会做了无用功。</p><img src="/2022/08/21/22-0821-01/image-20220821134224810.png" class="" title="image-20220821134224810"><p>大家只好放弃了提前做准备工作的想法，还是一步步来。</p><p>不过很快我们发现，我们经常执行到这个判断指令，而且每次结果都是去执行A分支，从没有去过B分支。</p><img src="/2022/08/21/22-0821-01/image-20220821134335630.png" class="" title="image-20220821134335630"><p>于是我们几个又商量，发明了一种叫<code>分支预测</code>的技术，<strong>遇到分支跳转时，按照之前的经验，如果某个分支经常被执行，那后续再去这个分支的概率一定很大，那这样咱们预测后面会去到这个分支，就提前把这个分支后面指令能做的工作先做了</strong>。</p><p>果然，用上了<code>分支预测</code>和<code>乱序执行</code>后，我们车间的效率又狠狠的提升了一把，在工厂的集体大会上又一次表扬了我们，并且把我们的先进技术向全厂推广。</p><p>自从我们车间用上了<code>乱序执行</code>和<code>分支预测</code>后，生产效率那是大大提升，领导不仅在全厂的员工大会表扬了我们，还把这两项技术向全厂推广，在我们8个CPU核心车间都铺开了，性能甩开竞争对手CPU几条街。</p><p>可是，就在我们还沉醉在取得的成绩时，不知不觉我们竟埋下了灾难的种子······</p><img src="/2022/08/21/22-0821-01/image-20220821135249703.png" class="" title="image-20220821135249703"><p>事情还得从不久前的一个晚上说起。</p><h1 id="神秘代码"><a class="markdownIt-Anchor" href="#神秘代码"></a> 神秘代码</h1><p>这天晚上，我们一号车间遇到了这样一段代码：</p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">uint8</span>_t <span class="hljs-built_in">array</span>1[<span class="hljs-number">160</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>&#125;;<span class="hljs-built_in">uint8</span>_t <span class="hljs-built_in">array</span>2[<span class="hljs-number">256</span> * <span class="hljs-number">512</span>];<span class="hljs-built_in">uint8</span>_t temp = <span class="hljs-number">0</span>;<span class="hljs-built_in">void</span> bad_guy(<span class="hljs-built_in">int</span> x) &#123;<span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">16</span>) &#123;temp &amp;= <span class="hljs-built_in">array</span>2[<span class="hljs-built_in">array</span>1[x] * <span class="hljs-number">512</span>];&#125;&#125;</code></pre></div><p>不到一会儿功夫，我们就执行了这个<code>bad_guy()</code>函数很多次，这不，又来了。</p><p>负责取指令的小A向内存那家伙打了一通电话，让内存把参数x的内容传输过来，我们知道，以内存那蜗牛的速度，估计得让我们好等。</p><p>这时，负责指令译码的小胖忍不住说了：“你们看，我们这都执行这个函数好多次了，每次的参数x都是小于16的，这一次估计也差不多，要不咱们启动<code>分支预测</code>功能，先把小于16分支里的指令先提前做一些？大家看怎么样”</p><img src="/2022/08/21/22-0821-01/image-20220821135655565.png" class="" title="image-20220821135655565"><p>我和负责数据回写的老K互相看了一眼，都点头表示同意。</p><p>于是，就在等待的间隙，我们又给内存那家伙打了电话，让他把<code>array1[x]</code>的内容也传过来。</p><p>等了一会儿，数据总算传了过来：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">x</span>: <span class="hljs-number">2</span><span class="hljs-attribute">array1</span>[x]: <span class="hljs-number">3</span></code></pre></div><p>拿到结果之后，我们开始一边执行<code>x&lt;16</code>的比较指令，一边继续打电话给内存索要<code>array2[3]</code>的内容。</p><p>比较指令执行的结果不出所料，果然是<code>true</code>，接下来就要走入我们预测的分支，而我们提前已经将需要的数据准备到缓存中，省去了不少时间。</p><p>就这样，我们成功的预测了后续的路线，我们真是一群机智的小伙伴。</p><img src="/2022/08/21/22-0821-01/image-20220821140235996.png" class="" title="image-20220821140235996"><h1 id="遭遇滑铁卢"><a class="markdownIt-Anchor" href="#遭遇滑铁卢"></a> 遭遇滑铁卢</h1><p>天有不测风云，不久，事情发生了变化。</p><p>“呀！比较结果是<code>false</code>，这一次的x比16大了”，我执行完结果后发现和我们预期的有了出入。</p><p>小A闻讯而来，“额，咱们提前执行了不该执行的指令不会有问题吧？”</p><img src="/2022/08/21/22-0821-01/image-20220821140404348.png" class="" title="image-20220821140404348"><p>老K安慰道：“没事儿，咱们只是提前把数据读到了我们的缓存中，没问题的，放心好啦”</p><p>我想了想也对，大不了我们提前做的准备工作白费了，没有多想就继续去执行&gt;16的分支指令了。</p><p>随后，同样的事情也时有发生，渐渐的我们就习惯了。</p><h1 id="灾难降临"><a class="markdownIt-Anchor" href="#灾难降临"></a> 灾难降临</h1><p>夜越来越深，我们都有点犯困了，突然，领导来了一通电话，让我们放下手里的工作火速去他办公室。</p><p>我们几个不敢耽误，赶紧出发。</p><p>来到领导的办公室，里面多了两个陌生人，其中一个还被绑着，领导眉头紧锁，气氛很是紧张。</p><img src="/2022/08/21/22-0821-01/image-20220821140529860.png" class="" title="image-20220821140529860"><p>“阿Q啊，你知不知道你们新发明的<code>乱序执行</code>和<code>分支预测</code>技术闯了大祸了？”</p><p>我们几个一听傻眼了，“领导，这是从何说起啊？”</p><p>领导从椅子上站了起来，指着旁边的陌生人说到：“给你们介绍一下，这是操作系统那边过来的安全员，让他告诉你们从何说起吧！”</p><p>这位安全员向大家点了点头，指着被捆绑那人说道：“大家好，我们抓到这个线程在读取系统内核空间的数据，经过我们的初审，他交代了是通过你们CPU的<code>乱序执行</code>和<code>分支预测</code>功能实现的这一目的。”</p><p>我和小A几个一听都是满脸问号，我们这两个提升工作效率的技术怎么就能泄漏系统内核数据呢？</p><img src="/2022/08/21/22-0821-01/image-20220821140718910.png" class="" title="image-20220821140718910"><h1 id="真相大白"><a class="markdownIt-Anchor" href="#真相大白"></a> 真相大白</h1><p>安全员显然看出了我们的疑惑，指着被捆绑的那个线程说道：“你把之前交代的再说一遍”</p><p>“几位大爷，你们之前是不是遇到了分支预测失败的情况？”，那人抬头看着我们。</p><p>“有啊，跟这有什么关系？失败了很正常嘛，既然是预测那就不能100%打包票能预测正确啊”，我回答道。</p><p>“<strong>您说的没错，不过如果这个失败是我故意策划的呢？</strong>”</p><img src="/2022/08/21/22-0821-01/image-20220821140925900.png" class="" title="image-20220821140925900"><p>听他这么一说，我的心一下悬了起来，“纳尼，你干的？”</p><p>“是的，就是我，我先故意给你连续多次小于16的参数，误导你们，误以为后面的参数还是小于16的，然后突然来一个特意构造的大于16的参数，你们果然上钩了，预测失败，提前执行了一些本不该执行的指令。”</p><p>“那又如何呢？我们只是把后面需要的数据提前准备到了缓存中，并没有进一步做什么啊”，我还是不太明白。</p><p>“<strong>这就够了！</strong>”</p><p>“你小子都被捆上了，就别吊胃口了，一次把话说清楚”，一旁急性子的老K忍不住了。</p><img src="/2022/08/21/22-0821-01/image-20220821140943193.png" class="" title="image-20220821140943193"><p>“好好好，我这就交代。你们把数据提前准备到了缓存中，我后面去访问这部分数据的时候，发现比访问其他内存快了很多”</p><p>“那可不，我们的缓存技术可不是吹牛的！哎等等，怎么又扯到缓存上去了？”，老K继续问道。</p><p>那人继续说道：“<strong>如果我想知道某个地址单元内的值，我就以它作为数组的偏移，去访问一片内存区域。利用你们会提前预测执行而且会把数据缓存的机制。你们虽然预测失败了，但对应的那一块数据已经在缓存中了，接着，我依次去访问那一片内存，看看谁的访问时间明显比其他部分短，那就知道哪一块被缓存了，再接着反推就能知道作为偏移的数值是多少了</strong>，按照这个思路我可以知道每一个地址单元的内容”</p><img src="/2022/08/21/22-0821-01/image-20220821141014291.png" class="" title="image-20220821141014291"><p>我们几个一边听着一边想着，琢磨了好一会儿总算弄清楚了这家伙的套路，老K气得火冒三丈，差点就想动手修理那人。</p><p>“好你个家伙，倒是挺聪明的，可惜都不用在正途上！好好的加速优化机制竟然成为了你们的帮凶”，我心中也有一团火气。</p><h1 id="亡羊补牢"><a class="markdownIt-Anchor" href="#亡羊补牢"></a> 亡羊补牢</h1><p>事情的真相总算弄清楚了，我们几个此刻已经汗流浃背。</p><p>经过和安全员的协商，操作系统那边推出了全新的<code>KPTI</code>技术来解决这个问题，也就是<code>内核页表隔离</code>。</p><img src="/2022/08/21/22-0821-01/image-20220821142034063.png" class="" title="image-20220821142034063"><p>以前的时候，线程执行在用户态和内核态时用的是同一本地址翻译手册，也就是人们说的<code>页表</code>，通过这本手册，我们CPU就能通过虚拟地址找到真实的内存页面。</p><p>现在好了，让线程运行在用户态和内核态时使用不同的手册，用户态线程的手册中，内核地址空间部分是一片空白，来一招釜底抽薪！</p><p>本以为我们可以回去了，没想到领导却给我们出了难题，“这祸是你们闯下的，人家操作系统那边虽然做了保护，你们是不是也该拿出点办法来呢，要不然以后我们CPU还怎么抬得起头来？”</p><p class="note note-secondary">    本文描述的是两年前爆发的大名鼎鼎的CPU的熔断与幽灵漏洞。<br/>    乱序执行与分支预测是现代处理器普遍采用的优化机制。和传统软件漏洞不同，硬件级别的漏洞影响更大更深也更难以修复。<br/>    通过判断内存的访问速度来获知是否有被缓存，这类技术有一个专门的术语叫侧信道，即通过一些场外信息来分析得出重要结论，进而达成正常途径无法达成的目的]]></content>
    
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编Day4</title>
    <link href="/2022/08/20/22-0820-04/"/>
    <url>/2022/08/20/22-0820-04/</url>
    
    <content type="html"><![CDATA[<h1 id="and和or指令"><a class="markdownIt-Anchor" href="#and和or指令"></a> AND和OR指令</h1><p>and：逻辑与，按位进行与运算，两个1才为1，不然为0</p><p>or：逻辑或指令，按位进行计算，有一个1就为1，不然为0</p><h1 id="字符串定义"><a class="markdownIt-Anchor" href="#字符串定义"></a> 字符串定义</h1><div class="code-wrapper"><pre><code class="hljs livecodeserver">assume cs:code<span class="hljs-keyword">string</span> <span class="hljs-keyword">segment</span>db <span class="hljs-string">&#x27;ayu&#x27;</span><span class="hljs-keyword">string</span> <span class="hljs-keyword">ends</span>code <span class="hljs-keyword">segment</span><span class="hljs-built_in">start</span>:mov ax,<span class="hljs-keyword">string</span>code <span class="hljs-keyword">ends</span><span class="hljs-function"><span class="hljs-keyword">end</span> <span class="hljs-title">start</span></span></code></pre></div><p>然后调试</p><img src="/2022/08/20/22-0820-04/image-20220902095749648.png" class="" title="image-20220902095749648"><p><strong>疑惑：</strong><code>db 'ayu'</code>，到底存储到代码段cs中，还是数据段ds中呢 ？（理论肯定是存在数据段ds中的）</p><p>这里采用mov ax,string来测试，发现mov ax,string就是mov ax,076a，所以显然<code>db 'ayu'</code>被存放到了076a，根据上图中ds的起始地址为075a，而cs的起始地址为076b，所以经过分析<code>db 'ayu'</code>确实被放到了数据段中</p><h1 id="psp区"><a class="markdownIt-Anchor" href="#psp区"></a> PSP区</h1><p>程序加载后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为0，则程序所在的内存区的地址为  ds:0，这个内存区的前256个字节（256对应16进制0100）中存放的是PSP，DOS用来和程序进行通信。从256字节处向后的空间存放的是程序。</p><img src="/2022/08/20/22-0820-04/image-20220902102015177.png" class="" title="image-20220902102015177"><p>注意：上图中为啥不写SA+0100H呢？？？？而是用的SA+10H呢？？？</p><p>正常来说应该是<code>SA+0100H:0</code>那么对应实际物理地址就是<code>SA*16+256 = SA*16+16*16 = 16(SA+16) = 16(DS+16)</code> (实际地址 = 段地址*16+偏移地址，这里的段地址和偏移地址换算成10进制运算)。而真正CS:IP对应的实际物理地址为<code>CS*16+IP</code>，而偏移地址IP开始为0，也就是<code>CS*16</code>，所以<code>DS+16 = CS</code>，由于这里采用的是10进制运算，16 就是十六进制的10h，所以<code>ds+10h = cs</code></p><p>比如：上面的ds=075a，那么psp的内容就是从075a:0到075a+10h:0，也就是075a:0到076a:0，而真正程序是从076a:0开始的，所以我们查看076a:0就可以看到我们定义的数据<code>db 'ayu'</code></p><img src="/2022/08/20/22-0820-04/image-20220903160907793.png" class="" title="image-20220903160907793"><p>但是这里076a:0为啥并不是CS:IP？？？？</p><img src="/2022/08/20/22-0820-04/image-20220903160916449.png" class="" title="image-20220903160916449"><p>可能是因为<code>db 'ayu'</code>是数据，但是CS寄存器存放的是指令，也就是说CS:IP指向存放指令的地方，而076a到076b这里面存放的是一些数据，就比如：刚才我们定义的段<code>db 'ayu'</code>，类似如下图：</p><img src="/2022/08/20/22-0820-04/image-20220903160925092.png" class="" title="image-20220903160925092"><p>现在我们将程序删除string段改成如下：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codecode <span class="hljs-meta">segment</span><span class="hljs-symbol">start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span>code endsend start</code></pre></div><p>重新debug后，如下：恰好DS和CS差10H，那么上面的猜测可能就是正确的</p><img src="/2022/08/20/22-0820-04/image-20220903160955361.png" class="" title="image-20220903160955361"><h1 id="寄存器si-di"><a class="markdownIt-Anchor" href="#寄存器si-di"></a> 寄存器SI、DI</h1><p>si和di功能和bx差不多的用法，但是不能和bx一样分成两个8位的寄存器</p><p>对于bx，经常的用法为：mov bx,0 或者mov bx,[0]，同理对于si、di也可以这样用：mov si,0 或者 mov si,[0]、mov di,0 或者 mov di,[0] 等</p><h1 id="寻址方式总结"><a class="markdownIt-Anchor" href="#寻址方式总结"></a> 寻址方式总结</h1><ul><li>直接寻址，比如：[0]、[1]</li><li>寄存器间接寻址，比如：[bx]、[si]、[di]、[bp]</li><li>寄存器相对寻址，比如：[bx+1]、[si+2] 等</li><li>基址加变址寻址，比如：[bx+si]、[bx+di]等</li><li>相对基址加变址寻址，比如：[bx+si+1]、[bx+di+2]</li></ul><div class="code-wrapper"><pre><code class="hljs x86asm">作业:<span class="hljs-comment">;将naizi、madou、caiji、linhu首字母变成大写</span><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code,<span class="hljs-built_in">ds</span>:datadata <span class="hljs-meta">segment</span><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;1. naizi........&#x27;</span><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;2. madou........&#x27;</span><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;3. caiji........&#x27;</span><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;4. linhu........&#x27;</span>data endscode <span class="hljs-meta">segment</span><span class="hljs-symbol">start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,data<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">0</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">4</span><span class="hljs-symbol">s:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[<span class="hljs-built_in">di</span>+<span class="hljs-number">3</span>]<span class="hljs-keyword">and</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">11011111B</span>  <span class="hljs-comment">;将首字母变成大写</span><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">di</span>+<span class="hljs-number">3</span>],<span class="hljs-built_in">al</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">16</span><span class="hljs-keyword">loop</span> s:<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span>code endsend start用两个循环实现把所有字母变成大写<span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code,<span class="hljs-built_in">ds</span>:datadata <span class="hljs-meta">segment</span><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;naizi...........&#x27;</span><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;madou...........&#x27;</span><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;caiji...........&#x27;</span><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;linhu...........&#x27;</span>data endsstack <span class="hljs-meta">segment</span><span class="hljs-built_in">dw</span> <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>  <span class="hljs-comment">;设置栈用于存放cx</span>code <span class="hljs-meta">segment</span><span class="hljs-symbol">start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,stack<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>,<span class="hljs-number">16</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,data<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">4</span><span class="hljs-symbol"></span><span class="hljs-symbol">s0:</span><span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">5</span><span class="hljs-symbol"></span><span class="hljs-symbol">s:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[<span class="hljs-built_in">bx</span>+<span class="hljs-built_in">si</span>]<span class="hljs-keyword">and</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">11011111b</span><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-built_in">si</span>],<span class="hljs-built_in">al</span><span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><span class="hljs-keyword">loop</span> s<span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">16</span><span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><span class="hljs-keyword">loop</span> s0<span class="hljs-keyword">loop</span> s<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>code endsend start</code></pre></div><h1 id="ptr"><a class="markdownIt-Anchor" href="#ptr"></a> ptr</h1><p>下面的指令中，寄存器指明了指令进行的是字操作：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">1</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>]     <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>],<span class="hljs-built_in">ax</span><span class="hljs-keyword">inc</span> <span class="hljs-built_in">ax</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">1000</span></code></pre></div><p>下面的指令中，寄存器指明了指令进行的是字节操作（因为是al）：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">1</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">bl</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>],<span class="hljs-built_in">al</span><span class="hljs-keyword">inc</span> <span class="hljs-built_in">al</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">100</span></code></pre></div><p>在没有寄存器名存在的情况下，既都是在内存，得用操作符 X ptr 指明内存单元的长度，X在汇编指令中可以为byte，word或者DWORD。要不然内存是片连续的区域，操作就乱了</p><p>例如：</p><p>下面的指令中，用word ptr 指明了指令访问的内存单元是一个字单元：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>],<span class="hljs-number">1</span><span class="hljs-keyword">inc</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>]<span class="hljs-keyword">inc</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>]<span class="hljs-keyword">add</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>],<span class="hljs-number">2</span></code></pre></div><p>下面的指令中，用byte ptr 指明了指令访问的内存单元是一个字节单元：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>],<span class="hljs-number">1</span><span class="hljs-keyword">inc</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>]<span class="hljs-keyword">inc</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>]<span class="hljs-keyword">add</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>],<span class="hljs-number">2</span></code></pre></div><p>在没有寄存器参与的内存单元访问指令中，用word prt 或byte ptr 显性地指明所要访问的内存单元的长度是很必要的。否则，CPU无法得知所要访问的单元，还是字节单元。假如我们用Debug查看内存的结果如下：</p><p>2000：1000 FF FF FF FF FF FF …</p><p>那么指令：<br />mov ax,2000H<br />mov ds,ax<br />mov byte ptr [1000H],1<br />将使内存中的内容变为：<br />2000: 1000 01 FF FF FF FF FF …</p><p>而指令：<br />mov ax,2000H<br />mov ds,ax<br />mov word ptr [1000H],1<br />将使内存中的内容变为：<br />2000：1000 01 00 FF FF FF FF …</p><h1 id="综合应用"><a class="markdownIt-Anchor" href="#综合应用"></a> 综合应用</h1><div class="code-wrapper"><pre><code class="hljs autoit">关于公司的一条记录如下：公司名称：<span class="hljs-built_in">DEC</span>公司姓名：naizi排名：<span class="hljs-number">250</span>收入：<span class="hljs-number">20</span>著名产品：pos</code></pre></div><img src="/2022/08/20/22-0820-04/image-20220903162344655.png" class="" title="image-20220903162344655"><p>现在进行如下操作：<br />修改排名为100<br />收入为50<br />产品变成amd</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">seg</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">60h</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">8</span>],<span class="hljs-number">100</span>  <span class="hljs-comment">;该指令也可写成mov word ptr [bx].8,100 </span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">10</span>],<span class="hljs-number">50</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">12</span>+<span class="hljs-built_in">si</span>],<span class="hljs-string">&#x27;A&#x27;</span> <span class="hljs-comment">;该指令也可写成mov byte ptr [bx][si].12,&#x27;A&#x27; 或写成mov byte ptr [bx].12[si],&#x27;A&#x27;</span><span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">12</span>+<span class="hljs-built_in">si</span>],<span class="hljs-string">&#x27;M&#x27;</span><span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">12</span>+<span class="hljs-built_in">si</span>],<span class="hljs-string">&#x27;D&#x27;</span></code></pre></div><h1 id="div除法指令"><a class="markdownIt-Anchor" href="#div除法指令"></a> div除法指令</h1><p>除法：有8位和16位两种，在一个寄存器或者内存单元中</p><p>被除数：如果除数为8位，被除数为16位，默认放在ax中，如果除数为16位，被除数一定为32位，在dx和ax中存放，dx存放高16位，ax存放低16位（注意：被除数一定比除数值大，除数是16位，则被除数一定是32位）</p><p>结果存放：如果除数为8位，则AL存放除法操作的商，AH存放除法操作的余数；如果除数是16位，则AX存放除法的商，DX存放余数</p><p>div byte ptr ds:[0] 的含义：由于在这里div后面是byte字节，也就是除数是8位，那么被除数一定为16位，AL存放ax÷(ds×16+0) 的商，AH存放ax÷(ds×16+0)的余数</p><p>div word ptr ds:[0] 的含义：由于在这里div后面是word字，也就是除数为16位，那么被除数一定为32位，AX存放的是 (dx×10000H+ax)÷(ds×16+0)的商，DX存放的是 (dx×10000H+ax)÷(ds×16+0)的余数</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-comment">;计算100001/100</span><span class="hljs-comment">;100001大于65535，所以用ax加dx两个寄存器联合存放，100001转化成16进制为186A1H</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,<span class="hljs-number">1</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">86A1H</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">100</span><span class="hljs-keyword">div</span> <span class="hljs-built_in">bx</span><span class="hljs-comment">;ax=商，dx=余数</span></code></pre></div><h1 id="伪指令-db-dw-dd"><a class="markdownIt-Anchor" href="#伪指令-db-dw-dd"></a> 伪指令 db 、dw 、dd</h1><p>dd 定义两个字型数据：double word</p><p>dup指令：进行数据重复</p><p>db 3 dup(0) 相当于 db 0,0,0</p><p>db 3 dup(0,1,2) 相当于 db 0,1,2,0,1,2,0,1,2</p>]]></content>
    
    
    <categories>
      
      <category>16位汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编Day3</title>
    <link href="/2022/08/20/22-0820-03/"/>
    <url>/2022/08/20/22-0820-03/</url>
    
    <content type="html"><![CDATA[<h1 id="bx-loop指令"><a class="markdownIt-Anchor" href="#bx-loop指令"></a> [bx]、loop指令</h1><h2 id="bx"><a class="markdownIt-Anchor" href="#bx"></a> [bx]</h2><p>前面day2天学习中，我们了解到了[0]的用法，如下：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">1000H</span> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">bx</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[<span class="hljs-number">0</span>]</code></pre></div><p>但这里中括号中的0是常量，我们还可放变量，比如：[bx]</p><div class="code-wrapper"><pre><code class="hljs X86ASM"><span class="hljs-comment">;如果ds已经是2000H</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">10</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,[<span class="hljs-built_in">bx</span>]<span class="hljs-comment">;这个指令就相当于mov ax,2000H:10,也就是把2000H:10这个字型数据给ax</span><span class="hljs-comment">;如果是mov dl,[0]，那么这个是把字节型数据给mov，因为dl只有8位</span></code></pre></div><p>inx bx 指令的作用是让bx+1，相当于bx=bx+1或者是bx++</p><h2 id="loop指令"><a class="markdownIt-Anchor" href="#loop指令"></a> loop指令</h2><p>loop 指令，在汇编里面代表循环，类似于c语言的while、for循环。</p><p>loop 指令的使用格式：<code>loop 标号</code>，CPU 执行 loop 指令时，首先执行 CX = CX-1，然后判断 CX 的值，CX的值如果不为0，就会跳到标号处执行程序，如果为0，就按顺序向下执行。</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-comment">;比如：如果要用指令实现2的三次方，可用如下方法</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">2</span><span class="hljs-comment">;ax=2</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">ax</span><span class="hljs-comment">;ax=2+2=4  </span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">ax</span><span class="hljs-comment">;ax=4+4=8</span><span class="hljs-comment">;但是这里如果要实现2的12次方呢？？？用上面的方法一直加下去就不太好，这里就用循环实现，用如下代码实现</span><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codecode <span class="hljs-meta">segment</span>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">2</span>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">11</span>    <span class="hljs-symbol"></span><span class="hljs-symbol">s:</span>  <span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">ax</span>    <span class="hljs-keyword">loop</span> s            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span>    <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span>code endsend</code></pre></div><p>对上面2的12次方debug下，-u后我们发现ayu.exe会先执行mov ax,0002，然后再执行mov cx,000B，一直向下执行下去，然后到loop指令的时候，会再跳回到上面的add ax,ax指令</p><img src="/2022/08/20/22-0820-03/image-20220830212722071.png" class="" title="image-20220830212722071"><p>然后我们可以-t来一条条的指令看下</p><img src="/2022/08/20/22-0820-03/image-20220830212728134.png" class="" title="image-20220830212728134"><p>注意，上面的第二条指令<code>mov cx,000B</code>，这里000B实际就是十进制的11，也就是源程序中的<code>mov cx,11</code>，当然mov cx,11也可以写成<code>mov cx,0BH</code>，这里必须是0BH，不能写成BH，在汇编中数据不能以字母开头，所以在前面加个0</p><img src="/2022/08/20/22-0820-03/image-20220830212735344.png" class="" title="image-20220830212735344"><p>cx存放的是程序（机器码）长度（字节数），一共15个字节，也就是十六进制的F</p><img src="/2022/08/20/22-0820-03/image-20220830212744246.png" class="" title="image-20220830212744246"><div class="code-wrapper"><pre><code class="hljs txt">作业:编程，用加法计算123*236,结果存在ax中123*236就是236个123相乘，即123×123×123×123...代码如下：code segmentmov ax,123mov cx,236s:add ax,axloop smov ax,4c00hint 21hcode endsend</code></pre></div><h1 id="debug和汇编编译器处理指令的区别"><a class="markdownIt-Anchor" href="#debug和汇编编译器处理指令的区别"></a> Debug和汇编编译器处理指令的区别</h1><p>用debug输入如下指令</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">2000h</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[<span class="hljs-number">0</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">bl</span>,[<span class="hljs-number">1</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,[<span class="hljs-number">2</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>,[<span class="hljs-number">3</span>]</code></pre></div><img src="/2022/08/20/22-0820-03/image-20220902093058566.png" class="" title="image-20220902093058566"><p>然后用编译器编译和debug如下程序</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codecode <span class="hljs-meta">segment</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">2000h</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[<span class="hljs-number">0</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">bl</span>,[<span class="hljs-number">1</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,[<span class="hljs-number">2</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>,[<span class="hljs-number">3</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span>code endsend</code></pre></div><img src="/2022/08/20/22-0820-03/image-20220902093112633.png" class="" title="image-20220902093112633"><p>那么，我们如何解决上面的问题呢？？把代码改成如下，添加上段前缀<code>ds:</code>，然后编译器就会把[0]当成地址处理了</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codecode <span class="hljs-meta">segment</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">2000h</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">bl</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-number">1</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-number">2</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-number">3</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span>code endsend</code></pre></div><p>或者用类似如下的形式也可以mov al,<code>[bx]</code>，中括号里面为变量，而不是常量0，如果要用ss段寄存器，那么前面必须有<code>ss:</code>[bx]，而默认中括号前啥都没有就是ds寄存器</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codecode <span class="hljs-meta">segment</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">2000h</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[<span class="hljs-built_in">bx</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">ss</span>:[<span class="hljs-built_in">bx</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span>code endsend</code></pre></div><p>注意：我们以后写代码用200:2FF这段空间，这个空间是没有用的，向别的内存空间中写入可能直接会导致死机或者其他的事情。。。</p><img src="/2022/08/20/22-0820-03/image-20220902093157911.png" class="" title="image-20220902093157911"><div class="code-wrapper"><pre><code class="hljs txt">作业:将内存ffff:0到fff:c的单元中的数据复制到0:200到0:20c单元中，注意：0:200到0:20c等价于0020:0到0020:c，因为合成后物理地址都一样assume cs:codecode segmentmov bx,0mov cx,0CHs:mov ax,0ffffhmov ds,axmov dx,[bx]mov ax,0020hmov ds,axmov [bx],dxadd bx,2loop smov ax,4c00hint 21hcode endsend;除了上述方法，还可以用es这个段地址寄存器来实现assume cs:codecode segmentmov bx,0mov cx,0CHmov ax,0ffffhmov ds,axmov ax,0020hmov es,axs:mov dx,[bx]mov es:[bx],dx   ;es不可省略，分号是汇编的注释符号add bx,2loop smov ax,4c00hint 21hcode endsend</code></pre></div><p>上面的程序中是只有一个段的<code>code segment</code>，也就是代码段，但是有的包含多个段，比如，同时包含代码段和数据段，那么数据段肯定要在内存中占用一定的空间，操作系统就会给数据段分配一定的空间，注意：操作系统给程序分配的空间都是安全的，因为操作系统不会让一个程序所用空间和其他程序或操作系统自己空间相冲突</p><p>程序获取所需要的空间有2种方法：</p><ol><li>加载程序的时候为程序分配内存</li><li>在程序执行过程中向系统申请（c语言的malloc）</li></ol><h1 id="start用法"><a class="markdownIt-Anchor" href="#start用法"></a> Start用法</h1><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codecode <span class="hljs-meta">segment</span><span class="hljs-built_in">dw</span> <span class="hljs-number">123h</span>,<span class="hljs-number">0456h</span>,<span class="hljs-number">0abch</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0ffffh</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span> code endsend</code></pre></div><p>编译，调试上面的程序，我们发现并不是从mov ax,0ffffh开始执行的，如果想从正常从mov ax,0ffffh开始执行的话，需要加上start</p><img src="/2022/08/20/22-0820-03/image-20220902094335774.png" class="" title="image-20220902094335774"><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codecode <span class="hljs-meta">segment</span><span class="hljs-built_in">dw</span> <span class="hljs-number">123h</span>,<span class="hljs-number">0456h</span>,<span class="hljs-number">0abch</span> <span class="hljs-comment">;定义字型数据，数据之间有逗号隔开</span><span class="hljs-symbol">start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0ffffh</span>  <span class="hljs-comment">;这里的start可以定义成任意名称</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span> code endsend start</code></pre></div><p>重新编译，调试，就是从mov ax,0ffffh正常开始执行了，并且我们发现cs:ip变成了076A:0006，偏移地址ip变成了0006，恰好我们定义了三个字型数据，也就是6个字节</p><img src="/2022/08/20/22-0820-03/image-20220902094608872.png" class="" title="image-20220902094608872"><p>查看076a:0的地址内容，就发现了我们的字型数据</p><img src="/2022/08/20/22-0820-03/image-20220902094810500.png" class="" title="image-20220902094810500"><h1 id="定义栈段"><a class="markdownIt-Anchor" href="#定义栈段"></a> 定义栈段</h1><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code,<span class="hljs-built_in">ds</span>:data,<span class="hljs-built_in">ss</span>:stackdata <span class="hljs-meta">segment</span><span class="hljs-built_in">dw</span> <span class="hljs-number">0123h</span>,<span class="hljs-number">0456h</span>data endsstack <span class="hljs-meta">segment</span><span class="hljs-built_in">dw</span> <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>  <span class="hljs-comment">;栈的内存空间</span>stack endscode <span class="hljs-meta">segment</span><span class="hljs-symbol">start:</span>     <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,data<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,stack<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>,<span class="hljs-number">10h</span>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span>    <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span>code endsend start</code></pre></div><div class="code-wrapper"><pre><code class="hljs txt">课后作业：1.编程向内存0:200~0:23F依次传送数据0~63(3FH) 备注：只能使用9条指令 包括mov ax,4c00h int 21h解答：assume cs:codecode segmentmov cx,3Fhmov ax,0mov ds,axmov bx,0s:mov [bx+200],blinc blloop smov ax,4C00hint 21hcode endsend2. 下面程序的功能是将&quot;mov ax,4c00h&quot;之前的指令复制到内存0:200处，补全程序用debug调试，跟踪运行结果assume cs:codecode segment    mov ax,__cs___ ;注意复制的是指令，指令在cs寄存器中    mov ds,ax    mov ax,0020h  ;注意：0:0200等价于0020:0，合成后物理地址一样    mov es,ax    mov bx,0    mov cx,__17h__ ;这里为啥是17h，看下面解析s:  mov al,[bx]    mov es:[bx],al    inc bx    loop s        mov ax,4c00h    int 21hcode endsend  3.编写code段中的代码，将naizi段和madou段中的数据依次相加，将结果存到feiwudidi段assume cs:codenaizi segment db 1,2,3,4,5,6,7,8naizi endsmadou segment db 1,2,3,4,5,6,7,8madou endsfeiwudidi segment db 0,0,0,0,0,0,0,0feiwudidi endscode segmentstart:   ?code endsend start解答：assume cs:codenaizi segment db 1,2,3,4,5,6,7,8naizi endsmadou segment db 1,2,3,4,5,6,7,8madou endsfeiwudidi segment db 0,0,0,0,0,0,0,0feiwudidi endscode segmentstart:mov ax,feiwudidimov es,axmov bx,0mov cx,8s:mov ax,naizimov ds,axmov dl,[bx]mov ax,madoumov ds,axadd dl,[bx]mov es:[bx],dlinc bxloop scode endsend start4.编写code段中的代码，用push指令将a段中的前8个字型数据逆序存储到b段中assume cs:codea segment    dw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fha endsb segment    dw 0,0,0,0,0,0,0,0b endscode segment    start: ?code endsend start解答：assume cs:codea segment    dw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fha endsb segment    dw 0,0,0,0,0,0,0,0b endscode segment    start:mov ax,b    mov ss,ax ;设置栈    mov sp,16 ;设置栈偏移地址 ;10进制的16        mov ax,a    mov ds,ax    mov bx,0        mov cx,8  ;控制循环次数    s:push [bx]  ;入栈    add bx,2    loop s            code endsend start</code></pre></div><p>第2题解析：</p><img src="/2022/08/20/22-0820-03/image-20220902094927400.png" class="" title="image-20220902094927400">]]></content>
    
    
    <categories>
      
      <category>16位汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编day2</title>
    <link href="/2022/08/20/22-0820-02/"/>
    <url>/2022/08/20/22-0820-02/</url>
    
    <content type="html"><![CDATA[<h1 id="内存中字节的存储方式"><a class="markdownIt-Anchor" href="#内存中字节的存储方式"></a> 内存中字节的存储方式</h1><p>8086 CPU是用16位寄存器来存储一个字，内存单元是以字节划分的，如下：0,1,2,3， 0,1两个内存单元存放的就是4E20H</p><img src="/2022/08/20/22-0820-02/image-20220830202004406.png" class="" title="image-20220830202004406"><h1 id="ds段寄存器和address"><a class="markdownIt-Anchor" href="#ds段寄存器和address"></a> DS段寄存器和[address]</h1><p>在CPU要读写内存单元的时候，我们必须得给出内存单元的地址才行呀，那么在8086 CPU里，内存地址由段地址+偏移地址组成，里面有一个DS的段寄存器来存放段地址</p><p>比如：我们这里要读取10000H内存单元的内容，如下：</p><div class="code-wrapper"><pre><code class="hljs X86ASM"><span class="hljs-keyword">mov</span>  <span class="hljs-built_in">bx</span>,<span class="hljs-number">1000H</span>   <span class="hljs-comment">;将1000H给bx通用寄存器</span><span class="hljs-keyword">mov</span>  <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">bx</span>      <span class="hljs-comment">;将bx的值赋值给ds段寄存器，也就是此时段寄存器存放着1000H</span><span class="hljs-keyword">mov</span>  <span class="hljs-built_in">al</span>,[<span class="hljs-number">0</span>]     <span class="hljs-comment">;注意：因为cpu读取数据时要知道段地址+偏移地址的，ds:[0] == 段地址:偏移地址，而中括号里面的0表示的就是偏移地址，中括号表示的是内存单元，上面读取10000H，如果要读取10001H，那么偏移1即可</span></code></pre></div><p>通过上面的三个指令，就可以让al寄存器读取到10000H内存单元的数据，但是如何反过来让寄存器的值赋值到内存单元？？？？通过<code>mov 内存单元地址:寄存器</code>  即可</p><p>注意：这里一定不能把1000H直接赋值给ds段寄存器，而是通过另一个寄存器bx间接将1000H赋值给段寄存器</p><h1 id="代码段和数据段"><a class="markdownIt-Anchor" href="#代码段和数据段"></a> 代码段和数据段</h1><p>我们可以将<code>一段内存定义为一个段</code>。用一个段地址指示段，用偏移地址访问段内的单元。这完全是我们自己可以决定的。</p><p>代码段：用来存放代码（通过用来存放程序执行的指令），段的基地址放在寄存器 CS 中，指令指针寄存器 IP 用来表示下一条指令在段中的偏移地址</p><p>数据段：用来存放程序处理的数据（通常用来存放程序中已初始化的（非 0）全局变量和静态局部变量），段的基地址存放在寄存器 DS 中。对数据段中的某个数据进行操作时，直接在汇编代码中通过立即数或寄存器来指定偏移地址</p><div class="code-wrapper"><pre><code class="hljs x86asm">作业:写几条指令，累加数据段中的前<span class="hljs-number">3</span>个字型数据，段地址为<span class="hljs-number">123BH</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span>   <span class="hljs-comment">;先把ax的数据置空</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">123BH</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,[<span class="hljs-number">0</span>]   <span class="hljs-comment">;也可以写成add ax,ds:[0]</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,[<span class="hljs-number">2</span>] <span class="hljs-comment">;这里为啥是2呢，因为这里是“字”型数据，所以为16位，也就2个存储单元（2个字节），所以每次增加2</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,[<span class="hljs-number">4</span>]</code></pre></div><p>作业解析：</p><img src="/2022/08/20/22-0820-02/image-20220830203705980.png" class="" title="image-20220830203705980"><p><code>add ax,[0]</code>也就是把3412这个数据给ax，然后<code>add ax,[2]</code>把7856这个数据给ax，<code>add ax,[4]</code>把6622这个数据给ax，这样就累加了前3个字型数据</p><h1 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h1><p>栈是特殊的访问方式的存储结构，CPU都有栈的设计，CPU提供相关指令以栈的方式读取内存空间，我们编程的时候可以将一段内存当作栈来使用，栈可以用于存储临时数据。</p><p>栈的结构如下：</p><img src="/2022/08/20/22-0820-02/image-20220830203831861.png" class="" title="image-20220830203831861"><p>栈有点类似于杯子，如果以a、b、c进栈，然后出栈的时候就是c、b、a，同时始终有一个标记指向栈顶，如果c出栈之后，那么标记就指向b</p><h2 id="入栈-出栈"><a class="markdownIt-Anchor" href="#入栈-出栈"></a> 入栈、出栈</h2><p>有两条指令可以操作栈，PUSH（入栈）、POP（出栈），入栈和出栈都是以<code>字</code>为单位</p><p>如：比如：<code>push ax</code>就是将ax的值放入栈，<code>pop ax</code>将栈顶的值出栈放入ax</p><p><strong>栈中数据的存放位置</strong></p><p>比如ax=1000H，然后我们 push ax，把ax的值压栈，注意：这里最下面是高地址，所以存放1000H时候，下面10，上面是00。然后让ax=2000H，再次 push ax 压栈，如下：</p><img src="/2022/08/20/22-0820-02/image-20220830204440835.png" class="" title="image-20220830204440835"><p>现在，我们要取出ax的值1000H，是不是只要执行pop ax 即可呢？？肯定不是，如果我们pop ax的话取出的值实际是2000H，pop指令肯本不知道ax是啥东西，只会取出栈顶的数据，那么我们如何取出ax的值呢？？？</p><p>可以先pop取出2000H，然后放到bx寄存器中，然后再取出1000H即可</p><h2 id="ss-sp寄存器"><a class="markdownIt-Anchor" href="#ss-sp寄存器"></a> SS、SP寄存器</h2><p>上面了解了栈，虽然在内存中是可以方便的定义一个栈了，但是，我们为什么要定义这么一个栈呢？自然，是为了操作方便，同时提供给 CPU 使用的，既然 CPU 要使用的话，自然，CPU 又必须根据一定的方式找到这个栈，而这就需要使用 SS 和 SP 寄存器了</p><p>栈顶的段地址存放在 SS 中，偏移地址在 SP 中，<code>任意时刻</code>，SS:SP就可以知道栈顶在哪里</p><p>如下：栈顶就是073F:00FD</p><img src="/2022/08/20/22-0820-02/image-20220830205442039.png" class="" title="image-20220830205442039"><p>再举个栗子，如下是内存中的栈</p><p>执行AX = 1122H，然后 PUSAH AX，执行后如下图，这里的栈顶SS:SP为1000H:000EH，那么这个栈顶是看出来的呀？因为SS是栈段地址，SP是栈的偏移地址，由于段地址×16+偏移地址就是实际的物理地址，而物理地址为1000EH，所以拆解1000EH即可得到SS为1000H，而SP为000EH</p><img src="/2022/08/20/22-0820-02/image-20220830205523642.png" class="" title="image-20220830205523642"><p>然后再次压栈，bx = 6677H，push bx，执行压栈后，SP的值发生变化，sp = sp-2，原本sp=000EH，减2后，sp=000C。而这里段地址SS肯定是不发生变化的，那么SS:SP = 1000H:000CH，如下图：</p><img src="/2022/08/20/22-0820-02/image-20220830205647442.png" class="" title="image-20220830205647442"><p>然后执行出栈操作，pop ax，注意：这里pop出ax的值为6677H，然后再执行SP = SP + 2，执行后sp的值由000CH变成000EH，如下图 ：</p><img src="/2022/08/20/22-0820-02/image-20220830205654587.png" class="" title="image-20220830205654587"><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">作业:</span>将10000H-1000FH这段空间当作栈，初始状态栈是空的，此时SS=1000H，SP=？？ （特别注意）0010H</code></pre></div><p>解析：</p><p>如下图，栈是空的</p><img src="/2022/08/20/22-0820-02/image-20220830205826726.png" class="" title="image-20220830205826726"><p>如果这里我们压入数据 1122H，这里那么毫无疑问，如下图：</p><img src="/2022/08/20/22-0820-02/image-20220830205835841.png" class="" title="image-20220830205835841"><p>但是这里问题是没有任何数据，那么我们直接把刚才写入的数据出栈即可，sp由000EH减2，如下图：</p><img src="/2022/08/20/22-0820-02/image-20220830205845476.png" class="" title="image-20220830205845476"><p>最终得到SP=0010H</p><h2 id="栈溢出"><a class="markdownIt-Anchor" href="#栈溢出"></a> 栈溢出</h2><p>如果栈内存大小就是4个字节，那么我们向里面压入数据，1122H、3344H，如下，已经放满了数据了</p><img src="/2022/08/20/22-0820-02/image-20220830205956602.png" class="" title="image-20220830205956602"><p>但是如果我们持续push压入数据的话，那么就会覆盖掉其它的数据，如下，并且如果压入的指令的话，并且把指令压入了CS:IP指向的内存空间，而8086 cpu任意时刻都会从CS:IP指向的内存中读取指令，那么程序就直接执行我们压入的指令了</p><img src="/2022/08/20/22-0820-02/image-20220830210005867.png" class="" title="image-20220830210005867"><p>pop可能造成栈顶越界，栈顶到了其它的内存空间</p><img src="/2022/08/20/22-0820-02/image-20220830210014390.png" class="" title="image-20220830210014390"><p>为了防止上面的溢出或者越界，CPU最好能够记录栈顶的上限和下限在哪里，这样一直pop就不越界，但这里学习的16位cpu没有该功能，32位的是有这个功能的。（金丝雀保护机制，后续再学习）</p><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">作业:</span>补齐下面程序，使他可以将10000H-1000FH中的8个字，逆序复制到20000H-2000FH中mov ax,2000hmov ds,ax- - -在此处补充指令- - - pop [E]pop [C]pop [A]pop [8]pop [6]pop [4]pop [2]pop [0]<span class="hljs-section">解答:</span>mov ax,2000hmov ds,ax- - - mov bx,1000h  mov ss,bx  //设置栈顶SSmov sp,0   //设置栈顶SP- - -pop [E]  //出栈把值放到内存地址中，这里的内存地址前面mov ax,2000h、mov ds,ax设置好了段地址2000h，[E]即偏移地址，两个一合成，段地址2000h×16+偏移地址000E得到内存中物理地址2000EHpop [C]  pop [A]pop [8]pop [6]pop [4]pop [2]pop [0]</code></pre></div><h2 id="对栈的分析"><a class="markdownIt-Anchor" href="#对栈的分析"></a> 对栈的分析</h2><p>向2000:0写入11,22,33,44,55,66</p><img src="/2022/08/20/22-0820-02/image-20220830210632162.png" class="" title="image-20220830210632162"><p>然后把ss:sp设置成2000:0</p><img src="/2022/08/20/22-0820-02/image-20220830210639111.png" class="" title="image-20220830210639111"><p>设置后，类似如下：</p><img src="/2022/08/20/22-0820-02/image-20220830210646646.png" class="" title="image-20220830210646646"><h3 id="pop出栈分析"><a class="markdownIt-Anchor" href="#pop出栈分析"></a> POP出栈分析</h3><p>然后-a设置来执行pop ax指令</p><img src="/2022/08/20/22-0820-02/image-20220830210708912.png" class="" title="image-20220830210708912"><p>-t执行后，sp的值加了2，并且ax的值变成了2211</p><img src="/2022/08/20/22-0820-02/image-20220830210716264.png" class="" title="image-20220830210716264"><p>pop出栈后，我们再次查看2000:0这里的数据，发现了11,22已经出栈了</p><img src="/2022/08/20/22-0820-02/image-20220830210723248.png" class="" title="image-20220830210723248"><p>然后再次执行pop ax操作，ax的值变成了4433，并且原本的33,44也已经出栈了</p><img src="/2022/08/20/22-0820-02/image-20220830210730955.png" class="" title="image-20220830210730955"><h3 id="push入栈分析"><a class="markdownIt-Anchor" href="#push入栈分析"></a> PUSH入栈分析</h3><p>同样2000:0处数据如下：</p><img src="/2022/08/20/22-0820-02/image-20220830210933972.png" class="" title="image-20220830210933972"><p>然后把ss:sp改成2000:4，图解如下:</p><img src="/2022/08/20/22-0820-02/image-20220830210941315.png" class="" title="image-20220830210941315"><p>然后把ax的值改成0000，并且push ax的值，然后sp的值由4变成了2</p><img src="/2022/08/20/22-0820-02/image-20220830210947907.png" class="" title="image-20220830210947907"><p>同时我们查看d2000:0的数据</p><img src="/2022/08/20/22-0820-02/image-20220830210954995.png" class="" title="image-20220830210954995"><p>压入ax的值0000后，如下：</p><img src="/2022/08/20/22-0820-02/image-20220830211001586.png" class="" title="image-20220830211001586"><p>然后再次压入ax的值0000</p><img src="/2022/08/20/22-0820-02/image-20220830211008964.png" class="" title="image-20220830211008964"><p>图解如下：</p><img src="/2022/08/20/22-0820-02/image-20220830211016110.png" class="" title="image-20220830211016110"><p>在这里压栈要注意下，经常容易有个误区：</p><p>当sp为4时，如果mov ax,0，然后push ax的话，之前一直以为压入栈内的0在如下位置，实际并不是。这里可以结合上面的作业题（当栈为空的时候，求解sp的值）多加理解</p><img src="/2022/08/20/22-0820-02/image-20220830211027991.png" class="" title="image-20220830211027991"><h1 id="汇编源程序执行过程"><a class="markdownIt-Anchor" href="#汇编源程序执行过程"></a> 汇编源程序执行过程</h1><ol><li>文本编辑汇编代码</li><li>使用汇编语言编译程序对源程序进行编译生成目标文件</li><li>再用连接程序对目标文件进行连接，生成可在操作系统中直接运行的可执行文件</li></ol>]]></content>
    
    
    <categories>
      
      <category>16位汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编Day1</title>
    <link href="/2022/08/20/22-0820-01/"/>
    <url>/2022/08/20/22-0820-01/</url>
    
    <content type="html"><![CDATA[<h1 id="进制基础"><a class="markdownIt-Anchor" href="#进制基础"></a> 进制基础</h1><ul><li>bit（比特） = 一个bit是一个0或1，叫做一个二进制位</li><li>byte（字节）=  1byte 是 8 个比特</li><li>16进制 = 4个2进制</li></ul><h1 id="汇编语言组成"><a class="markdownIt-Anchor" href="#汇编语言组成"></a> 汇编语言组成</h1><ul><li>汇编指令：由CPU执行，是机器码的助记符，有对应的机器码</li><li>伪指令：由编译器执行，没有对应的机器码，计算机不执行</li><li>其它符号：比如：+－*/ 由编译器识别执行，没有对应机器码</li></ul><h1 id="cpu组成"><a class="markdownIt-Anchor" href="#cpu组成"></a> CPU组成</h1><p>一个典型的CPU大概由运算器、控制器、寄存器构成。外部总线实现CPU和主板上其他器件的联系，内部总线实现CPU内部各个部件的链接</p><h1 id="寄存器-存储器-内存的区别"><a class="markdownIt-Anchor" href="#寄存器-存储器-内存的区别"></a> 寄存器、存储器、内存的区别</h1><ul><li>寄存器：是cpu组成部分，作用是将寄存器内的数据执行算术及逻辑运算，是操作数据的地方（当然也可以存储数据和指令）</li><li>存储器：在cpu外，一般指的是硬盘、U盘等可以在切断电源后保存资料的设备，是存放数据的地方。</li><li>更通俗的解释如下：（参考自知乎）<ul><li>解释一：<ul><li>寄存器就是你的口袋。身上只有那么几个，只装最常用或者马上要用的东西。</li><li>内存就是你的背包。有时候拿点什么放到口袋里，有时候从口袋里拿出点东西放在背包里。</li><li>辅存（外存）就是你家里的抽屉。可以放很多东西，但存取不方便。</li></ul></li><li>解释二：如果把被储存的东西比作能量<ul><li>寄存器就是 ATP，可以随时拿来用，性能高，但数量有限；</li><li>内存就是葡萄糖，性能一般，但是存量可以比较多；</li><li>外存（比如硬盘）就是脂肪，容量可以非常大，性能很差，要先转化为葡萄糖（存进内存），然后转化为 ATP（放到寄存器）才能直接利用（存取）。</li></ul></li><li>解释三：按最简单的数据的存储和操作距离来理解它们的区别：<ul><li>CPU（数据的操作）&lt;<mark><mark>&gt;缓存（数据的存储）&lt;</mark></mark>=&gt;寄存器（指令等存储）&lt;<mark><mark>&gt;内存（需要等待的所有数据的存储）&lt;</mark></mark>&gt;外部存储器（硬盘、光盘等）</li></ul></li></ul></li></ul><h1 id="8086-cpu"><a class="markdownIt-Anchor" href="#8086-cpu"></a> 8086 CPU</h1><p>8086 CPU （Intel 8086 是一个由Intel于1978年所设计的16位微处理器芯片，是x86架构的鼻祖）有14个16位寄存器 AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW，其中AX，BX，CX，DX 这4个通常用来存放一般性数据，被称为通用寄存器</p><p>注意：8086 CPU 的上一代，也就是8086 CPU 的老爸实际是8位的，当然8086是16位的兼容8位的，所以为了兼容上一代的CPU， AX 寄存器（16位）可以分为两个<code>独立</code>的8位寄存器 AH，AL。同理，BX可分为BH、BL。CX分为CH、CL。DX分为DH、DL。</p><p>8086 cpu可以一次处理2种尺寸数据：<code>字节(byte)和字(word) ，一个字等于两个字节</code></p><h1 id="简单汇编指令"><a class="markdownIt-Anchor" href="#简单汇编指令"></a> 简单汇编指令</h1><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">18</span>    <span class="hljs-comment">;将18送入寄存器AX    AX = 18</span><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-number">88</span>    <span class="hljs-comment">;将88送入寄存器AH中   AH=88</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">8</span>     <span class="hljs-comment">;AX = AX+8</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">bx</span>    <span class="hljs-comment">;AX的值 = BX</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">bx</span>    <span class="hljs-comment">;ax = ax+bx</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">bl</span> <span class="hljs-comment">;这条指令是不正确的，ax是16位寄存器，bl是8位的，前后必须保持一致</span></code></pre></div><p>作业：</p><div class="code-wrapper"><pre><code class="hljs x86asm">程序段中的指令     指令执行后<span class="hljs-built_in">AX</span>中的值    指令执行后<span class="hljs-built_in">BX</span>中的值<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4E20H</span>      <span class="hljs-number">4E20H</span>                   <span class="hljs-number">0000H</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">1406H</span>      <span class="hljs-number">6226H</span>                   <span class="hljs-number">0000H</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">2000H</span>      <span class="hljs-number">6226H</span>                   <span class="hljs-number">2000H</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">bx</span>         <span class="hljs-number">8226H</span>                   <span class="hljs-number">2000H</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-built_in">ax</span>         <span class="hljs-number">8226H</span>                   <span class="hljs-number">8226H</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">bx</span>           ?                     <span class="hljs-number">8226H</span>注意:后面的H字母表示十六进制数（Hex）计算：<span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">1406H</span><span class="hljs-comment">;也就是16进制4E20+1406=6226，直接用计算器</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">bx</span><span class="hljs-comment">;也就是16进制ax=6226+2000=8626</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">bx</span><span class="hljs-comment">;也就是ax=8226+8226=1 044C</span>注意：这里最后？计算出来的结果为1044C，但是由于<span class="hljs-built_in">AX</span>是<span class="hljs-number">16</span>位寄存器，所以最前面的<span class="hljs-number">1</span>溢出了，得到的？值为044C</code></pre></div><h1 id="8086-cpu寻址能力"><a class="markdownIt-Anchor" href="#8086-cpu寻址能力"></a> 8086 CPU寻址能力</h1><p>8086有20根总线，可以传送20位地址，每个地址都可以存放0或1，寻址能力即<code>2^20=1048576 bit</code>，即寻址能力为1M，cpu和内存之间通过20条地址总线相连接，可以传送20位地址，寻址能力达到1MB。但是16寄存器寻址能力是2的16次方，也就是65536bit，只有64KB，这显然是不合适的</p><p>那么内部寄存器为16位，那么如何来寻找20位地址？？采用地址合成（两个16位进行地址合成得到20位）</p><img src="/2022/08/20/22-0820-01/image-20220829104830861.png" class="" title="image-20220829104830861"><p>例如，1230和00C8进行合成，步骤如下：</p><img src="/2022/08/20/22-0820-01/image-20220829104840678.png" class="" title="image-20220829104840678"><p>寻址123c8H的内存单元  地址加法器采用段地址 x 16 + 偏移地址的方法合成<code>物理地址</code>，其实就是用一个基础地址加上一个偏移地址</p><p>注意：</p><ul><li>这里的段地址×16，段地址是1230，这是十六进制，但是16是十进制，所以我们把1230转为十进制，也就是4656，然后再用4656×16=74496，而76696转为十六进制就是12300</li><li>或者这样想也行，段地址*16相当于这个 “16进制数” 左移1位，后面补个0，1230就变成了12300</li></ul><h2 id="段地址和偏移地址的理解"><a class="markdownIt-Anchor" href="#段地址和偏移地址的理解"></a> 段地址和偏移地址的理解</h2><blockquote><p>转载：<a href="https://blog.csdn.net/qq_18360881/article/details/107225697">https://blog.csdn.net/qq_18360881/article/details/107225697</a></p></blockquote><p>如果让你去一个地方，这个地方叫野猪窝（哈哈，这是个地名），那你知道怎么走吗？如果你不知道地址，你是不是会把中国遍历一下。也挺好，你可能会找到若干个野猪窝。如果我告诉你，这个地方在陕西省西安市蓝田县汤峪镇。你是不是很快就能找到目标?</p><p>先别急，让我们一步一步来，假设你的定位范围是整个地球，首先我告诉你在中国，那么你就可以过滤掉美国，日本，英国等一系列国家，从而在我们中国内部进行检索。这时我又告诉你在陕西省，那么你离目标是不是又近了一步？然后是西安市、蓝田县······一步一步的，你就找到了这个地方。</p><p>在上面的介绍中，中国可以认为是一级段地址，通过他可以过滤掉一系列其他国家，进行下一级行政单位（省份）的确定，陕西省是中国的偏移地址，进入中国范围后，可以通过陕西省过滤掉我国的其他省份，同样陕西省也是他下一级行政单位（西安市）的段地址，依次递推。这是不是就明了许多了？</p><p>我们将这个概念再带回计算机上，假设你现在有1024字节的内存，你将他们分为四个段，每个段有256个字节。把这四个段分别编号为A，B，C，D。当你想要唯一的定位一个字节时，你应当先找到他所在的段地址，然后就可以排除其他三个段地址了。这样你的检索范围就会大大缩小。比如说你要检索的数据在C段，那你就可以只检索C段内的256个字节，如果再告诉你偏移地址，比如说是第123个字节，那么就很容易定位了。</p><h2 id="物理地址段地址16偏移地址的含义"><a class="markdownIt-Anchor" href="#物理地址段地址16偏移地址的含义"></a> 物理地址=段地址*16+偏移地址的含义</h2><blockquote><p>转载：<a href="https://zhuanlan.zhihu.com/p/443067188">https://zhuanlan.zhihu.com/p/443067188</a></p></blockquote><p>“段地址 x 16 + 偏移地址 = 物理地址” 的本质含义是：CPU在访问内存时，用<strong>基础地址</strong>（段地址 x 16）和基于基础地址的<strong>偏移地址</strong>相加，给出内存单元的物理地址。</p><p>比如：</p><img src="/2022/08/20/22-0820-01/image-20220830093931526.png" class="" title="image-20220830093931526"><p>此时 你从家出发前往图书馆，你询问我如何前往，我可以告诉你两种方式：</p><ol><li>从家出发，走2326m到达图书馆。这2326m就可以看作图书馆的物理地址。</li><li>从家出发，走2000m到达饭馆，吃个饭在走326m到达图书馆。这里的2000m可以看作相对于家的基础地址，第二个326m相对于基础地址的偏移地址（以基础地址为起点的地址）</li></ol><ul><li>第一种方法直接给出物理地址。</li><li>第二种方法是用基础地址和偏移地址相加得到物理地址。（进一步展现了物理地址=段地址*16+偏移地址）</li></ul><p>此时我们为以上描述增加一些限制条件，比如，只能通过纸条来传递信息</p><p>你问我去图书馆怎么走，显然我需要一个可以容纳4位数据的纸条，才能写下2326这个数据。</p><img src="/2022/08/20/22-0820-01/image-20220830094506657.png" class="" title="image-20220830094506657"><p>可是不巧的是， 我没有能容纳4位数据的纸条，仅有两张可以容纳3位数据的纸条。那么我只能以这种方式告诉你</p><img src="/2022/08/20/22-0820-01/image-20220830094948537.png" class="" title="image-20220830094948537"><p>在第一张纸上写上 232（段地址），在第二张纸上写上006（偏移地址）。假设我们事先对这种情况有过约定：<br />你得到两张纸后做这样的运算：232（段地址）×10+006（偏移地址）=2326（物理地址）</p><h2 id="段的最大长度"><a class="markdownIt-Anchor" href="#段的最大长度"></a> 段的最大长度</h2><p>一个段中每个内存单元的地址表示为 段地址:偏移地址</p><p>其中，段的长度是偏移地址可以取的数值规定的，在8086cpu中，偏移地址使用一个16位的二进制数表示，其表示范围是（0000H:0FFFFH），总共有2^16(2的16次方)=64K个不同的取值，一个内存单元使用1个偏移地址，故一个段的大小是64K</p><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">作业:</span>1.给定段地址为0001H，仅通过变化偏移地址寻址，CPU的寻址范围为____0010H___到___1000F_____。2.有一段数据存放在内存20000H的单元中，现给定段地址为SA，若想用偏移地址去寻址到这个单元，则SA满足的条件是：最小为___1001_____，最大为______2000H_______<span class="hljs-section">解析:</span>1. 由于CPU的范围是“段地址×16”+偏移寻址，由于偏移寻址是16位，那么最大就是FFFF，最小就是0啦，所以最小范围就是0001H×16，最大就是0001H×16后再加FFFF2. 这里和第1题恰好反过来了，这里知道物理地址是20000H，所以先减去FFFF得到1 0001，再把10001转为十进制再÷16得到4096，再把4096转为十六进制就是1000H，但是1000H如果是段地址，那么进一位（×16），也就是10000H，但是应该是1001H才行，所以前面的段地址最小应该是1001H最大为2000H</code></pre></div><h2 id="8086-cpu读取指令过程"><a class="markdownIt-Anchor" href="#8086-cpu读取指令过程"></a> 8086 CPU读取指令过程</h2><p>段地址实际就是由段寄存器提供，8086 CPU有4个段寄存器：CS 、DS、SS 、ES</p><p>其中CS和IP它们指示了CPU当前要读取的地址，CS叫代码段寄存器，IP为指令指针寄存器，比如：在<code>任意时刻</code>，8086 CPU将从CS中的内容×16+IP的内容单元处开始读取一条指令（可以将CS理解为段地址、IP理解为偏移地址）</p><p>如下图：B8、23、01这些都是机器码，后面的20000、20001、20002这些是内存地址，后面是B8、23、01机器码对应的汇编指令（注意：<code>每个内存地址对应一个存储单元，每个存储单元大小为1字节</code>，恰好这里B8、23、01这些十六进制都是1个字节）</p><img src="/2022/08/20/22-0820-01/image-20220830100304478.png" class="" title="image-20220830100304478"><p>8086 PC读取和执行指令的相关部件以及过程如下：</p><p>步骤一：</p><img src="/2022/08/20/22-0820-01/image-20220830100330281.png" class="" title="image-20220830100330281"><p>步骤二：</p><img src="/2022/08/20/22-0820-01/image-20220830100750071.png" class="" title="image-20220830100750071"><p>步骤三：</p><img src="/2022/08/20/22-0820-01/image-20220830100801500.png" class="" title="image-20220830100801500"><p>步骤四：</p><img src="/2022/08/20/22-0820-01/image-20220830100809487.png" class="" title="image-20220830100809487"><p>步骤五：</p><img src="/2022/08/20/22-0820-01/image-20220830100826437.png" class="" title="image-20220830100826437"><p>步骤六：</p><img src="/2022/08/20/22-0820-01/image-20220830100835114.png" class="" title="image-20220830100835114"><p>步骤七：</p><img src="/2022/08/20/22-0820-01/image-20220830100846225.png" class="" title="image-20220830100846225"><p>步骤八：</p><img src="/2022/08/20/22-0820-01/image-20220830100854359.png" class="" title="image-20220830100854359"><p>步骤九：</p><img src="/2022/08/20/22-0820-01/image-20220830101101510.png" class="" title="image-20220830101101510"><p>步骤十：</p><img src="/2022/08/20/22-0820-01/image-20220830101110907.png" class="" title="image-20220830101110907"><p>步骤十一：</p><img src="/2022/08/20/22-0820-01/image-20220830101121777.png" class="" title="image-20220830101121777"><p>步骤十二：</p><img src="/2022/08/20/22-0820-01/image-20220830101129951.png" class="" title="image-20220830101129951"><p>步骤十三：</p><img src="/2022/08/20/22-0820-01/image-20220830101136970.png" class="" title="image-20220830101136970"><p>步骤十四：</p><img src="/2022/08/20/22-0820-01/image-20220830101145687.png" class="" title="image-20220830101145687"><p>步骤十五：</p><img src="/2022/08/20/22-0820-01/image-20220830101154735.png" class="" title="image-20220830101154735"><p>步骤十六：</p><img src="/2022/08/20/22-0820-01/image-20220830101201719.png" class="" title="image-20220830101201719"><p>经过上面的步骤，可总结CPU执行指令的步骤如下：</p><ol><li>从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器</li><li>IP = IP+读取的指令的长度，指向下一条指令</li><li>执行指令，执行完成转到步骤1，重复这个过程</li></ol><h2 id="如何修改csip的值"><a class="markdownIt-Anchor" href="#如何修改csip的值"></a> 如何修改CS:IP的值</h2><p>8086 CPU加电启动或复位后，CS和IP的值被设置为CS=FFFFH、IP=0000H，开机后执行的第一条指令的内存地址就是 CS=FFFFH、IP=0000H</p><p>如何要同时修改CS:IP的值，那么可以通过jmp（跳转）指令来实现，比如：<code>jmp 0fffh:0100h</code>，把CS修改为0fffh，IP改为0100h</p><p>如果仅仅修改IP的值，jmp 某个寄存器，比如：<code>mov ax,0fffh,jmp ax</code>，可以将这个分开理解，<code>mov ax,0fffh</code>就是ax=0fffh，后面的<code>jmp ax</code>可以理解为<code>mov ip,ax</code>，也就是ip=ax=0fffh，这样ip就成了0fffh，为啥修改ip的值要这么麻烦呢？？？因为语法就这么规定的。。。</p><div class="code-wrapper"><pre><code class="hljs txt">作业：mov ax,bxsub ax,axjmp ax这3条指令执行后，CPU几次修改IP？都是在什么时候？，最后IP的值是多少？解答：注意：sub是减法指令mov ax,bx  读取到指令缓冲器mov ax,bx 修改自己ip+2  执行sub ax,ax  读取sub ax，bx 修改ip+2   执行jmp ax     读取jmp ax ，修改ip+2  执行注意：jmp ax，这里由于sub ax，ax后，ax为0，也就是jmp 0，所以还会修改ip，ip还会修改1次所以ip一共修改了4次</code></pre></div><h1 id="debug调试方法"><a class="markdownIt-Anchor" href="#debug调试方法"></a> Debug调试方法</h1><blockquote><p>注意：这里要在windows 2003中使用，win10版本太高，无法直接使用</p></blockquote><p>cmd下直接输入debug即可</p><img src="/2022/08/20/22-0820-01/image-20220830104037882.png" class="" title="image-20220830104037882"><p>-r 查看和改变寄存器内容</p><img src="/2022/08/20/22-0820-01/image-20220830104056968.png" class="" title="image-20220830104056968"><p>-d 以数据方式显示寄存器的内容</p><img src="/2022/08/20/22-0820-01/image-20220830104104567.png" class="" title="image-20220830104104567"><p>-u 以汇编指令的方式显示寄存器的内容</p><img src="/2022/08/20/22-0820-01/image-20220830104509769.png" class="" title="image-20220830104509769"><p>-t 执行一条机器指令</p><img src="/2022/08/20/22-0820-01/image-20220830104519704.png" class="" title="image-20220830104519704"><p>-a 用汇编形式写入指令，这里是向0AEF:100这个地址写入mov ax,100（两次回车退出）</p><img src="/2022/08/20/22-0820-01/image-20220830104528150.png" class="" title="image-20220830104528150"><p>然后-r查看寄存器的内容如下，AX的值是0，我们现在是想把ax值变成100，如果后面执行-t的话，下图中绿色划线的指令mov [96C7],AL，我们只需要让其-t执行mov ax,100即可把ax的值由0变成100</p><img src="/2022/08/20/22-0820-01/image-20220830105122544.png" class="" title="image-20220830105122544"><p>所以我们需要修改IP的值，把IP的值修改成100即可，这样段地址（CS）：偏移地址（IP） = 0AEF：0100，这个地址也就对应-a写入时的地址</p><p>通过-r ip修改ip的值，修改后，再次-r查看寄存器内容，指向的就是ax,100</p><img src="/2022/08/20/22-0820-01/image-20220830172405342.png" class="" title="image-20220830172405342"><p>然后-t执行后，ax的值就改成了100</p><img src="/2022/08/20/22-0820-01/image-20220830172414669.png" class="" title="image-20220830172414669"><p>-d 0aef:0170从0aef:0170开始查看数据</p><img src="/2022/08/20/22-0820-01/image-20220830172421247.png" class="" title="image-20220830172421247"><p>如果要查看0aef:0170到0aef:0177之间的数据，如下划红线的数据：</p><img src="/2022/08/20/22-0820-01/image-20220830172429001.png" class="" title="image-20220830172429001"><p>使用 -d 0aef:0170 0177</p><img src="/2022/08/20/22-0820-01/image-20220830172436745.png" class="" title="image-20220830172436745"><p>-e修改数据内容，比如：修改0aef:1000开始的数据，没修改前，数据46,EB,EB，修改成00,11,22</p><img src="/2022/08/20/22-0820-01/image-20220830172444557.png" class="" title="image-20220830172444557"><p>修改后如下：</p><img src="/2022/08/20/22-0820-01/image-20220830172451282.png" class="" title="image-20220830172451282"><p>也可以按字符串修改</p><img src="/2022/08/20/22-0820-01/image-20220830172459440.png" class="" title="image-20220830172459440"><p>修改后如下：</p><img src="/2022/08/20/22-0820-01/image-20220830172505840.png" class="" title="image-20220830172505840"><p>也可以通过-a写入数据，比如通过-a向1000:0这个地方写入mov ax,bx，然后查看</p><img src="/2022/08/20/22-0820-01/image-20220830172512107.png" class="" title="image-20220830172512107"><p>通过-u查看更明显</p><img src="/2022/08/20/22-0820-01/image-20220830172518360.png" class="" title="image-20220830172518360"><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">作业:</span>查看内存中的内容，PC主板上的ROM上有一个生成日期，在内存FFF00-FFFFFH的某几个单元中，请找到这个生产日期并且试图改变他<span class="hljs-section">解析:</span>物理地址=段地址*10+偏移地址，这三个地址都是16位数字，数字后面的H可以写，也可以不写，都表示的是16位的数据；16表示的是十进制的，转换成16进制就是10。段地址占用4个字符，即：fff0，因为物理地址=fff00，所以偏移地址=0，计算过程即：fff00=fff0*10+0；同样的道理，物理地址fffff，段地址是fff00，便宜地址是ff所以，查看内存的指定物理地址的数据，就直接使用命令，d fff0:0 ff即可得到该内存中fff00-fffff的数据。</code></pre></div><img src="/2022/08/20/22-0820-01/image-20220830191832791.png" class="" title="image-20220830191832791">]]></content>
    
    
    <categories>
      
      <category>16位汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>转载：理解 分段 | 分页 机制</title>
    <link href="/2022/08/13/22-0813-02/"/>
    <url>/2022/08/13/22-0813-02/</url>
    
    <content type="html"><![CDATA[<h1 id="分段分页的产生"><a class="markdownIt-Anchor" href="#分段分页的产生"></a> 分段|分页的产生</h1><blockquote><p>转载自：<a href="https://blog.csdn.net/low5252/article/details/106068865/">https://blog.csdn.net/low5252/article/details/106068865/</a></p></blockquote><p>分段和分页都是为了利用和管理好计算机的资源—内存。在分段技术没有出现之前，程序运行是需要从内存中分配出足够多的连续的内存，然后把整个程序装载进去。举个例子，某个程序大小是10M，然后，就需要有连续的10M内存空间才能把这个程序装载到内存里面。如果无法找到连续的10M内存，就无法把这个程序装载进内存里面，程序也就无法得到运行。上面这种直接把整个程序装载进内存的方式是有一定的问题的。</p><ol><li><p>地址空间不隔离</p><p>举个例子，假设我有两个程序，一个是程序A，一个是程序B。程序A在内存中的地址假设是<code>0x00000000~0x00000099</code>，程序B在内存中的地址假设是<code>0x00000100~x00000199</code>。那么假设你在程序A中，本来想操作地址<code>0x00000050</code>，不小心手残操作了地址<code>0x00000150</code>，那么，不好的事情或许会发生。你影响了程序A也就罢了，你把程序B也搞了一顿。</p></li><li><p>程序运行时候的地址不确定</p><p>因为我们程序每次要运行的时候，都是需要装载到内存中的，假设你在程序中写死了要操作某个地址的内存，例如你要地址<code>0x00000010</code>。但是问题来了，你能够保证你操作的地址<code>0x00000010</code>真的就是你原来想操作的那个位置吗？很可能程序第一次装载进内存的位置是<code>0x00000000~0x00000099</code>，而程序第二次运行的时候，这个程序装载进内存的位置变成了<code>0x00000200~0x00000299</code>，而你操作的<code>0x00000010</code>地址压根就不是属于这个程序所占有的内存。</p></li><li><p>内存使用率低下</p><p>举个例子，假设你写了3个程序，其中程序A大小为10M，程序B为70M，程序C的大小为30M。你的计算机的内存总共有100M。这三个程序加起来有110M，显然这三个程序是无法同时存在于内存中的。并且最多只能够同时运行两个程序。<br />可能是这样的，程序A占有的内存空间是<code>0x00000000～0x00000009</code>，程序B占有的内存空间是<code>0x00000010～0x00000079</code>。假设这个时候程序C要运行该怎么做？可以把其中的一个程序换出到磁盘上，然后再把程序C装载到内存中。假设是把程序A换出，那么程序C还是无法装载进内存中，因为内存中空闲的连续区域有两块，一块是原来程序A占有的那10M，还有就是从<code>0x00000080～0x00000099</code>这20M，所以，30M的程序C无法装载进内存中。那么，唯一的办法就是把程序B换出，保留程序A，但是，此时会有60M的内存无法利用起来，很浪费对吧。</p></li></ol><p>为了解决上面的问题就引入了分段和分页技术</p><h1 id="分段的理解"><a class="markdownIt-Anchor" href="#分段的理解"></a> 分段的理解</h1><p>为了实现分段技术，需要引入虚拟地址空间的概念。那么什么是地址空间呢？简单的说就是可以寻址的一片空间。如果这个空间是虚拟的，我们就叫做虚拟地址空间；如果这个空间是真实存在的，我们就叫做物理地址空间。<strong>虚拟地址空间是可以任意的大的，因为是虚拟的。而物理地址空间是真实存在的，所以是有限的</strong>。</p><p>分段这个技术做了一件什么事情呢？它把虚拟地址空间映射到了物理地址空间（<strong>未开启分页情况下，从虚拟机地址空间到物理地址空间的转换是段基地址+段内偏移地址</strong>），并且你写的程序操作的是虚拟地址。假设，程序A的虚拟地址空间是<code>0x00000100～0x00000200</code>。此时，不仅需要一块连续的物理内存来存放程序A，还需要把程序A的虚拟地址空间映射到（转换为）物理地址空间。可能，程序A的虚拟地址空间从<code>0x00000100～0x00000200</code>映射到了物理地址空间<code>0x00000000～0x00000100</code>。</p><p>分段技术可以解决上面1、2两个问题。</p><p>在问题1中，假设程序A的虚拟地址空间是<code>0x00000000~0x00000099</code>，映射到的物理地址空间是<code>0x00000600~0x00000699</code>，程序B的虚拟地址空间是<code>0x00000100~0x00000199</code>，映射到的物理地址空间是<code>0x00000300~0x00000399</code>。假设你还是手残，在程序A中操作了地址<code>0x00000150</code>，但是英文此时的地址<code>0x00000150</code>是虚拟的，而虚拟化的操作是在操作系统的掌控中的，所以，操作系统有能力判断，这个虚拟地址<code>0x00000150</code>是有问题的，然后阻止后续的操作。所以，体现出了隔离性。（另一种体现隔离性的方式就是，操作同一个虚拟地址，实际上可能操作的是不同的物理地址）（<strong>注意，实际上，很可能程序A和程序B的虚拟地址都是<code>0x00000000~0x00000099</code>。这里的举例只是为了方便理解。</strong>）</p><p>问题2也很好的解决了。正是因为这种映射，使得程序无需关注物理地址是多少，只要虚拟地址没有改变，那么，程序就不会操作地址不当。</p><h1 id="分页的理解"><a class="markdownIt-Anchor" href="#分页的理解"></a> 分页的理解</h1><p>但是问题3仍然没有解决。因为第三个问题是换入换出的问题，这个问题的关键是能不能在换出一个完整的程序之后，把另一个完整的程序换进来。而这种分段机制，映射的是一片连续的物理内存，所以问题3得不到解决。</p><p>而问题出在哪呢？就是<strong>完整和连续。</strong></p><p>而分页技术的出现就是为了解决这个问题的。分页这个技术仍然是一种虚拟地址空间到物理地址空间映射的机制。但是，粒度更加的小了。单位不是整个程序，而是某个“页”，一段虚拟地址空间组成的某一页映射到一段物理地址空间组成的某一页。（如何理解这个“页”的概念，这个问题见下面）</p><p>分页这个技术，它的虚拟地址空间仍然是连续的，但是，每一页映射后的物理地址就不一定是连续的了。正是因为有了分页的概念，程序的换入换出就可以以页为单位了。那么，为什么就可以只换出某一页呢？实际上，不是为什么可以换出某一页，而是可以换出CPU还用不到的那些程序代码、数据。但是，把这些都换出到磁盘，万一下次CPU就要使用这些代码和数据怎么办？又得把这些代码、数据装载进内存。性能有影响对吧。所以，我们把换入换出的单位变小，变成了“页”。（实际上，这利用了空间局部性），问题3是不是就解决了呢？<br />所以，分段和分页的区别在于：<strong>粒度</strong>。</p><h1 id="分段和分页的概述"><a class="markdownIt-Anchor" href="#分段和分页的概述"></a> 分段和分页的概述</h1><p>分段就是将一个程序分成代码段，数据段，堆栈段什么的，如下：</p><img src="/2022/08/13/22-0813-02/image-20220821104720506.png" class="" title="image-20220821104720506"><p>分页就是将这些段，例如代码段分成均匀的小块，然后这些给这些小块编号，然后就可以放到内存中去，由于编号了的，所以也不怕顺序乱，如下：</p><img src="/2022/08/13/22-0813-02/image-20220821105207174.png" class="" title="image-20220821105207174"><p>然后我们就能通过段号，页号，页内偏移找到程序的地址，如下：</p><img src="/2022/08/13/22-0813-02/image-20220821105323219.png" class="" title="image-20220821105323219">]]></content>
    
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo入门+Fluid主题美化|汉化</title>
    <link href="/2022/08/03/22-0803-01/"/>
    <url>/2022/08/03/22-0803-01/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="5001fcd208dad6f2b6840c1f1d8605761a1a257c57748df8bc3adb4240998722">bb37e7fa29ac998f9193b7733de58c59ffc2b770bd4b3ca6766c4a815de0249883f92792439ac57210abede1f2ef6caa040406f67f17ef6c27509103db6f265e866169ea347167b9e1e75f0efecf3e14405bdd736ac18f5705ffec9464444edbe5a8d888cb1da2404244f887508db1c4d55c2d162efa6678465716aa8ae5ae8219dc29b59e118e5b8f4c00b74afcaed09f8607fcd1b4f66297f4d130ceee2f88a08f9ee965c97baf26c6f54682c69844de46e216e458ad8aa50a643c1c6f4311b93517ace7797cb5806d81d7ed284963f0561222215cfce9c050b7b4c8984835120147a9e836f3b4961cb4307b7bd7c1566188d9c9acb60b74948ca829f02dc57a69516f00f7a662882e00b0838a72f94362dcf7ff7d5c2cdbb73fa0ca07d9aef1451a6122bb1a82f11e07d8f5994aa02ac6a4f1bea67ce6e3d2689b3ae41210f14dad939a4fc1e05f6574376d8f5fdd9e5d367322f102e22b13ff915473366f39cb4a9f845474ccefd66cbaa4d38e87bff82c0f3e803d905fd3a22c5723338378b373cb227a643a0fe184be48e83ceb0a0781a575da60df2747cd66f5cac516691c06698738f02c97c281c2d8db05e9dd63c98443dc43146b7c631e3cb3dddb03ed09e28bbe98d15cac6de46fd1f1acbfa8969d37c6af4379e484473433433cfc94616cf2ab59553a623d6107d66927670dd555b2c5ca31baa98ab4ecd157b3260ec141b70d6af874b43980d236b4551814b1ed9655e27ec8fde807008fef773f08772e10539fabddc963a4d36424947ecfc622d3f8e40e1ee7faa6f251ce0ece13046dfb668bff7974dcb78f476ed3e3529e795ad4706071616ce77dc748adb2214c829d06ae7b7636261e7049354f7f2f9bc11d709b3bc5a4e792683cf91633a6b1b19a90b2543546458f31089f95a4200862b3b5fe1526a0e89b742c91a1291252363ec1b4843711063cee3d5e25a95b7c9e4e7e41f56563122a5d9feaeb97154750a4866843ea0b95a7ebadb55077fd9327f138d0bb6c13f4d7617b327320b4fbd2ca9aca49202b333f8f254e7f0f8c032ca25039150e4e673084e06482459fc949296ce77b4706a0399ce6e9ee94487be66ff0cf3efc038adce38ed9ce15812e3c3f69fea5da914f56c962d19bd46260011f6ac4fb1f8a0c06e70c82451d5a55c1fb181253919044efe359ae0a66bf1a7d3439c78ef8a4cfdc28a249d7ae0b025b087dcaa8fcbe1a1838777062ae8734f0d0cc2bad13ffed98982f86205b83ea307baeccce73ccf2554384bf6b97b6fd623f9c83da43e2bfa90ee36fb2e1b7fc3652988c895c6586213866d946640aecf41fdc85bdefb9952ef910b052c6f47fd8514272e8406ed59f342151057fb61bf47c21e996e199b36c93716f80c90a3473330ec154e0de2679df326790c4dd1ce69e2a6d309e688cdbcedebe185050b7dc9d0e0e00c6373aaa009cd1eafd0f2fdbc86d3d93b957e7b97fa3560e10cb405ea0686c64d0fc60443fb07a97472e66aef15e54301032c44d781c66ac6fbe437cf09d91d8f24a93a058d7be988dadf78c13f7f855b81d78c225b580fd644bad9f6cd81919df997b41fed46a43fcb58501679317bc9c7949048b2c37787f535405a2082fb9f13ab9bd87393048fda10b8bcd49834455144294fef1794497984376c3a0956de6f17ee1e7ec17f54bd7a2e3e9edf413aa8972eb96a7e66dc99255718fe45a3d60e5fe65b41338929c3aabccee0cf7a57d3c7f60445a5e58e597397a38d11e6c4ac365a7978247c1fd6e1e365838f38552cbb65fdcdd34e77b4e0bf9fc637ceacbc74198381b8dd60f869a1e2343e061e5342f9344f38138da39445076671482f3284cfc750327ceea74a34ae9e8ab3a350573bb2b7e07d809c326da1f358d33b910cdd5113e802c7c6ddb7a9aaa97cc63dd21609c57813cc8a5f5c03e4b99312baaf9b7e0c95da44afb427b113aabcd888dc853788a038bc1b450a587cbe96296faee4ec7722602f35964f1ff374ac452786a413d91509bf63554bf6479e9bba2e26d2f92e7ccc84af819e88a6c2ba9e704bcd5b0207d015d6b6c155558b0e651e52f3039452dbc0d752fa0d7da64030fafb20ab8931ee028c9eaf608355115d709d9506a8c91f27607fb826a64c19504a0f4deab08d04d41b64666b35ffb45e5e2bdb8f3dc2c230ebfb64e9d886e7a019edd53f7ba23b2432cf6cf19b202830fb584cdf6a30da17bc169329c5be98f949aaae913902f77711d50569665b3c3478ac616e6dfdb4ab9e84aef5d87f957392488ade7643d521ccbfbdf076c298036aeee25b99858cf671fbd30aa95f91f6d3f6eb138ffd66af0aa9188e40269a992cfe0d909899af0dc02d1c0db75ccd3aa08626c498054e28adc78802ed561071dd3eb357a1f060912d1eca4a8c68f8f151dd5c7f081ff019dd6150fac66bcf842db207db9307d53b248f46644770b4bc991493b7bdc294d316adb6d355a29be14055f171aedc44894ce1fd027fef54ae890b43e8bf5bdec8b98b179491a259055a9f6053708dd3ea4039b0fb12358da2cc3d9c7886256043ea9b6dcf0923aa424d2d19ee1176da397676a628f3b4cca78e2a3d0c61f73e647f878b628b79f15649ed575b304adc64376792b414b27c7cb2deb783ba852df69bb149b9287dfebb0cebd7686d6fa92cf86f40e48dea98eaef128c5b969229b0e71efaeb3f9102387e2146fd89d182d093b570b456dbc24c2e64dd9b2fe8e879bba747cd3f6c7937aa46951932a486bbcaa588c98be3941bcda0883acf3530026b85b28cb8780e5c7727498b09926514c72517e61f90576acad153a97309547c718282860c47151101a58ecc7c1cd77e40d58ecf698753afad80c39bdfdecc7d310e7fc08dc5a045d5f0fd5ed075404464f513a7d299fb6b90ed124fd9a0a8b3dda851aba09cbf50db828906eb42c4d09d3b47938e0e4ff1ca48d7c32293daabfd5532f41a292cf2bac8d0ceb9864a09ea7fb749223a4faa9babec456472c69f1ed1213d927fd05732700e526235537d1feafe6898b3dc186d5af2651a581099b637f79a044e06ce771f134e9b84702880fc3e871d026e9c5048fb1921c3094fa684ff7de1ec7b6d58ac3917b587b21ca4dd7051dadfb7700236dc9d9dea66cca55a590e01e2579d2565e1d9f04abce3031b830903a3ecc710031baee303bd4c6c9ee17efc24131b0bd4e659be39e8fd0f347693a2a6f1272d501dd1a60f5bd70031f638eed8f6238f8fbce20083dcbb552a9ee2e2a8e486e1cc804ed1169a8e225f83e1822e4be75f744f1135ec381faab81d9f3352d715ecaf1f2faeccd03ea54208101a126392309ca7af8bf94669732eaaf17970960b64e0810812e8c765806b9ccf1dd7b684e17d3f1fa8bba35224ad10196ce3acaa3cfe914e637cff4fc0f776401166e0830ff81325c4d5491666f6df5c4804a64bce3c56e975e2cc1af7f43ef52e99f86688c4f53ed0c57d37c43c6df2272b7e57890702b12093e848174ab88ac40a5847647219165ce35b5162d9d22bbb5fbbd3bed477234c8c2f55378fb2ffccc61cabae9ae1c485100982c245b2756545726e55dcceb8d6138c42fa3adeee3309cef5238bc78ae0af9e039ad4826838a9368dbdce1bb24feaba42ec5c1fc3a5da5f0395b8faad16cd38323851bb1e2ee09e9861eda2cdbbc273394cc202ec3e92876e90e519515ce66c355edb8f6e0652a44dbdd32a632c74751719c55e41fb4a1f49135666d0df6cf92b07c9e05b5a04e643957ddd4d3d02163aeea4615ed95182eef91369edb3c1e2c7dc6c69e113ff498ef39abc7f92950cc89ba0193331489181e606a48dd2b1108a7f7be86e9fb9f2c728332f0b66df390c3c86e01b965b88c78e63c5bc3d76edd282295a026b1344960b5db22c26f60d12b6feeff78630075fa35f567173dee27d0828572422f773cb89d7681da5d8beb978b06f7e9a810d10c5c4419bff36d024efe4d81a6ee338e2b88d067853ade6ce766acc9289384b1664722a38e1f86596e8c1f2af0367a4f1bda4b4471ce3b92cbd0170dbef41840eafb31311232913ffba9b160b54028f0d7352412adfc3128d58958d6127aba9c59a636539a49d42b31d1e6013a0e101c41e15e58c6dbfd0d3ac51fc546145a27fd96021da5eaf73c0afc5f31b19d10f2c5c319372baa6d05a33cf5d07e7ceb1beb2c7f47db169aadd46987e4413312624eac88e051d8c1b35be8727fd651982b8532263da3ad03df5c5547196c1452fcd65d0347c8f54801398dbcd4d7144b4e46a7fbbb53342e662561d32895c26ceeecdd4eda7f9b9858101409121fd346f0849fb097240e8bc8419080a89f96bdfbb99793fae1b5f653e96594930bf51165f00aded720122dbe163a1c048382e11dbad6d50c8a0bd11eb59caacfc653964dc164f825b52b35f7dd97334ed978b8add812d50c24da79549cd8907a6187a9ed4e749b5632a897d289b1ebbcbf03bdcd78810e8cd2f062f8972659cd93d1643eddb1aec73720a64c7ff0dc64e079fb82a8f885631eeb0a1f289d1f1c869df47741ad2efb80d4588860430bd77fb72ba3282c530bcd6fce907224f011367aa2086d154f741cf2c44dcad67f0b94af21502cafb50b4bb161d4c953817986c9f76e81060875d5549023bdb1fec6d979e75471b0bc1820553ad4adb792dea5ce25059975f14b7349b9eec177f0f1fcad103fcc55e005b131e4981f84af04deb26eaf83bbc5c8c29986e58cb4b9a2d229e7e42c5f8886ec5865ac5f8c817370c71d1aed619aa11b0c8dc402e1b0e9f9db90502f392288480ddc0b73be44f2e284f8582edecde5bf0bb53b4388be72205bf3f52a2d42e8c5801675505b9420bdbf0e2f3761d49d264e4ce4f9a8fb3fef457f512f4c3a933e4143c549bbdcd7199753cf172c0802eeccf4eebcef9fd92b4d91ce389a5454be67f14add946054e0263d2e7859efe66dbadebae2c44e7874d07ab5eebebe4d3bb07508eab5f2bd59d04faba8b373f6b27f633c9e2a2ab629adb8571cdb3cfebbdb2f36c38281bfb16faeb9ac70b889574218d61b64697daf56c77c5d5f9524bf8429852cdb9d642467c52d2be4407ac39560f7659b5cdeae307f3b5399dbaad64b817e05a00931afcee0e3d779749c902d0854b2afe74afadac193e44662e459de21d789c00920f450dcefe15717314719242dbc3c1a6f9b743972de5fa1657e19f03f8650aa42da5f9cceb7e46d36a31f8698ad6ed8c0bdfabe1c32629e698c65a5d0845b2f6c273d07dea0132de7e11c4aa4aca2e90fddfd34f6695b6fe854f12839bbd64bdb8ffdd364e42366d544dca38b4528dac9cc76cdba5625d9d836040a5d8fd7fb5f0d45a4232a3176962bc1466fc50166a6e9329602c8e8a4bba910e45677eb241fd5163c56a5e576fb60fbe32646ba0eae6c63e40b9fb81f0cc06faa10affed4e8ebc3c56bdf26848fb7cdc13baf4cf056924f174d87b6e0f53164f9448a49a6921be058e10d8d17aa8d9bddec168b5cae3714a5ec27895cd286df3f1ee8571b1d31f0970b81d052bd1c4af7f08629d13bcbc3111ee39bf8fcd5c73232a953630cc7ee39bd3ecd12c96049a77e8e5ecea77562ed915d90ce5ad11ec077a9086ad58fa02445785048bfd6f5591c0d6f13ef87fde1fd1dd074df0ebdebc839fece7410eacae7c85a0582a719078611981eafe558b5de4dc18eb86e6d35d9db8c30a5c52745c783883de4ad1c372f7eb48f407d6c899ff65ce57a3220401dac0949c227d8611a42dd6a38a55954ba7ae41e6550b39f2694c534315123ae72b883f7b5e3054c02f5421ea17c992e3e99afb8067483362cfef045a21cdeee0897b763b62b0b9de1316c12b65335c227895830aa035571ab08bfe949b62ad561a16faf8b1a6b1acca019e1250801b7aedb0b91f96e9e2f2f4bae85c0645487f879f57d6c664820164bc0e318a04a81de6ea945fb8aceb0b25aa12a501ccb47450cc78bbd87ce2d1133ae65a5066677ce74eb3caf0498453cc491be4579e0b6474dde127632c0118028ca857aa6eae20bdf7aba181f2ca5e0ca6e725c5cf76c11ac2cb3f544f9740628f830ac86fe78831bda726d5a63bf4c3c473306a1bd28a6f7c8c542ee91d6c9e497f1263709fbc046e5004cd381e5538d9d3741ffc5ce8aadc9e3ccafd1b0bc23961ee148039e8c05fd05e0d1ae91e2ee8ba845ca753696fb4200acf2a1c23ec36a23b9e36d38aa46a2fe7f744263aeb32c354897f51e9233830ad790343860e51e525ee834191773a0f205136c78e5d77910f52aafb6f4334d3340614d15a8559d5ff8993a45e7a9359f25f478d0ab2decbf3c844bf3cfa10636ec82829467b0180e8841ada0b78177c285c3814d1c556a7a0be1f22137d0d31673113c3268e85639f8d3ad481addd566eb77779483e02d721a684f9722da08cb0fc420c35a356f1acb8132e0118dcfe7de6102d7c7bee95e3fd0fa79cf53aac5ad28d0549ba950b2d73eb842206b04eb39fc16dc0afd93241e3cf3a9dbe776d665595154facba1510e3d7f42e3ea245342f39586cef019bb59f545ca16568784bee87c3490f6b258496c0c18b2fd3d21ecd223f600a490ab19f6c893a8c3ab9a40c6bc8d88e70849f34f2a7990d5bdeabaec5b35a3f6596a96efd82f63bc587053e467235f1d5651995bf301b2f43712e9ec3d285e46aac5e362fb7e2ae17bdf804cc7b8edf81529c97910f28a29c77bce28fb4e02b2bedcd6f18e7229887cc50bcbeca5bd62b41ea1ef3ded0f3af63b2a1fb68056d61e70e7b34bcd23012cac9b04183f8e23716c1843631fe68ac5713fc08f4caf522e9ce901a05229f2d5d8bed5378ee4d6edf991576f9a40a55274c21f152531284973f2426db9346833caa82a94f2f1fa802e965efbd5a048ff6a1e315f921df2aba3a56724d0e3faa1103340bb9ffe0791d0cffdcda2353a0ba632356f186d396374ac64407f405d1a1d256e0221f0299531f733dc5f20e81413259ddad7c39d48d24d984193c3dc0438b418cc24726f779a6ac100ef98cf6a583c1779801e689a67bae8f1b084bf3a8409deb1d02715995931866effa46098aca6f4ea883016cbdbe5cf6b2deb876e48e44c4e0d73b82858fb24101c05ec81f112c76363aeeb5882b8c43db51f664ceb261bab788495b6cd9afe0b63844e8c9c112155ee9a7b03db1b79fdc2b1c00b067b7074f6502779aa92fffbdc5dc926df9cf2925e24503f34bb26d76dd5abe1a9fa4dd597a3d7848bba43ad43a093e4fa3c1a4b913976395b1575870ff5516ff0e6bcf225188e6ef03a036d94837b813bf9992691ec34283d94eb3cebfa971b682ef6321c458584ba09bbef0369653491bec37f295e78b259e352f7df5caa7050da890e4cc7f0f2ae678a1664d9f3247791b09998a930d611094a891533b8d02ea6a72b0df4cbcc448e135e88f3e218815a9198a79715363cdfb6185d29d062990cecc1f1ec33fe2e99f3201f004e4782de06558bef6818f5dd0fdeefff22fc5f20eff343680c8b58392e12b0081571325c7df99467e1e33518c22a8f5179d6424a385c72aaedf6eae3daa3f165d2478c5f81eb06331a93414a6e4547ab52a26f3385a690c05a134c8d0ab03e67651496c4b1af2f3953207f930fb61387615b39cee86fa4dfafa6ab4a2f008c1a37cb938ef0d43dcb8843ea75f9f0e2fd1c917a00a19a6d6429420d8967470848e1c9fc6ea8e79ba81e204dba674c78b1a5d8b9b6e103427a4ccf7a295bb7e2ac73ff3ce3028c1f267f0abb9d42b6ce1d976abcd859cfc350211bb9a991c2095982c53986d21db81c067080da7ef1411c14f195f5afd0f22094726123d89238b2d3c54d012f774ba027af22ed8bdf4443a311332bb83896b4a338f13e9461ffb53ed6299fd4b262bbd6f96562ee84bfa3b8a2db381d6684f21c14ca3f7a295f202668ffeea035f8438b648c3d1c7112b824f1770a10dc935d904fb61aec0d71dd7f2135f829a3770b071dda7b18c3b75953c619d0fd87fb2fa2e7ded36c3d443cc055cd572a9b8e619818a2447ea83cef542d67d1e7e340958a42ee0b90ea5152660bed6904b6822ce8c8005885bcb362addf1bfa4026f0942f238d2fb1a2bd243272c373e6944cc4712858c31291d55a4446ed050a87f935424ca05b3f755b774c16e7c5fbc1afd686499f9e3d8d248fb73e4ce17cd17724ded2aa93671bd77d7baed78ff75a4ff3f8a4280ad46ab31cafd713f89aca87d885b9ce0041c5483bdbc366a7ba57d3059b49173351edb96886f41dd94d7a1badfa8d0b991ce11754b63abbb59e049281e32c12ea853373b09a92f54e24b3069ef6bbef4ed60d11c54226b9e5df27878887c1881f6794ddb1db7714d32c1450e740ddaaa12fd964d39995c5bd44cb7ad1a111122f532c26f89713983716276648128dc03a3eb9a6d39b4bd2a55a5203495d3c6945a2836ed5b28eb48f69b2548290eb2b11e491e8c835e0deddae766acbabb208032580e4e3b2fa156365b57768a2fe1ac9128f9ff5fe92ae3c416e1796df0ba20f338076f41d1bed3398ac01462115483ef4a78fad751bf35dba265d5535ea2d68f7c9486755dddb393d4f4eaca15a7122f70fb8e179c20cfb9d5731ac97d6263b05530511ef230dda8f8d1a7904de6e45a399f9982a6b44e9b63c4d11909e7556aa4be7a1244e8823f7ab093bf1329a868d5cc2c67147bd06f4c0a1a24a47527109ee9df44a8a3152b83e7550fd270bbe99bb8cdad7fe23ae0b6a2366cb16f019916cd3b1184268a92f782efe1c0877ee57babc98c89ba9e14412245a72aeab8c6d6afb8ec0091e2b294a58352ccc2fa83dfbfdff854fa9d84045e6af156079d4fe7c598414354a5531f8c535bea9311b187c59fb069d9b6fa386832d7b4f5877a618b19906d94303ecb404d59095c2681cec5157e21d1e4863c286280149c3eb4eebc57e14fcb7504334f28e33b7903b68892e96374ff0c01ba60dedefbff304b5090180edcc0cc20282ada8ec3a6f40aa028d45343ee72c9767f9da615da1b50fa68c05f8bbc634ce4a0156763fbd187dcbfdae19adb725d414922299c42cd6313e0d44e63e65d954e538e9b4140c45a896f284af575e0867835626a859dc61f391aeab90e3664c050bb3f83c4777aa38b0c9a7c4468f66c33bbc2b01258ef7c2a2919bb8403c51e37b9bde5580a972844d3e2945627b16ac6a93a1938b96e907e4f3b17bb17c791de4e17b5a6711d72c4489fa25996188d6a4f403b83c9582dc0a6b0baeee9c400554a68c749a99ab10f21431b263b3f51a4efcd8d0f7743f3003c4c0a9a89db15f1f8304eefd132be726227472a220094f49ad2099a5da57fac1f12bf02d427aca796d8aae57491c0473447c4029a3d2a512c391998a701eef3ccfbab2090b1498f35dcdacba61a20a8ad107082f4bfff17d7f352b409c767589ca0e5910d5a504eb9aa34b0c57e4ac785b7f3951c350eaf782682c466452d8b2e25919057958c21c069591ee41252010965e29e5619bf7fe3fa634c05c3436e07033c6c6de5055d3ccc15a0c9c1c9abb542b79cff80f749af94bdba0c233de51726efa6fd7503e3a08c7c25fff85b4ed8cabd7c3eb1ee45dacbf0d98d89a5cefcb42212fe2d1dbe6da4e2ea1230aa9993307eed47b24f7c6232e158ec4d08f824220b8a1c0197820394ec7ab31ceefbec7c3701dbee1f23cad0645902b165d4ffde6646e6df28b1e323eebfb84d4267e5c3d31087b2bb68a81ed3ba8e298c9d066bc35b7ff51c1a56575510fc4ad2a4d14b5f463d291776b8aafac843fa0a385a7010a8433a5d3caed23e761479753bd6f82aa429dc8629b965be523e5051d9d1cd8b849ac57a436e421567c15a088c1ee92bad56bcfb2273954d0c68d2fb285ad7d0c8ad285c3cf954e9e99be4f9f35a06dd378c7edf0de407b54476d2a58509b799ea7240f38a79167367cd14913445c0e78d3e1b486edd2747cde2040798359def0bfa0464ea43f38b9db713a34b94e1c2c0ab51c5bad46a7e99ca4952430aff5f8050c8cdb06ac0a7bb85b34358ad16eb784864206e1e1cada1aa871eb7bd05c8eecc03d2bffec13bb8da94f22a91e9bcb3f8ec22d16ec7f9c5139f22325966e40944926917fba88bd18225f708ff73f1814c58ddabd67d76e6c7ab559e2ac94cd5a9be8c34062c69416ff5db165d49354e1b925af0c486d99134c4e815963a7f5ef63827adf00ab1a57a12db1015bf02fc95b5ab1944c119dfaa8de888b016888a5877dcc5149453f7a5a914eadd6deb2f765ca2545bf7cbd7e46aca817ec60a095dc945ad7c688dccf53cd8b548638221a5f6ed1717683a8b719c3163bac730ad9c3ca23727d557d3be010e96feb2c2698ec24e2bbd12fa79413d9219c28dc8325bae855a05b2ee81808fd426658551f87ea5ef3bcf89a24c4209d675e6fc9762cd9d27c7464778ee204b67cdae5f699070f338b310a5371a7c1e7406b4b3cd613e803ffcce366a77fbec9dab2f5af13ff4c090d2ffca0388a69027d92c7a79594ac4ab105bd3561daa986f0d86f90f30f2a0203cf6189fb0081fbfc86a103c362e1d5973984f7ed88f39414e0a19d1c78b6d9983b203c913418af51cfba4b85720639991dd78c5bfa3971a0e0f7e1add16f043f8a81034a743e536f9546590996be061ccac68565cbd71faf0b6a925621361581acac463fa8256892aad49b7948f55f1f982c118e0db03d264537f41d63c2b6e0e15962c788f8aba2b533d7e75269af18a736248972b69a58a98abea83441ef7bb70cffe639f9102e03456c9ba4d5b534e3c19255e00342f5a6e68a55c213a4ea3fe20f087466c644742a9edfe8cf1e5e11c666590378b0b5c65840555749db86ac7afb04659fd05403cf0c86f880f3d0cdcc366dc2dd320eff517f9aabb733452142c78f44975c77327ef7f6f841e54759cbab80a15cd5712a9a1ca2c263b5176ae589ea108d905e9f48937f560e4cd10a56855f02a03e971323aa636a4a4aea779d3d5fbfdb896797599b0ac74d2951e283530f19a59f010e8aec9fd96416eadf879b853d3935ca007806767242de9e701b7663c10b6ff3de421438061ba036a996631d70baf01268d4ce0a54d6d37c6e2033d3cac49f06e3904542987afa647b41b94baf6185572247a42b1ab19b82b39dfc5c66dc14b75481aebc6d958cd7ecf1aa36f17e91caaa21a5832bebc2e22f92edf6803d563a3704d2c71fedfcd0086ef80b51162393b2c8d8f6adae9a8846904e6dcf59ed72b170d4821932e2f1458ce69fbbabe9c5a11cf8eb5e2aba7a09b2cf518561a8256f1d3d01fa5fcfd536ccd53a60271a985b0977bdf3ab5d508e51a6f70e54cba7a7870be31462c10c894d08744848bedbc3ef123e334171661a4b98f9587163164b93327bc4f003a95bb8437f876cf1efbe67d19f74ccf4fa1c02cbb49caf4e6c9fcb937c7d98f26535ab570fca2c6d18301d9a7486b91f3f18d4daffd8fdfab996ad9a8101c85f4c03b40f84e24d06ac67567ff5ee44ea26940f84ab1beae43ac16314d29a889bc08723b8e5ad88d89010046f9b931c0f653110c0dda937dc09a429e8500629cac5a55cde50438db9269a706b0d6021eb9e16147173e90338b4a13522399fa67f90d40dea23192e1702154556d4de23ef7d5a5367dc3dbe8b9daad3615abe6fb8e44ae411577392dce7311dcafc8213c3f18f569f05d43c8e5a38a8ac65c373fa4e2ba693a6d9b1691d9003009e6578ae11e7779d0309019dca4f8f7989260d00efeaee4910bf264a0e1d941ebaca3f06e789ce20cd1d6eee163140bc59969e5bbb7cb80a1d3d3dab510add30c628a995c5631a24350f9fbae4427fc6b16d282fbcad2796b62e6b5533cc3b88ffc6dd447dfa668ea8042cca922e6a24a28da1f08f93259ab0b63b400f81d547d4eb4491dffabf37953cf7439a89ce734ff4377fb10948d47734dafd4f98e760933b48968da5ec0b6ac5b964fa4ef6c9ddd38bbbe13d0014666f8bef2cfe0e2e909b916a50e81827433f27479140c6e28d7607856ebc2e1bc232545a4fff88fe8811e28e1314bf09f15f6ee29fa24f5bde6994ef73eb0784b6fa3ce5786a4cc04c6ed4d499bf3f0e5001f8beb7edd14ce0cde82f636d90ce9d8f84da790614f979ee96b8e945b86318ee0ecd1afbc58c2d073d5ba04b1304b825c4eb2bc49c3df4a2b909264759a93aeebd0cd65950ca6a73c05568de9b9b2e0386829cdba1e77fac80c881d04c4fbb1ffb4d0f3c237840ed8a15494801c1a1e39d7012d30be1c11842e08e5adaceffe4080fde79643bff779bfce69ce40fe11765d9c0ea2b0336dd494934751bb7a551ee68e9f916b1a2d661e4f6b5eb6cc58b392ff820f3e7a34d27d27a256c3860a9d28c806bffda98c99e35acdf4001041cdbfd85fd8528fdc77f5b85e96faa81a4b6bdf3e0e9ad9aba4cad0251b53eeb5a994134b948ac08eacb00af708942e5c0ea376a7f5038763b2c164fd4a05d732185fbe843046fee99338958fee774ababab4cfbace00fd7ae51905d2d9e304a9eb99adfe61db9806d7063b71e337bae06bac3ecee6cc16f7db350ccd3f65c4413c450ce237e68388f49c97ee4dfa8348af61f8f591d85c9624b4783a140b0656545237ed24f9b8ab0abd4bd72bd62f0440fc5beab9add337abb748c7db12959ea3903863ab0564062be9f23ce6600ff1943a8978f1f2e45dd7952f489ffa5ddae284da9499da0ce93b47f301a301739df74c52dbe87d8decf3c05d96c45009dc4b4a65d919e9700c1a255e0ed70343d5689f6b1a8b946faf7e44f94849ea20edad1d4e165720fff5054d13353a9ec06f3629583fb965eb1d5dd2bf7e61b8afce8986735f0b11131d096d0fda4b3abf09aa9b9055509aaa20ea39f5b57bc3442fe20ac1c43ad0f803cdcadd3087060b72ee08ca78539b956d7f7b4654e7528f6bcdf7cb50e8b136355ac6fdd7bba95df5eaae30f8ec3b70ffb4a99034bfb2c57732ea9aebe402a8137ff5626fa0f6af3e7bb646022134ee465c2464837cdc890b34a71ebe9f9d50a6b3591990c4f5052180e1c50f70b6953d3a2653cf0e853d2c9280840b50790182c7e8aa09e9d6d6b68184b99a2938d48e0339bc4e2405f7f09303e6bd286f9894ce3786b074a60aaff4ab1028be93b0a9e600e679d08f6a4537c9abf57b7ef4ba2e05e9d39d4ea2b610e1b2bc3ac4cf6d55c92308fe8d0cf6d14a40b22b7ac9b5e0d4cc463b7667d9e39a1db0f00fee74a7a8a82029a0f175e970ed077bf1cb4960f22a04a7f60d1327e150e12c084d4fc2ec5a3680e44c0b9602b0239de9efa8a1a4efdfce6ec7650cfc1cd6e684876f2c1487e1c2286fe268940c98cf051bf3e64b76811118839de26d6b464b283fb9d936c67b3d7824a3987dafecb0606ed8f8f70f3b526872057566009fa6218994d41ae9059d05c2e4f0625b4cd80bc9ad95cbe28a9e1e4d94dda07a38925d38e3a8bc9ed533d1ca9b682021a7d517400a1742f76709bceff7dc79e2ed030d657d75b0a05ad74779b0e19409433224a57a7e48ed287b0330b8b9014b2b4b271212d3b46ac93b1e916cd125e539adcf086a76a629cc43cdcd59ac2674b22cc07ba4ed3cfc9e3fdb87c8728e312258d836487959c11ae2f876627059360290f22b3665258fbe78e8f8484284ef9aee1015cc7ec486a49d9e1285fe35e674c51021a025ca9eb904e539777a319685cbc135eb83495f691e0511aabe1a49091c8f84e81cb9758ff1a165b664216f462215dd9333986208816dae49c17b4f0dd19db74ce8983ca49b0f111e38ef880212e950259e3c64528eb944aff66ca35aaf6ed01985afc1e4789776255a6968356009099eb2834ad93807ce3afbba15cd8b5e5e4ac3fa67a17c087fd7c7a087030dc496d5d233d2a633fe2f26e68f7b5d72959110bac8fa703c5127b3e8c0b6c2b3a84d92e887752c078ff5aaf99bb7ab4da786dd4e6618b221882c051ff3d0593bca2cae9602418564a521235aef4d7d2fe02aa38d1ff9135960d2d2c7a288f6f79d4b4d24ec466639cc7cb643e5674e22662acc3df1958e876f14df608bdcc0d9bcc7b2e53f76dadcb48333e288e79b85a97f877fd0f678f32ec8c0c96b108165a8e6c3793ecb5a6f2733e36576ea6e6591ac836655a04d4bd94bb3cbc071ccfc16f6e075b906c780c1e1865d83c4067aca24641b121c30576952ff33928fd9d766fdde5acea67184358cbf9d7148e062d8afb2cbd844fe11e023ed79f919803854beea9621b49a8998280dbedce6e34cc34cc95744cf2f556f1ea99b9e9eb49736fb6b2eb8c5cf6ae2eb674fd0d2b7a675a7618a33183ed8ab38a6a5923fb0c44941be82536663e579bb8cbbc9ee2f3637528726271566edca203d763c3ce0ee5702d66e62e0b6f7de13ec96594a3a3e4e344356348c823ee399f59b0b05d5d63e8d133fe354a7d43f8bec16d51ccfab6b8e9c6f217991fd673a3b12dbd8ae3c965bfcb40263f1d12140745e0d26822b87ae9e8b83912dc0b277d737d09fce755816e08de4daa1fb66dd21622494a1109e46891045541114de43252d4691bd8f18e81fb9fc06dc418055c05407b0a36a1a5bb65ded09a76d83b29f4c644bf52319f0f3010c58c1a16fd8b587c7f22f327f51f1399d0da2eb8965116469fb6be538005142e390fa3d573130a0d93ff86b3d259b292c0c05502344e0252e91817c2c483652469ce6d6d6899c19c2154e64a8f7d2555e87c4069e3596f8cb0a98d4eae9292050bae209b0c497bfc0c55a02aabdc297834cbd90aee9d5b1fef2d1f95e431d7b54203d930bac7bf2ebff1812731d14ab7f9dcb9a92b3fea27cc2d9c417aea45fe257f622ec41d6ee74fc31a8b9e52fa0c3b818c8da4b7f0103f3e0f5ac0f4d0d006e93b338ac3d4b95e376fd3be669d950622fff81eec1a7b9cf999f0afc3c47dc4a0b1406996f76624c99f26c66efa93afde55d9dcf8b05a4cbfea7feb33f2244f9e2c291deead70884a521d53a2e17c0197d8114720958a74290cfc9be79396b99f45cf6c31499e1dfc3749c4c02c69929579c60da882c77c11d91c13e0c6742d4b7d79e143001b763a08a7ed74dfeadfb3d65d31a1a1c33a10c4c2a25bdd01317e29a3c1799867d5148cb00391b17ca46809fb89860a0f777b051db79994c91ad1665994882a6a38ac3ecd6852e174b14ce3598fa9e3cf652fb655564e1bb4c0fd63091d9642daa9caacc126b6603de56135e39d28b83200211727d40eb50d97916a4b003871efba353b454353d13ff10e28400e06829f083b3a1edcafe80d86139a7565897bd2dac847e1cf3c3355d559e97348954bd92adae0224fe8727e4658cea8bcfd78d5cf2a6efd096d47b6556d8961ca99d1a77e62eef80d6942da5230b5b9213b81f1c7f73e16b28724993e65dee075ed527ac618a6d91872e3da6c061c7552e9ad84e3cb26d082052d87db44e770eaa8b15394ec008330be52e7d1674f99253157303de708bceb930258fa65a4f4a4f7c9a6c364036459eb13617335ca9debc45f28534343c4ff16260bfb90e9eba6b1447ac62675a306491a3e7f88a4161e8d5dacb3a2734890e0d56c7f578690a7103e3bbd8a64de51b4d9041d0720596ad9464c9ff8b9ee192e3acc2e53328bf664e580702934e2afff2c561d9690194ec8a97484a5361a8c198736365a807e8a129d8e5d8db16098319de8025d33663bd8e649a8757415a501629e16f3864ee4bb297d1bfeaada61a277fe2e6f12d9d171787b2444d3e60ad34e81072af11df24bfc81a77da985c4544fbe23808e8e1d5fb94a2500584eabd2560004cf5e13b2f8dd66b1057ab9d42d1b1ac9e594b84c7c4dcaaa3444cada31f7cb4d6e933c45e32c526cff4e5f0feeb50e739abcd1d12279c0455489d1f5485500fff4d6990dd93c2621326702b512ed04e24bc810b2bff8b7620af8bf7e2c93db1ec2c8c3fa70f3114b9bc32622d3b4d78d2aabcdeb46966ff3ad43482ff22451d57a3e9f4d57df34aee663d656f9bc13fe3f9e60980de34a054c10a3e7a3731864dd9fbe0786f873223c9f38d355cc647b63d43ad6a2cad40ed2b700938d0e8128c6f5f64908f1f34aa2991bbeef1e4cded7b75458101a4b8ae30731eaf3da26895aaa3b173843b8cc57a4608ea79ab5a510638345beb0bc0bc1c2f934a748fe5aa43232f5b5aabc17e089cf7d042e49bc53c2a8ff08534d8e63715881098ba18780c51b977dde9cbdb4da6fc9b568af1ceb3900d839afbf56758ae348d8c217e23db2c69d6cc4b0fdef432ab46740e378c61eb856edb6eba8e8d4c895bd83d778976538bb59547d0ce2bb5f875fb289fb89153979b42d06dbf580143de3b78930894e863e011de196cf3d113f56dac7f7b507a76592e921806e546119d95789bbc11dca82aa995eb7e2df99f9cfff9e05c2541ae6cbc3276de3107087441567dd361a598486c7efb08938cac37cc26c686f8335fb1167a2f1d44bb893c3eac40cfbcc6c208e70694feac4a6756b8a3ae85a8580786fc82d9999c9310c09949979964f96cc2ade5e72586cc118969a642bbf5080afd313ab39df4d84ddcb6527234f0543bd8cf390821c477257e74680061585a7ebf9893e2981ef651f747f53a7927983e8d39925ca97be22a15f42c264cdbdec09d0764cdbb3522e33045b29de046e6508de235b9f4309494f7116b9a7f7d2e0f9c07a98db8669f42a26506e414f431f132837a0e2b9f045416a161d652a2ca6f1720f57365b4f2d09d7a0c7aae32e648c7f05c2ef7fcd369d92f042fe42800dacd8ab8a1a5fc01c894b95dc9ab59c4436449c58d9ac89b475eb9c21fe78b6cc153da4bd378432260c7bb80ac87164f9e8238f20e3cb75605bc5d68a43af3f8c18dd898746e7d4b025d3498d3836a8e58a4bea40daefc5057648341a80e91a02b036c41687bec2800ff76aaba2b9767fddfd679eb42769dcf7baf1d8d1e7e15f176b3a00be543827d0ae97e5cd4588ad7dc6df1a4c69bc2090ad012c8ce0f66b9b3c9d133fbdcd818271d8e71d262246d16fec4068be48d3facc25738265499fdac4d1d61f1d4950e3de4aab8506f32c880929c721c8d0d72cc5d00d7f3c6c9731d71a1f2e3365e4ba93ec3eab74385b91551e4ec76a71fc9eaa745ec5bc0dc7ffedce481be0a4d681f6a9dba4af3f9e336331c9cdfc6944febcee7a566bbfc1b97e0fe5356ff17721c46cd4bce7023314ae3a4b216ac597d7fca9402872c4373193e06f505c2cfff5dcd8b24c5ab1fad5b1b4668c6929fcd1153e06634dacf4a87811c321961d6b44aca15682fe8f81fff3164793ee5709bbf207b28c0db8162edf4027a8f1274133b148feb9908b6308dc88be4c7cb5e011853f386c65b698907bd1bf6bfb46441daa3e4ab524fd9993e6f1f21bbde67d9c8d72b4d36b563d9630514c68e024b6d8c9ed1e0bdc65122557252710730271eb215ec203579b16273e63bccf3a61a87d6297e9b724ff125aed70524dd1014ff2a2420ae61e0d6b0c4b6e27f0e53a450acd9bd9734cd31c9f32f8306c1bc30f12d3090629704e15a18372d33dd6179ed5ba04fd572f97bbd1f497b2d4f31870ebc1166244bd0539d5609ed937f2202c76fef3dfc0ec1f995af56b25811b0c38ade7390b3569172710504cc4cb6e871fa6f0c7b171998cad7884ef76f9f389c001a85c4c1c9498febc4cfefc6aeeb7daac43926322c62d25b1ae1258c229de2b4e24fa8355cdd16a9739719af589d1ba9c9ce7170f55a3426e6dbd40bc01edcb10ca0b6179fa0a47512f4fd77e6f87090a790accfaac88b866f7f1bd2fe63a98748c97947bb3605ff390c696ff0a7b369106434426b4047ea808eda0094053c7b054932057e62a43b6569fc6f594f02ab8268e189ba8caac69be1b9239a92778e3216a4843c438b647abe8dbc6f8cda53b10ab0e7729a20980a93705d08627d9577451c769400a3ff29d882f3edb4ca9b7f02b035d093c181db4a91936c2e31b5e52de1b06ed619b00eddb1cc01ff01caec03df5a4320a8dede12305ecad6d3b7959abfb3cca1e70b1f54132a3822d53a81be8806f78ffe793e3458fcdc14bc2fcf899bec9fbb6e619bb068765cc998f7975d8d6086cc6713e85527b4b590d08303d01e72b5d7d39d356615e689b2d60018e38979d18f05dd8311bb27cf86803fbf16ce441a71d2923bc77558ae2f0d78456aad749206cb31709c9ae5e9f173d09512f71931ec3617042b618881737af2f85cdc71734a3580f9d516ddc1f416dfc03b45ca92851e7ab1ac64a21bb8fbf4096939edff5e484291dcab75681b87b42988c6f77a6f1ffaf32480e81b7369888193f159eaeb49f6468653ee6924cc8e56fea349444f65636bd2989a7ab2d7111871c9f24696e67d3469c7d979e195c555ca1c242863c7911258a15400e16e53c27b09779bfe0038cc88cbbbe6636aabfd276a625d20715bda46e24c17589a1339a5d9bb773ce47325871cc7444153a0b467b61c9a2480b8e1651b8bd138e72216dd9577e4dd67753345b69ff44ffc80ac9b124fbd41dcdd29316980e0542e9b3be1cd68c1b1189c19fd41c61dd9113d92b6a88e6a1ec90564b27c5aea0041b5c90919762692f4e299768bbdb38f51ab3a26804d1d5c75667bdd2ce85350bdd08d668d6571beb79156d436309b1e155964db67451b7c0ce29a6ab799f3f52c6ce09436ba7b5f359a218fbee3b9ec871b693cb938ed2e3d28c0f67a7ae4603c6c8d3d9feb673c8d1937766abc8f35174744024f0e3c596c2d69ed71a342ab87082ddf85c8875e77adef3c98fb935bfac2d1646bec2b1da44ee5897f36035eac9b03beea619dafa44a94a0fefa437e8390d296e07c529f1b9d993b72224b7419ea04a6071c1259a90c4c8fa9d20eb66190aa161807cd23b4aad116e49bff9898f36577cbcbeec93d9bcb8159df16752423b0090cec7a8213262dc81e5aad168bc7a86e1a4ae210d7994176fefdfc121965db7a0e563edaac67ff4546cd87f760842cc4ab66a35c9ad16a9c84c69b8d7541bff9d27c417970ba59be3626cea75c40cb53e1ffa2cb5fb9862d5008230cfe4fd458cd6d93f3cbd319b3e5cc1c7fd907fa61f49429c37f88eb775c31794f373fae2628366dccbab80d035dfe39144f5168b21859fa443173beae585c2208fed4f7a7b6f16618f39c28032f0ee8ef240253e0d802bda30d8a921f88d1e7c60ddb37d574de4baaa91dd60a464b77b75456ba585c3d6866c33054405946bc2416626fbeaa5219097905da20ad9baf12b8f96c66d3d438d49b86018ddc43b675b053079f1b1a1ad2d56bd428dd513decc7caf8ab5ed568e5d45c890b3ecc4f6f318c4130e068ae7bf86d39865a5ff735a35922b2e4910a64012b9b941fec2200e2656a27de15361deaba9da47a1556b050547b77cc0ccdf57ced0df4597781a18e7180b5a8c794700c4cbadf0c221bf066c8b2225dded4bdbf4a9e84bf3b2c90892ec5794c6f58987820798e69965b3d3e33c17a193b65ec7cd110b5b3499d599d2011070606e08698b5d570f0dc6b974def5cf746cfda570e2a6deccdaf7ff42e0c398df383dcd6ee504969cf1dd80ea3d9387ae9c7ee2c038502a55bd638be37d6f2be7e49111b8cc30ad1c75d324b771357ba2a646ce7b21102a5db9d284df63e4d74b733df95589e8a4205d115ecf3ad10178788de9d635ad29c65ba8837c9579d4f733390a25c72d83a8f8f8ce14014697bc64c64299e624e5ee6d6805c2340f75e44e5d9c4631652172f10dc940b34816bac659d43c680dcd0a37b54c0aeaa9d07175e86c60de7c76e9f2884a256217bef922598dfd5dcc6cbede01e9fe8eaa8a72145e55189fc599adcd695cc53cac178620b2a8388bf5045bc2f2ae23e6e0ebceab88d7c4020f90e1d11fef02aadecc17c2e4816fc7de7af8482c05b1edd7e2e18a8fd5334d83c242938373861d129b4b291e74d6661321327c636f9b83ac3204bf48f72e863141e07982b185f4fc9021ff7dc014c050ab495a7abf3c3aa8de24bf76d29606908921e0ffcd56556a6f82c3da1ee35242a62bda8a595a543b2933ed11616aca4a0b2980e8a82f348efc6d7887f129ec06ea8751270e6998ae50efb350ffd81e12fd85115e37c90e4bbc3a70eb2bdaa0743c77421c5aea773c490d9adfbc645d299e1b4976f5cbf76e1e6375e5fc3e8e4963574a325cd18b2cbcef4c8e89afa76c224db22541ce54542980f91d4dacb5d4cdf84086100ba0a3b976cfd8d4f34a781d5393ce70f4f5a88114a07c03f0750e58f2c30c6e3ad87cea1ea79658e415eb826a1ef82e0798e94f3a874b71b1d3d32c93be982f0076a4c372fdd534ca47e36a6700d43fe502714999945d4b9a547f5996e353ad3e9faf246b36ba58ae8bb054c93e70e91d58294328c0c287aa1a6ae2d91c7382be7e56550dde348cf4e0795a60a48d44d89add1c34de5b3bc0d02f9b2f7c1b44f8b972c9f84fe3d1ecdb872d03affb1cb48f0274b4cdf57da322e45a80d4a9bd31494f5b65e0bf696fe3cd1f06961436152cdf75ca3572f599d104b755c1c8c93d7fc50921f4aeff083127eea2be44cb9cc17f7eca1a3014435ab3890edea63d27d615d9764c7e17ae2cc3b2d8915d562c91d90fa7e936007bc75b4c5b7304ed78be2504ee048b590d3a6335b26a70afa9f322c0cd858253f0e896bc58c7b6bb0064db744621ec1c955ccf0c605f50f8b1a1abe1176ea0d11010bb1acde58fefbc8f1de0c59045d8371c68ef92900aee7b56098c2ce86eb0553e22246561c5d40e427af56dc3d0708f3c6f8053afb430e6f4c62b1dcb3f71b8901dd7b99cf5c451c92dad23f68e086dee7a47dd3b8ec0ee58d7bd02b26cf401dd57a2dbe62565c231bd1ca255aa9d3fbcc403bffc42aae52470418c6531d78ac77948af6a66af6085c884b3b16aebf482d1d57b11e18167d51152d44bdad63fcacb8194c53c3011e351bc7197e1a18830e38a951db77037541799f4011c8940264bab7996254e084827ee159b5eed5da659cb65c04ad184127b263fc2e19c12d721cd42c2131200802af523d021429b2ece9c1225c9ad9a6a02363f1119d4a0de9478961712ed7a4efd6aed660b1371a64d3d5ffc467a409fddd473c440ffdbc1793a73d4083d8df7b972f33b371d0829f26523fa3cb114cdfde2876770d94c23e2f52ed3974cdff6ee91c443ae6315958278af65a423fcb25b9aad8a4fdf5f31bc5d54c75401651f6d0e301e515841ae5adde993794ea058f1ed8a0614fd04e4624bd5fbf87775aa371f87f87c00dc842fac4f5431a67f5f67eebed3df87a954761e57c29c7184768e8c0a3d7f8541c9e81322ba4e9c369236ae10a250b50d9edb0eacaf49f537dce7572acab11f79cc5de582d415648a1da340b453a12d176d0a0145c0b9c5e0f70bf29942b5ab3a4f0b866f5dd567f60b18c27a55009d7808988dbb2b5d10e56ad46f0833e993f7b81b882570349c8e234c096ea2d0ac25bf2c793080d3c6a63bb1aee85509c94c21ffd9f27dd3324d9a92e33b30112b14651c90c4ed9d822ca4fca4e12fa83da8e357a27175ff392a1ab187cd84ba37adda97f5ce7c8810703aa936ac3995f71af79f12c9d292f20307ea2d7dc75a5e53129516941137cb099f9f25fda120292385efd323ffe2eac477a34513358f74b380cdcf77e8abaf65b4d17dd2a24472141c8c5b99e153831fc64beeb4d2dad25efbe2b4e7270fe96c3441158af56bf8199a4ca33e9bd26078262d96af1014237c76a798047576aeb6ceb1cd4e853dd0299719a5cca00708110f619e656e9422d43c4edfc0226ca0197536c945f3784519908927faf4686fd281733c396419953483ea7fdfa8a2a2bae86dce81dc4b45f14d575a3e02aa2dead043dbca6cd3f89692c5ece4b9864882940601655e9cabe06b291bd980c2e597d4ad5ad5a0f4bd34afcda6386fdd51af52a7e4aa969c3aba3ed98cf2ace99e459eae3eeb5f0f58d7aa59f600af1fa15155438643fc0c84e87bd1b233e5ebbfd7f382453c6566c249912b3d7025ef2027261f65f2b69029f7919841e05926cf76b79684f035aec8df03ca1401af1e7644bd650f7d8b135303fa13b739adf590ae2d3b951b2f408fe4d9160c242a25cdc8e695b63e296865e897aa861f9810212243e2e2585b3c7cbbc62b21f06b9e3ec6f46ed2ac121cae49b0e0974453eceed5e3427cc11ec687a204aa68066a1a9fc013db4468a20ba5ed3d2de8f6ffcfe0242092b07ef3b616d98549aa49b245483b1d4c849f572c73c8de4f5fa39ae5c643039792baf91648febd101bc0b9d17af28cb4270f6ab73eaf761d32c5fb0f25a65b54dc83c32d6180161bb4494c255ef7975609fec16a5bbfa12fc11f8fa6db3436ab7c93a6c9553852931b9c4c0490b6fb401d072df1525653332d2c65f679b962a2557cb97bdcbc927cfd9bb15a2fdb2cefc814c54bf8f46906c5d06645af1521793928d637c8abe51b5c91b9690ab1c1ea3bbdc6572e373d9153e7b552475d6588f202c12a104ce8ba915741d12292ff5e5574be80c471629b2ba634cb1091cb963a0b2e6ff4bf48e3dabf90fdf114b1bded4fffe3019b097f367542b4276a90468e0b0cac399cb2115709da24bbb3fda4137bcad07d7e9cdbafbeb5ae4fdd098e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
    <tags>
      
      <tag>博客搭建优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
