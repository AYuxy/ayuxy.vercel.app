<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>9月份计划</title>
    <link href="/2022/08/28/22-0828-01/"/>
    <url>/2022/08/28/22-0828-01/</url>
    
    <content type="html"><![CDATA[<p>7月初开始去南京实习，因为必须要返校的原因，只能早早的回到学校，实习期间经历了HW、现场和远程渗透测试、以及某攻防演练，认识了一些好朋友(•̀ᴗ• )，对安全服务有了更多的了解，对自己水平有了更加清晰的认识（啥也不会 - - .）</p><p>9月份要一方面准备秋招，另一方面认真学习免杀，在过年前达到独立免杀 ，同时学习各种钓鱼的姿势 ◔.̮◔✧，同时刷htb，学习渗透测试思路，距离毕业还有不到一年的实习，希望能在秋招或者春招找到一份合适的工作 (≧▽≦)/</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>x86保护模式day5</title>
    <link href="/2022/08/21/22-0821-05/"/>
    <url>/2022/08/21/22-0821-05/</url>
    
    <content type="html"><![CDATA[<h1 id="现代处理器的结构和特点"><a class="markdownIt-Anchor" href="#现代处理器的结构和特点"></a> 现代处理器的结构和特点</h1><h2 id="流水线"><a class="markdownIt-Anchor" href="#流水线"></a> 流水线</h2><p>在8086处理器时候，就已经有了指令预取，当指令执行时，如果总线是空闲的，那么就可以在指令执行的同时，预取指令并同时译码</p><p>执行一条指令需要如下过程：<br />取指令—&gt;需要从内存中拿出指令—&gt;然后对指令进行译码—&gt;访问操作数和结果—&gt;并且进行移位、加法等其他任何操作</p><p>流水线可以提高CPU的执行效率，流水线把一条指令的执行过程分解成若干个细小的步骤，并分配给相对应的单元来完成，各个单元执行独立的，并行的</p><p>正常的指令执行的时长如下：</p><img src="/2022/08/21/22-0821-05/image-20220821160333343.png" class="" title="image-20220821160333343"><p>如果采用流水线的方式，在取指令的同时可以译码，在译码的同时还可以继续取指令（压榨CPU，让CPU不断工作，提高速度），如下：</p><img src="/2022/08/21/22-0821-05/image-20220821160518407.png" class="" title="image-20220821160518407"><h2 id="高速缓存"><a class="markdownIt-Anchor" href="#高速缓存"></a> 高速缓存</h2><p>除了流水线会影响处理器速度外，影响处理器速度的另外一个因素是内存（即我们所说的存储器）。从处理器向外看，分别是寄存器、内存、硬盘，寄存器的速度非常快，其次是内存，最后是硬盘，硬盘速度相对要慢很多，在这种情况下，CPU的速度很快，这样就需要等待内存和硬盘这种速度比较慢的设备，CPU就无法全速运行，为了解决这个矛盾，高速缓存就出现了</p><p>高速缓存就是处理器和内存中的一个静态处理器，容量比较小，位置在处理器中，高速缓存会缓存程序在运行时具有的局部性规律（比如：判断程序经常执行一些指令和数据）</p><img src="/2022/08/21/22-0821-05/image-20220821160729512.png" class="" title="image-20220821160729512"><p>如果CPU要读取0x10，如果L1一级缓存中没有0x10，一级缓存会先去内存中读取数据0x10所在的页，然后CPU从高速缓存中读取0x10</p><img src="/2022/08/21/22-0821-05/image-20220821160742964.png" class="" title="image-20220821160742964"><h2 id="乱序执行"><a class="markdownIt-Anchor" href="#乱序执行"></a> 乱序执行</h2><p>为了实现流水线技术，需要将指令拆分成更小的可独立执行的部分，即拆分成微操作，比如：加法指令，如果参与加法的数据不依赖前面指令的结果，那它可以完全提前把这加法指令执行了，把结果保存到缓存中，等到真正轮到这条指令执行的时候，再把缓存中的结果写入到内存中</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>转载：CPU的熔断幽灵</title>
    <link href="/2022/08/21/22-0821-06/"/>
    <url>/2022/08/21/22-0821-06/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载：<br /><a href="https://blog.csdn.net/xuanyuan_fsx/article/details/106052513">https://blog.csdn.net/xuanyuan_fsx/article/details/106052513</a></p></blockquote><h1 id="自我介绍"><a class="markdownIt-Anchor" href="#自我介绍"></a> 自我介绍</h1><p>我叫阿Q，是CPU一号车间里的员工，我所在的这个CPU足足有8个核，就有8个车间，干起活来杠杠滴。</p><p>我所在的一号车间里，除了负责执行指令的我，还有负责取指令的小A，负责分析指令的小胖和负责结果回写的老K。</p><img src="/2022/08/21/22-0821-06/image-20220821125419547.png" class="" title="image-20220821125419547"><p>CPU的每个车间都有一堆箱子，人们把这些箱子叫做<code>寄存器</code>，我所在的一号车间也不例外，我们每天的工作就是不断执行指令，然后折腾这些箱子，往里面存东西取东西。</p><p>由于我们四个人的出色工作，一号车间业绩突出，在年会上还多次获得了最佳CPU核心奖呢。</p><h1 id="缓存"><a class="markdownIt-Anchor" href="#缓存"></a> 缓存</h1><p>我们每天都需要跟<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&amp;spm=1001.2101.3001.7020">内存</a>打交道，不过由于内存这家伙实在太慢了，我们浪费了很多时间等待他给我们数据传输。</p><img src="/2022/08/21/22-0821-06/image-20220821125541494.png" class="" title="image-20220821125541494"><p>终于有一天，上面给我们下了命令，说竞争对手CPU的速度快赶上我们了，让我们想办法提升工作效率。这一下可难倒了我们，我们平时干活绝没有偷懒，要怪只能怪内存那家伙，是他拖了我们后腿。</p><p>一天晚上，我们哥四个在一起聚餐，讨论起上面的这道命令来，大家都纷纷叹气。</p><p>就在一筹莫展之际，老K提出了一个想法：“兄弟们，我发现了一个现象，<strong>咱们和内存打交道的时候，如果访问了某个地址的数据，它周围的数据随后也大概率会被访问到</strong>”，说到这里，老K停顿了一下。</p><img src="/2022/08/21/22-0821-06/image-20220821125634033.png" class="" title="image-20220821125634033"><p>我一边听一边想着，小A倒是先开口：“然后呢？你想表达什么意思？”</p><p>老K继续说道：“咱每次数据都找内存要，太慢了，我寻思在咱们车间划一块区域，结合我发现的那个现象，以后让内存一次性把目标区域附近的数据一起给我们，我们存在这块区域，后面在需要用到的时候就先去这里找，找不到再去找内存要，岂不省事？”</p><p>听老K这么一描述，感觉靠谱，我也赶紧附和：“好办法！你们看啊，这内存老是拖咱后退，但是这家伙一时半会也快不起来，要不咱先用这招试试，看看能不能加快一点工作效率，给上面也有个交代。”</p><p>说干就干，我们很快就付诸实践了，我们还给这技术取了个名字叫<code>缓存</code>，效果居然出奇的好，后来为了进一步优化，我们还把缓存分为了两块，一块离<a href="https://so.csdn.net/so/search?q=%E5%AF%84%E5%AD%98%E5%99%A8&amp;spm=1001.2101.3001.7020">寄存器</a>很近叫一级缓存，剩下的叫二级缓存。一级缓存中进一步分了指令缓存和数据缓存两块。</p><img src="/2022/08/21/22-0821-06/image-20220821130113626.png" class="" title="image-20220821130113626"><p>我们车间的工作效率那是飞速提升，但不知道是谁走漏了风声，其他几个车间也知道了这项技术，纷纷效仿。</p><p>这天，为了业绩，我们决定再加第三级缓存，这次把空间弄大点，不过咱们车间地盘有点局促，放不下，我们偷偷给上面领导反馈了这事儿，想让领导帮我们协调一下。</p><p>领导倒是同意了，不过告诉我们他得一碗水端平，平衡各车间的利益。但是咱厂里空间也有限，不可能给每个车间都分配那么大的空间，于是决定由厂里统一安排一块大的区域，让各个车间来共享。没有办法，我们也只好同意了。</p><img src="/2022/08/21/22-0821-06/image-20220821131713172.png" class="" title="image-20220821131713172"><p>现在，我们用上了三级缓存技术，内存那家伙拖后腿的现象缓解了不少，相当部分时间我们都能从这三级缓存里面找到我们需要的数据。</p><h1 id="乱序执行"><a class="markdownIt-Anchor" href="#乱序执行"></a> 乱序执行</h1><p>随着技术的发展，咱们CPU工厂的工作性能也是不断攀升，慢慢的，我们几个又开始闲下来了，因为我们实在太快了，尽管有了缓存，但我们还是有了不少闲暇时间。</p><p>这天我还是像往常一样，小A取指令去了，我们知道这得要点时间，于是我和小胖还有老K我们仨斗起了地主。</p><img src="/2022/08/21/22-0821-06/image-20220821133410193.png" class="" title="image-20220821133410193"><p>打了好几把，小A才气喘吁吁的回来，“小胖，该你去指令分析了，你起来让我来打几把”。小胖赶紧起身干活，换上了小A上桌。</p><p>就这样我们几个轮流工作，一直保持着三个人的斗地主牌桌。</p><p>没想到的是，没过多久，厂里领导过来视察了，正好撞见我们几个打牌，狠狠的训斥了我们一顿。</p><img src="/2022/08/21/22-0821-06/image-20220821133444813.png" class="" title="image-20220821133444813"><p>“你们几个上班时间玩得挺嗨啊”，领导的脸拉的老长。</p><p>“领导，我们没有偷懒，这取指令、译码、执行、回写几个步骤都得分步执行，但是我们工作太快，存储器跟不上我们，我们等得无聊打发时间嘛”，我上前解释到。</p><p>“干等着你们也可以提前做一些后面的准备工作嘛，不要浪费时间，让生产效率更上一层楼”，领导说完就离开了，留下我们几个面面相觑。</p><p>不过领导的一番话倒是如一记重锤敲在我的头上，对啊，我们有这打牌的时间不如提前把后续指令的准备工作先做了，肯定能提升不少效率呢！</p><p>我开始组织兄弟几个商讨方案，“兄弟们，我们最主要的时间都浪费在等待内存数据上了，如果我们能在等待的时间里把后续指令需要的数据提前准备到缓存中来，那可就节约不少时间了，不用每次都等那么久。”</p><img src="/2022/08/21/22-0821-06/image-20220821133557943.png" class="" title="image-20220821133557943"><p>老K听后很赞赏我的思路，并补充到：“<strong>不仅是准备工作，像有些指令，比如加法，如果参与加法的数据不依赖前面指令的结果，咱们完全可以提前把这加法指令执行了嘛，把结果保存在缓存中，等真正轮到这条指令执行的时候，再把缓存中的结果写到内存中，这不也是节约了时间吗</strong>”</p><p>大家开始头脑风暴起来，原来可以做的事情还这么多，之前光想着等靠要，现在要主动出击了，因为打乱了顺序提前会执行后面的指令，我们把这个技术叫做<code>乱序执行</code>.</p><p>“这次大家要保密哦，不能让隔壁车间知道咱们的这次讨论内容”，会议结束前，我提醒大家。</p><h1 id="分支预测"><a class="markdownIt-Anchor" href="#分支预测"></a> 分支预测</h1><p>按照这次会议讨论的结果，咱们第二天准备实行，不过刚一开始，就遇到了麻烦。</p><p>按照计划，我们在空闲时间里，会提前把后续要执行的指令能做的工作先做了，但麻烦的是我们遇到了一条判断指令，因为不知道最终结果是true还是false，我们没法知道后续是应该执行分支A的指令还是分支B的指令。不敢轻举妄动，怕一会做了无用功。</p><img src="/2022/08/21/22-0821-06/image-20220821134224810.png" class="" title="image-20220821134224810"><p>大家只好放弃了提前做准备工作的想法，还是一步步来。</p><p>不过很快我们发现，我们经常执行到这个判断指令，而且每次结果都是去执行A分支，从没有去过B分支。</p><img src="/2022/08/21/22-0821-06/image-20220821134335630.png" class="" title="image-20220821134335630"><p>于是我们几个又商量，发明了一种叫<code>分支预测</code>的技术，<strong>遇到分支跳转时，按照之前的经验，如果某个分支经常被执行，那后续再去这个分支的概率一定很大，那这样咱们预测后面会去到这个分支，就提前把这个分支后面指令能做的工作先做了</strong>。</p><p>果然，用上了<code>分支预测</code>和<code>乱序执行</code>后，我们车间的效率又狠狠的提升了一把，在工厂的集体大会上又一次表扬了我们，并且把我们的先进技术向全厂推广。</p><p>自从我们车间用上了<code>乱序执行</code>和<code>分支预测</code>后，生产效率那是大大提升，领导不仅在全厂的员工大会表扬了我们，还把这两项技术向全厂推广，在我们8个CPU核心车间都铺开了，性能甩开竞争对手CPU几条街。</p><p>可是，就在我们还沉醉在取得的成绩时，不知不觉我们竟埋下了灾难的种子······</p><img src="/2022/08/21/22-0821-06/image-20220821135249703.png" class="" title="image-20220821135249703"><p>事情还得从不久前的一个晚上说起。</p><h1 id="神秘代码"><a class="markdownIt-Anchor" href="#神秘代码"></a> 神秘代码</h1><p>这天晚上，我们一号车间遇到了这样一段代码：</p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">uint8</span>_t <span class="hljs-built_in">array</span>1[<span class="hljs-number">160</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>&#125;;<span class="hljs-built_in">uint8</span>_t <span class="hljs-built_in">array</span>2[<span class="hljs-number">256</span> * <span class="hljs-number">512</span>];<span class="hljs-built_in">uint8</span>_t temp = <span class="hljs-number">0</span>;<span class="hljs-built_in">void</span> bad_guy(<span class="hljs-built_in">int</span> x) &#123;<span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">16</span>) &#123;temp &amp;= <span class="hljs-built_in">array</span>2[<span class="hljs-built_in">array</span>1[x] * <span class="hljs-number">512</span>];&#125;&#125;</code></pre></div><p>不到一会儿功夫，我们就执行了这个<code>bad_guy()</code>函数很多次，这不，又来了。</p><p>负责取指令的小A向内存那家伙打了一通电话，让内存把参数x的内容传输过来，我们知道，以内存那蜗牛的速度，估计得让我们好等。</p><p>这时，负责指令译码的小胖忍不住说了：“你们看，我们这都执行这个函数好多次了，每次的参数x都是小于16的，这一次估计也差不多，要不咱们启动<code>分支预测</code>功能，先把小于16分支里的指令先提前做一些？大家看怎么样”</p><img src="/2022/08/21/22-0821-06/image-20220821135655565.png" class="" title="image-20220821135655565"><p>我和负责数据回写的老K互相看了一眼，都点头表示同意。</p><p>于是，就在等待的间隙，我们又给内存那家伙打了电话，让他把<code>array1[x]</code>的内容也传过来。</p><p>等了一会儿，数据总算传了过来：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">x</span>: <span class="hljs-number">2</span><span class="hljs-attribute">array1</span>[x]: <span class="hljs-number">3</span></code></pre></div><p>拿到结果之后，我们开始一边执行<code>x&lt;16</code>的比较指令，一边继续打电话给内存索要<code>array2[3]</code>的内容。</p><p>比较指令执行的结果不出所料，果然是<code>true</code>，接下来就要走入我们预测的分支，而我们提前已经将需要的数据准备到缓存中，省去了不少时间。</p><p>就这样，我们成功的预测了后续的路线，我们真是一群机智的小伙伴。</p><img src="/2022/08/21/22-0821-06/image-20220821140235996.png" class="" title="image-20220821140235996"><h1 id="遭遇滑铁卢"><a class="markdownIt-Anchor" href="#遭遇滑铁卢"></a> 遭遇滑铁卢</h1><p>天有不测风云，不久，事情发生了变化。</p><p>“呀！比较结果是<code>false</code>，这一次的x比16大了”，我执行完结果后发现和我们预期的有了出入。</p><p>小A闻讯而来，“额，咱们提前执行了不该执行的指令不会有问题吧？”</p><img src="/2022/08/21/22-0821-06/image-20220821140404348.png" class="" title="image-20220821140404348"><p>老K安慰道：“没事儿，咱们只是提前把数据读到了我们的缓存中，没问题的，放心好啦”</p><p>我想了想也对，大不了我们提前做的准备工作白费了，没有多想就继续去执行&gt;16的分支指令了。</p><p>随后，同样的事情也时有发生，渐渐的我们就习惯了。</p><h1 id="灾难降临"><a class="markdownIt-Anchor" href="#灾难降临"></a> 灾难降临</h1><p>夜越来越深，我们都有点犯困了，突然，领导来了一通电话，让我们放下手里的工作火速去他办公室。</p><p>我们几个不敢耽误，赶紧出发。</p><p>来到领导的办公室，里面多了两个陌生人，其中一个还被绑着，领导眉头紧锁，气氛很是紧张。</p><img src="/2022/08/21/22-0821-06/image-20220821140529860.png" class="" title="image-20220821140529860"><p>“阿Q啊，你知不知道你们新发明的<code>乱序执行</code>和<code>分支预测</code>技术闯了大祸了？”</p><p>我们几个一听傻眼了，“领导，这是从何说起啊？”</p><p>领导从椅子上站了起来，指着旁边的陌生人说到：“给你们介绍一下，这是操作系统那边过来的安全员，让他告诉你们从何说起吧！”</p><p>这位安全员向大家点了点头，指着被捆绑那人说道：“大家好，我们抓到这个线程在读取系统内核空间的数据，经过我们的初审，他交代了是通过你们CPU的<code>乱序执行</code>和<code>分支预测</code>功能实现的这一目的。”</p><p>我和小A几个一听都是满脸问号，我们这两个提升工作效率的技术怎么就能泄漏系统内核数据呢？</p><img src="/2022/08/21/22-0821-06/image-20220821140718910.png" class="" title="image-20220821140718910"><h1 id="真相大白"><a class="markdownIt-Anchor" href="#真相大白"></a> 真相大白</h1><p>安全员显然看出了我们的疑惑，指着被捆绑的那个线程说道：“你把之前交代的再说一遍”</p><p>“几位大爷，你们之前是不是遇到了分支预测失败的情况？”，那人抬头看着我们。</p><p>“有啊，跟这有什么关系？失败了很正常嘛，既然是预测那就不能100%打包票能预测正确啊”，我回答道。</p><p>“<strong>您说的没错，不过如果这个失败是我故意策划的呢？</strong>”</p><img src="/2022/08/21/22-0821-06/image-20220821140925900.png" class="" title="image-20220821140925900"><p>听他这么一说，我的心一下悬了起来，“纳尼，你干的？”</p><p>“是的，就是我，我先故意给你连续多次小于16的参数，误导你们，误以为后面的参数还是小于16的，然后突然来一个特意构造的大于16的参数，你们果然上钩了，预测失败，提前执行了一些本不该执行的指令。”</p><p>“那又如何呢？我们只是把后面需要的数据提前准备到了缓存中，并没有进一步做什么啊”，我还是不太明白。</p><p>“<strong>这就够了！</strong>”</p><p>“你小子都被捆上了，就别吊胃口了，一次把话说清楚”，一旁急性子的老K忍不住了。</p><img src="/2022/08/21/22-0821-06/image-20220821140943193.png" class="" title="image-20220821140943193"><p>“好好好，我这就交代。你们把数据提前准备到了缓存中，我后面去访问这部分数据的时候，发现比访问其他内存快了很多”</p><p>“那可不，我们的缓存技术可不是吹牛的！哎等等，怎么又扯到缓存上去了？”，老K继续问道。</p><p>那人继续说道：“<strong>如果我想知道某个地址单元内的值，我就以它作为数组的偏移，去访问一片内存区域。利用你们会提前预测执行而且会把数据缓存的机制。你们虽然预测失败了，但对应的那一块数据已经在缓存中了，接着，我依次去访问那一片内存，看看谁的访问时间明显比其他部分短，那就知道哪一块被缓存了，再接着反推就能知道作为偏移的数值是多少了</strong>，按照这个思路我可以知道每一个地址单元的内容”</p><img src="/2022/08/21/22-0821-06/image-20220821141014291.png" class="" title="image-20220821141014291"><p>我们几个一边听着一边想着，琢磨了好一会儿总算弄清楚了这家伙的套路，老K气得火冒三丈，差点就想动手修理那人。</p><p>“好你个家伙，倒是挺聪明的，可惜都不用在正途上！好好的加速优化机制竟然成为了你们的帮凶”，我心中也有一团火气。</p><h1 id="亡羊补牢"><a class="markdownIt-Anchor" href="#亡羊补牢"></a> 亡羊补牢</h1><p>事情的真相总算弄清楚了，我们几个此刻已经汗流浃背。</p><p>经过和安全员的协商，操作系统那边推出了全新的<code>KPTI</code>技术来解决这个问题，也就是<code>内核页表隔离</code>。</p><img src="/2022/08/21/22-0821-06/image-20220821142034063.png" class="" title="image-20220821142034063"><p>以前的时候，线程执行在用户态和内核态时用的是同一本地址翻译手册，也就是人们说的<code>页表</code>，通过这本手册，我们CPU就能通过虚拟地址找到真实的内存页面。</p><p>现在好了，让线程运行在用户态和内核态时使用不同的手册，用户态线程的手册中，内核地址空间部分是一片空白，来一招釜底抽薪！</p><p>本以为我们可以回去了，没想到领导却给我们出了难题，“这祸是你们闯下的，人家操作系统那边虽然做了保护，你们是不是也该拿出点办法来呢，要不然以后我们CPU还怎么抬得起头来？”</p><p class="note note-secondary">    本文描述的是两年前爆发的大名鼎鼎的CPU的熔断与幽灵漏洞。<br/>    乱序执行与分支预测是现代处理器普遍采用的优化机制。和传统软件漏洞不同，硬件级别的漏洞影响更大更深也更难以修复。<br/>    通过判断内存的访问速度来获知是否有被缓存，这类技术有一个专门的术语叫侧信道，即通过一些场外信息来分析得出重要结论，进而达成正常途径无法达成的目的]]></content>
    
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>x86保护模式day1</title>
    <link href="/2022/08/21/22-0821-01/"/>
    <url>/2022/08/21/22-0821-01/</url>
    
    <content type="html"><![CDATA[<h1 id="段的划分"><a class="markdownIt-Anchor" href="#段的划分"></a> 段的划分</h1><p>程序把数据和指令集中起来，在前面学习8086汇编时，我们经常划分数据段（用来存放全局变量等）、代码段（用来存放指令），但是我们虽然进行了划分，但并没有改变内存上的物理性质。</p><h1 id="程序的重定位"><a class="markdownIt-Anchor" href="#程序的重定位"></a> 程序的重定位</h1><p>程序具体在内存中的哪个位置，并不能由我们来决定，在我们双击程序 A ，程序 A 加载到内存的位置是随机的（内存中哪里有空闲的地址，就会被加载到哪里）</p><p>我们在学8086汇编的时候，访问内存地址都是用的偏移地址来访问。那么，我们为啥不用物理地址来访问呢 ？？？</p><p>假设，程序加载到内存后的地址是从0开始的，并且代码段有条指令要求访问物理地址为4的数据，进而得到了FF</p><img src="/2022/08/21/22-0821-01/image-20220904223124317.png" class="" title="image-20220904223124317"><p>但是，由于程序加载到内存后的位置是随机的，那么如果程序加载到内存后是从1000开始的，但代码段中的指令是不变的，所以如果还是取物理地址为4的数据，那么肯定无法得到FF，而应该取1004地址的数据，这就是用物理地址来访问的弊端，而我们只需要把代码段设置成CS，程序里面直接用偏移地址（IP）即可</p><img src="/2022/08/21/22-0821-01/image-20220904223135781.png" class="" title="image-20220904223135781"><p>汇编中用 reg 表示寄存器，即 reg 也就是 ax、bx、bx、dx、sp、bp、si 、di 。用 sreg 表示段寄存器，即 sreg 也就是 ds、ss、cs、es</p><h1 id="nasm安装使用"><a class="markdownIt-Anchor" href="#nasm安装使用"></a> NASM安装使用</h1><p>安装nasm（编译后的exe可编译在linux和windows上），直接下一步即可</p><p>安装后可以手动编译和自动编译，笔记中只记录自动编译方法：</p><div class="code-wrapper"><pre><code class="hljs txt">cmd /k pushd &quot;$(CURRENT_DIRECTORY)&quot; &amp; D:\nasm\nasm.exe -f bin  &quot;$(FULL_CURRENT_PATH)&quot; -o &quot;$(NAME_PART).bin&quot; &amp; PAUSE &amp; EXIT</code></pre></div><img src="/2022/08/21/22-0821-01/image-20220904223217946.png" class="" title="image-20220904223217946"><img src="/2022/08/21/22-0821-01/image-20220904223222590.png" class="" title="image-20220904223222590"><p>然后运行nasm</p><img src="/2022/08/21/22-0821-01/image-20220904223230078.png" class="" title="image-20220904223230078"><p>即可得到编译后的bin文件</p><img src="/2022/08/21/22-0821-01/image-20220904223237799.png" class="" title="image-20220904223237799"><p>然后查看二进制bin文件，并且转为16进制（因为16进制更方便观看）</p><img src="/2022/08/21/22-0821-01/image-20220904223244526.png" class="" title="image-20220904223244526"><p>转为16进制形式后如下：</p><img src="/2022/08/21/22-0821-01/image-20220904223250813.png" class="" title="image-20220904223250813"><p>注意这里为啥有一些点，因为这里是一个字节来对应的，比如：16进制的69对应的ascii码就是i，但表示汉字需要两个字节，所以一些无法表示出来的就用点来表示</p><h1 id="计算机启动过程"><a class="markdownIt-Anchor" href="#计算机启动过程"></a> 计算机启动过程</h1><p>每种操作系统都对管理的程序提出了种种格式的要求，比如，windows的PE、linux的elf。如果在windows上的程序格式不是PE，那么就会提示不是有效的windows程序，那么我们如何绕过这个限制呢 ？？？</p><p>我们要了解计算机的启动过程大致是啥样的 ？？？如下：</p><div class="code-wrapper"><pre><code class="hljs txt">1. 通电2. 读取ROM里面的BIOS，用来检查硬件3. 硬件检查通过4. BIOS根据指定的顺序，检查引导设备的第一扇区（即主引导扇区），加载在内存地址 0x7C005. 主引导记录把操作权交给操作系统（注意：操作系统放在硬盘的活动分区内）</code></pre></div><h2 id="三种启动过程"><a class="markdownIt-Anchor" href="#三种启动过程"></a> 三种启动过程</h2><p>计算机有三种启动过程：</p><ol><li><p>冷启动（加电）：指计算机在没有加电的状态下初始加电，一般原则是，先开外设电源，后开主机电源，因为主机的运行需要非常稳定的电源，为了防止外设启动引起电源波动影响主机运行，应该先把外设电源接通，同时应避免主机启动后，在同一电源线上再启动其他电器设备，如：电视，冰箱，空调等家电设备。</p></li><li><p>热启动：计算机在DOS状态下运行时，同时按下 “ctrl”、“alt”、“del” 三个键,计算机会重新启动，这种启动方式是在不断电状态下进行计算机的程序启动，所以也叫做热启动。</p></li><li><p>复位启动（复位）：指在计算机停止响应后（死机），甚至连键盘都不能响应时采用的一种热启动方式，一般在主机面板上都有一个复位按钮开关，轻轻按一下即可，计算机会重新加载硬盘等所有硬件以及系统的各种软件，当然它的威胁不亚于热启动。</p></li></ol><h2 id="处理器"><a class="markdownIt-Anchor" href="#处理器"></a> 处理器</h2><ul><li>CPU有很多引脚，其中有一个是专门用来接受复位信号的，当计算机启动时，会执行硬件初始化，将CPU内部所有寄存器的内容初始化到一个预知的状态。</li><li>对于 8086 CPU 而言，如果接受到复位信号，会使 CS 代码段寄存器置为 0xFFFF，其他所有寄存器的内容都置为 0x000（注意：8086之后的CPU没有延续这样的设计）</li><li>处理器的作用主要还是取指令、执行指令</li></ul><h2 id="内存"><a class="markdownIt-Anchor" href="#内存"></a> 内存</h2><p>内存有两种</p><ul><li><p>一种是主内存，如：内存条，在断电后，内存条保存的内容全部消失。刚开机的时候，内存条中啥数据也没有，所以CPU不可能从内存条中取指令。</p></li><li><p>另一种只读内存（ROM），只读内存实际就是一块单独的内部存储器，比如：我们常说的BIOS，断电后，里面的数据不会消失，开机后，CPU就是从这里面取指令</p><p>补充BIOS的概念和功能：BIOS是一组固化到计算机内主板上一个ROM芯片上的程序，它保存着计算机最重要的基本输入输出的程序、开机后自检程序和系统自启动程序，它可从CMOS中读写系统设置的具体信息</p><p>读取ROM里面的BIOS来检测硬件过程如下：</p><img src="/2022/08/21/22-0821-01/image-20220904223454290.png" class="" title="image-20220904223454290"></li></ul><h1 id="硬盘"><a class="markdownIt-Anchor" href="#硬盘"></a> 硬盘</h1><p>结构如下：</p><img src="/2022/08/21/22-0821-01/image-20220904223747531.png" class="" title="image-20220904223747531"><p>主引导扇区：（更多相关：<a href="https://baike.baidu.com/item/%E4%B8%BB%E5%BC%95%E5%AF%BC%E6%89%87%E5%8C%BA/7612621?fr=aladdin%EF%BC%89">https://baike.baidu.com/item/主引导扇区/7612621?fr=aladdin）</a></p><p>硬件第一个扇区就是主引导扇区（位置为 0面 0道 1扇区，包括硬盘主引导记录和分区表），开机启动并检测完硬件后，BIOS将读取硬盘主引导扇区内容把它加载到内存地址 0x0000 : 0x7C00（ 对应的物理地址为0x07C00 ），然后用 jmp 跳转指令跳转到这个地址，CS : IP 将会从0x07C00 这个物理地址开始执行汇编指令（实际0x07C00这个物理地址就是主引导记录的内存地址），而主引导记录会把操作系统的引导扇区调入内存加以执行，这样就把操作权交给了操作系统</p><p>我们如果修改主引导扇区，就会导致无法加载操作系统</p><h1 id="虚拟机"><a class="markdownIt-Anchor" href="#虚拟机"></a> 虚拟机</h1><p>虚拟机也是需要存储器的（类似于机械硬盘等），但在虚拟机并不需要真正的磁盘，而是用一个文件（如：vhd格式文件、vmdk格式文件）当作虚拟磁盘</p><p>Oracle VM VirtualBox 对应的磁盘就是 vhd 格式文件，这里我们主要以 vhd 格式文件来学习</p><p>在读取磁盘的时候，会从 0 面 0道 1 扇区开始读取，读取完后，再读取 0 面 0道 2 扇区，当0道上所有的扇区全部读取完后，然后会读取 0 面 1 道 1扇区，然后再读取0 面 1 道 2扇区 ，以此类推，读取完道后，再读取面</p><p>vhd文件里一开始的512个字节对应真正硬盘的 0面 0 道 1扇区，也就是对应主引导扇区，第二个512个字节对应物理硬盘的 0面 0道 2扇区，第三个512个字节对应物理硬盘的 0面 0道 3扇区，假设只有3个扇区，然后下一个512个字节就会读取下一个道，那么第四个512个字节对应物 理硬盘的 0面 1道 1扇区，以此类推</p><div class="code-wrapper"><pre><code class="hljs txt">;向显存中写入数据naizigege,编译后的文件为ayu.binmov ax,0xb800mov ds,axmov byte [0x00],&#x27;n&#x27;mov byte [0x02],&#x27;a&#x27;mov byte [0x04],&#x27;i&#x27;mov byte [0x06],&#x27;z&#x27;mov byte [0x08],&#x27;i&#x27;mov byte [0x0a],&#x27;g&#x27;mov byte [0x0c],&#x27;e&#x27;mov byte [0x0e],&#x27;g&#x27;mov byte [0x10],&#x27;e&#x27;infi:jmp near infitimes 510-($-$$) db 0db 0x55,0xaa</code></pre></div><p>然后利用如下工具向虚拟硬盘中写数据，首先选择要写入的虚拟硬盘</p><img src="/2022/08/21/22-0821-01/image-20220904224459198.png" class="" title="image-20220904224459198"><p>然后选择写入的数据，这里写入ayu.bin文件（因为计算机识别的就是二进制文件，无法识别源码），即显示naizigege</p><img src="/2022/08/21/22-0821-01/image-20220904224506479.png" class="" title="image-20220904224506479"><p>然后选择LBA模式写入文件，会提示写入成功</p><img src="/2022/08/21/22-0821-01/image-20220904224513051.png" class="" title="image-20220904224513051"><p>然后用 Oracle VM VirtualBox 新建虚拟机</p><img src="/2022/08/21/22-0821-01/image-20220904224519933.png" class="" title="image-20220904224519933"><p>然后分配内存，如下</p><img src="/2022/08/21/22-0821-01/image-20220904224525637.png" class="" title="image-20220904224525637"><p>然后使用我们刚才写入数据的虚拟磁盘</p><img src="/2022/08/21/22-0821-01/image-20220904224531927.png" class="" title="image-20220904224531927"><p>然后开机，显示如下</p><img src="/2022/08/21/22-0821-01/image-20220904224537949.png" class="" title="image-20220904224537949"><h1 id="大小端模式"><a class="markdownIt-Anchor" href="#大小端模式"></a> 大小端模式</h1><p>小端模式：指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，在前面我们学16位汇编时，就是小端模式，而x86汇编中也是小端模式</p><img src="/2022/08/21/22-0821-01/image-20220904224551771.png" class="" title="image-20220904224551771"><p>为啥需要区分大小端模式呢 ？？？</p><p>因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为 8bit，对于位数大于 8位 的处理器，例如 16位 或者 32位 的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。</p><p>小端模式的优势</p><p>在进行强制类型转换时，由低精度向高精度进行转化时，比如：由 short 类型（2个字节）的 0x1234 转为 int 类型（4个字节）的 0x00001234，转换完后，数值是不变的，只是存储形式变了。</p><img src="/2022/08/21/22-0821-01/image-20220904224614036.png" class="" title="image-20220904224614036"><p>如果是从高精度向低精度转换，比如：从 0x00001234 转为 0x1234 ，那么只需要将高地址的内容砍掉就好了</p><img src="/2022/08/21/22-0821-01/image-20220904224624236.png" class="" title="image-20220904224624236"><p>大端模式的优势</p><p>优点在于对于有符号数而言，判断更加方便，假设是大端模式的话，如果地址 073F:2000 的内容为十六进制的1234，并且是负数的话，那么对应大致如下：</p><img src="/2022/08/21/22-0821-01/image-20220904224635725.png" class="" title="image-20220904224635725"><p>由于符号位在低地址处，所以我们一开始就可以在低地址处知道符号位是负的</p><h1 id="屏幕显示内容的原理"><a class="markdownIt-Anchor" href="#屏幕显示内容的原理"></a> 屏幕显示内容的原理</h1><p>为了显示数据，必须存在两大硬件:显卡+显示器。显卡是为显示器提供需要显示的数据，控制显示器的模式和状态。而显示器是将目标数据以可见的方式呈现在屏幕上。显存的概念和意义就是显卡拥有自己内部的而数据存储器，显存在本质上和普通内存无差别，用于存储目标数据，操作显存中的数据将导致显示器上内容的改变。</p><p>对于显卡，有两种工作模式，一个是文本模式，另一个是图形模式，开机启动后，默认是文本模式，文本模式下，内存的<code>0xB8000</code>到<code>0xBFFFF</code>这段物理地址被映射到显存。也就是说，写这些物理地址，就可以控制显示内容。</p><h1 id="16位汇编和32位的简单区别"><a class="markdownIt-Anchor" href="#16位汇编和32位的简单区别"></a> 16位汇编和32位的简单区别</h1><p>在16位汇编中的寄存器为：AX、BX、CX 等等</p><p>在32位汇编中的寄存器为：EAX、EBX、ECX 等等 ，EAX可拆分成两个16位的寄存器使用</p><p>在64位汇编中 的寄存器为：RAX、RBX、RCX 等等、RAX可拆分成两个32位的寄存器使用，当然低32位寄存器还可以继续拆分。还新增了 R8、R9 等，这些不能拆分</p>]]></content>
    
    
    <categories>
      
      <category>x86保护模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编day11</title>
    <link href="/2022/08/20/22-0820-11/"/>
    <url>/2022/08/20/22-0820-11/</url>
    
    <content type="html"><![CDATA[<h1 id="数据标号"><a class="markdownIt-Anchor" href="#数据标号"></a> 数据标号</h1><p>不带冒号的标号可以描述内存地址和单元长度，这种标号称为数据标号，如下：</p><div class="code-wrapper"><pre><code class="hljs txt">data segmenta dw 0,0;标号a描述了地址data:0，还有就是从这个地址开始，后面内存单元都是字单元b db 1,2;标号b描述了地址data:4，还有就是从这个地址开始，后面的内存单元都是字节单元data ends另外还有如下使用方法：mov al,b 相当于mov ax,ds:[4]mov al,b[si] 以数组形式使用</code></pre></div><h1 id="直接定址表"><a class="markdownIt-Anchor" href="#直接定址表"></a> 直接定址表</h1><p>一个字节用两个十六进制数码来表示，用一个字节的高 4 位和低 4 位分开，分别用它们的值得到对应的数码字符。比如 2Bh，可以得到高 4 位的值为 2，低 4 位的值为 11</p><p>即，当数值为2，则显示2；当数值为11，则显示B</p><p>那么，我们就可以建立一张映射表。通过依据数据，直接对应的结果，类似如下：</p><div class="code-wrapper"><pre><code class="hljs txt">数值 ——&gt; ASCII字符  0       0  1       1  2       2  3       3  4       4  5       5  6       6  8       8  9       9   10      A   11      B   12      C   13      D   14      E   15      F</code></pre></div><p>用汇编代码表示如下：</p><div class="code-wrapper"><pre><code class="hljs txt">table db &#x27;0123456789ABCDEF&#x27;table[0]  ;对应的就是0，这里中括号里面的0有点类似数组的下表table[10] ;对应的就是A</code></pre></div><h1 id="键盘原理"><a class="markdownIt-Anchor" href="#键盘原理"></a> 键盘原理</h1><p>day10 学习过扫描码和对应的ASCII码被送入内存的BIOS键盘缓冲区，当我们按下 a 键时，具体流程是啥 ？？</p><ol><li><p>当我们按下 a 键的时候，此时键盘缓冲区的高地址为扫描码（通码）1E，低地址为ASCII码 61</p><img src="/2022/08/20/22-0820-11/image-20220904164745649.png" class="" title="image-20220904164745649"><p>附键盘按键的各种编码对照表：<a href="https://blog.csdn.net/liuyukuan/article/details/120575746">https://blog.csdn.net/liuyukuan/article/details/120575746</a></p></li><li><p>然后 cpu 执行 int 9，从 60h 端口读取 a 的通码。然后检测状态字节（判断我们有没有按下 shift、ctrl 等控制键），这里我们没有按下shift键</p></li></ol><p>BIOS提供了int 16h中断例程给我们从键盘缓冲区读取一个键盘输入（ 前面学过的int 9的功能是将扫描码和ASCII码写入缓冲区 ）</p><div class="code-wrapper"><pre><code class="hljs txt">;使用16号中断例程的0号子程序mov ah,0 ;设置参数，用ah表示使用哪个子程序int 16hint 16h 0号功能进行如下操作：检测缓冲区是否有数据，没有就继续等待，有的话读取缓冲区第一个字单元的键盘输入，将读取的扫描码送入ah，ASCII码送入al,将已读取的键盘输入从缓冲区里删除比如说：现在缓冲区只有1E61，那么就会将1E给ah，61给al，然后将1E61从缓冲区中删除，现在缓冲区没有数据了，就会继续等待</code></pre></div><p>编写一个程序，要求：接受用户的键盘输入，输入 ‘r’ 将屏幕上的字符都设置为红色，输入 ‘g’ 显示绿色，输入 ‘b’ 显示蓝色</p><div class="code-wrapper"><pre><code class="hljs txt">assume cs:codecode segmentstart:mov ah,0int 16hmov ah,1;ah保存扫描码，这里把扫描码暂时设置1，即0000 0001cmp al,&#x27;r&#x27;;al存放的是ascii码，比较按下的键位是不是rje red;如果是r，跳转到red标号cmp al,&#x27;g&#x27;je greencmp al,&#x27;b&#x27;je bluejmp jieshured:shl ah,1;将ah中值左移1位，即0000 0010green:shl ah,1;将ah中值左移1位，即0000 0100，而0000 0100就是红色blue:mov bx,0b800hmov es,bxmov bx,1mov cx,2000;循环2000次s:and byte ptr es:[bx],11111000b;采用and指令，全1为1，所以会把后三位表示颜色的位设置成0,or es:[bx],ah;将颜色设置为相对应的颜色add bx,2;循环，将屏幕上所有的字符全部设置成相对应的颜色loop sjieshu:mov ax,4c00hint 21hcode endsend start</code></pre></div><p>效果如下：</p><p>按下r</p><img src="/2022/08/20/22-0820-11/image-20220904164843077.png" class="" title="image-20220904164843077"><p>按下g</p><img src="/2022/08/20/22-0820-11/image-20220904164849228.png" class="" title="image-20220904164849228"><p>按下b</p><img src="/2022/08/20/22-0820-11/image-20220904164856726-16622813370711.png" class="" title="image-20220904164856726"><h1 id="字符串输入本质"><a class="markdownIt-Anchor" href="#字符串输入本质"></a> 字符串输入本质</h1><p>字符串输入，如何接受字符串输入 ？？</p><ol><li>在输入的同时需要显示这个字符串</li><li>一般在输入回车后，表示字符串输入结束</li><li>能够删除已经输入的字符串</li></ol><p>字符的输入和输出是按照栈的访问规则进行的，后进先出，如下：</p><p>![GIF 2022-6-5 13-00-55](file://D:\Lucy1.7.6\Lucy%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8v1.7.6%E4%B8%AA%E4%BA%BA\Hexo_Blog\source_posts\22-0604-01\GIF%202022-6-5%2013-00-55.gif?lastModify=1662281428)</p><p>所以字符串的存储空间实际上是一个字符栈，从栈底到栈顶组成了一个字符串，如下：</p><img src="/2022/08/20/22-0820-11/image-20220904165042463.png" class="" title="image-20220904165042463"><p>输入回车符，就在字符串中加入0表示一个字符串结束</p><h1 id="对汇编语言实质思考"><a class="markdownIt-Anchor" href="#对汇编语言实质思考"></a> 对汇编语言实质思考</h1><p>编程思想：</p><p>比如：计算 1 + 2 + 3 + 4 = 10，实际是先算 1 + 2 = 3 ，然后算 3 + 3 = 6 ，然后算 6 + 4 =10</p><p>输入数值—&gt;计算数值—&gt;将计算后数值输出，输出的数值又可以作为输入，所谓的输入和输出其实就是数据从哪里来，数据到哪里去</p><p>这个哪里这个词是不是给人一种空间的感觉呢？那我们学到现在，学过哪些和空间位置信息相关的概念呢？</p><div class="code-wrapper"><pre><code class="hljs txt">CPU中的寄存，比如：ax，bx，cx，dx ......内存条、显卡中的内存地址、段地址、偏移地址 外设（比如：键盘）中的端口地址（端口号）网卡的网络地址硬盘的硬盘地址</code></pre></div><p>那么以上都是什么的空间位置信息？是数据的空间位置信息，那么这些数据的空间位置信息，它们对应的是哪些物理设备？</p><p>这些设备都是插在一块主板上的，而主板上都是有电路的，这又回到了我们刚开始学习的时候，这些电路需要表示哪些信息啊？</p><p>地址信息，数据信息，控制信息，也就是地址线，数据线，控制线。那么也就是说这些插在主板上的物理设备之间，它们是依靠主板上的电路去传递这些信息，然后进行互相<strong>通信</strong>的。</p><p>通信这个词语很关键，我们程序写到现在，你们应该也发现了，我们汇编程序员就是在用汇编指令去控制插在主板上的CPU，通过这些信息去和同样插在主板上的这些各个物理设备之间去进行通信</p><p>当你在执行很多指令的时候（比如：mov al,ds:[si] 、in al,60H、int 13h 等），你都需要有这些信息，特别是这个地址信息，否则的话你这数据从哪里来的啊？还有这个数据到哪里去？而所谓的读写是不是其实就是在通信</p><p>而像 mov ax,bx 指令，则表示CPU内部寄存器之间的通信</p><p>汇编语言是什么呢？ 语言是一套表示系统，再结合我们刚在所讲的，那么我们可以得到一个思考，汇编语言它是一套控制计算机通信的表示系统</p><h1 id="编译器和链接器"><a class="markdownIt-Anchor" href="#编译器和链接器"></a> 编译器和链接器</h1><p>如果一个程序中有100W行代码，需要编译5分钟，那么我们一旦需要修改代码，就需要再次编译，并且等待5分钟，这样很麻烦</p><p>那么就可以把100W行代码拆分多个部分，如下：</p><p>t1.asm</p><p>t2.asm</p><p>t3.asm</p><p>t4.asm</p><p>然后把这些编译成obj</p><p>t1.asm —&gt; t1.obj</p><p>t2.asm —&gt; t2.obj</p><p>t3.asm —&gt; t3.obj</p><p>t4.asm —&gt; t4.obj</p><p>然后再通过链接器把所有obj文件链接在一起变成可执行的exe文件</p><p>假设我们需要修改 t1 里面的代码，我们是不是只需要编译 t1 就行了，其他的不用再编译，节省时间</p>]]></content>
    
    
    <categories>
      
      <category>16位汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编day10</title>
    <link href="/2022/08/20/22-0820-10/"/>
    <url>/2022/08/20/22-0820-10/</url>
    
    <content type="html"><![CDATA[<h1 id="dos中断例程"><a class="markdownIt-Anchor" href="#dos中断例程"></a> DOS中断例程</h1><p>实际之前我们已经接触过dos中断例程，如下：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span></code></pre></div><p>而 mov  ax,4c00h 也就是 mov ah,4ch mov al,00h</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-number">4ch</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0</span><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><span class="hljs-comment">;表示使用int 21h中断例程的4ch子程序，功能为程序返回，ah传递参数</span></code></pre></div><p>作业：</p><div class="code-wrapper"><pre><code class="hljs txt">assume cs:code,ds:datadata segmentdb &#x27;Welcome to naizishaozhi&#x27;,&#x27;$&#x27;;这里的$表示字符串结束的标志data endscode segmentstart:mov ah,2;调用2号子程序，来设置光标;设置参数mov bh,0;设显存置第0页mov dh,5;设置第5行mov dl,12;设置第12列int 10h;设置完参数后调用10h中断例程mov ax,datamov ds,axmov dx,0;ds:dx，指向data段字符串的首地址mov ah,9;调用号子程序，功能是在光标处显示字符串int 21h;注意:调用21h中断例程时候，该例程是以dx为偏移的，所以在前面把dx设置为0mov ax,4c00hint 21hcode endsend start</code></pre></div><p>编译上述程序，指向后如下：</p><img src="/2022/08/20/22-0820-10/image-20220904162736276.png" class="" title="image-20220904162736276"><h1 id="端口"><a class="markdownIt-Anchor" href="#端口"></a> 端口</h1><p>CPU 是一块芯片，通过地址线、数据线、控制线和其他电子器件链接，那么我们在键盘上按下 ‘A’ ，CPU如何获取到我们键盘上按下的 ‘A’ 呢 ？？</p><p>在电脑的主板上有很多接口，如下，这些接口上有很多芯片，这些芯片上还有一些寄存器，比如：笔记本上的插键盘的usb接口，这个接口上就有芯片，芯片上就有寄存器。</p><img src="/2022/08/20/22-0820-10/image-20220904162855237.png" class="" title="image-20220904162855237"><p>比如：我们在键盘上按下 ‘A’ ，由于键盘上肯定也有芯片，芯片上就有寄存器，那么当我们在键盘上按下 ’ A’ 的时候，就会把 ‘A’ 存放到键盘芯片上的寄存器中，然后通过 “端口” 把A发送给CPU，实际这里端口就是键盘和电脑连接的usb接口上的寄存器，每个端口都有一个编号，类似于内存的地址。CPU通过端口地址来定位端口，端口的范围是64KB，即 0~65535</p><img src="/2022/08/20/22-0820-10/image-20220904162902231.png" class="" title="image-20220904162902231"><p>注意：对端口的读写不能使用 mov push pop 等内存指令，端口的读写有2条：In（读）和 out（写）</p><p>比如：访问60号端口的内容</p><div class="code-wrapper"><pre><code class="hljs txt">In al,60h;这里必须是al或者ax，这个是固定的格式，访问8位端口用al，访问16位端口用ax</code></pre></div><p>具体如下：</p><p>CPU要读取60h号端口的内容，那么CPU通过地址总线将60h这个地址信息发送出去，找到60h端口，然后通过控制线告诉这个端口要执行In读命令，那么芯片所在的60h端口会把数据通过地址线直接放到CPU的寄存器中</p><p>比如：对0~255（8位）以内的端口进行读写时，这里以20h端口为例</p><div class="code-wrapper"><pre><code class="hljs txt">in al,20hout 20h,al</code></pre></div><p>比如：对256~65535（16位）进行读写，端口号放dx中，这里的端口号为3f8h（10进制的1016）为例</p><div class="code-wrapper"><pre><code class="hljs txt">mov dx,3f8hin al,dxout dx,al</code></pre></div><h1 id="cmos-ram-芯片简称cmos"><a class="markdownIt-Anchor" href="#cmos-ram-芯片简称cmos"></a> CMOS RAM 芯片（简称CMOS）</h1><ol><li><p>CMOS芯片是电脑主板上的一块可读写的RAM芯片，因为可读写的特性，所以在电脑主板上用来保存BIOS设置完电脑硬件参数后的数据，这个芯片仅仅是用来存放数据的。</p></li><li><p>CMOS芯片包含一个实时钟（用来显示当前时间）和一个有128个存储单元的RAM存储器</p></li><li><p>128个字节的RAM中内部实时钟占用0~0dh单元用，来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序读取</p></li><li><p>CMOS RAM 存储的具体时间信息如下：</p><p>年、月、日、时、分、秒，这六个信息长度都为1个字节，存放单元为：秒:0   分:2   时:4  日: 7   月:8   年:9</p><p>这些时间数据都是以BCD码的方式存放</p><p>BCD码是以4位二进制数表示十进制数码的编码方法，如下所示：</p><div class="code-wrapper"><pre><code class="hljs tap">十进制数码:     <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 1 </span>    <span class="hljs-number"> 2 </span>    <span class="hljs-number"> 3 </span>    <span class="hljs-number"> 4 </span>   <span class="hljs-number"> 5 </span>     <span class="hljs-number"> 6 </span>     <span class="hljs-number"> 7 </span>     <span class="hljs-number"> 8 </span>     9对应的BCD码:  <span class="hljs-number"> 0000 </span>  <span class="hljs-number"> 0001 </span> <span class="hljs-number"> 0010 </span> <span class="hljs-number"> 0011 </span> <span class="hljs-number"> 0100 </span> <span class="hljs-number"> 0101 </span> <span class="hljs-number"> 0110 </span>  <span class="hljs-number"> 0111 </span>  <span class="hljs-number"> 1000 </span>   1001</code></pre></div><p>比如：数值26，用BCD码表示为: 0010 0110</p><div class="code-wrapper"><pre><code class="hljs txt">;作业：编程在屏幕中间显示当前的月份;分析：当前日期为6月，我们拿到的数据实际是bcd码，也就是0000 0110，然后我们右移四位，拿到4个高位数据0000，然后and指令拿到低4位0110，然后把高位和低位分别+30h，拿到对应的ascii码，然后写入显存，显示出来对应月份assume cs:code,ds:datadata segmentdb &#x27;Welcome to naizishaozhi&#x27;,&#x27;$&#x27;data endscode segmentstart:mov al,8out 70h,alin al,71hmov ah,almov cl,4shr ah,cl;拿到月份高位（十位）and al,00001111b;拿到月份的低位（个位）;加上30H显示对应的ASCII码add ah,30Hadd al,30Hmov bx,0b800hmov es,bxmov byte ptr es:[160*12+40*2],ahmov byte ptr es:[160*12+40*2+1],11001100bmov byte ptr es:[160*12+40*2+2],almov byte ptr es:[160*12+40*2+3],11001100bmov ax,4c00hint 21hcode endsend start</code></pre></div><p>编译运行上述程序后，结果如下：</p><img src="/2022/08/20/22-0820-10/image-20220904163032978.png" class="" title="image-20220904163032978"></li><li><p>该芯片有电池供电，所以关机后内部的时钟依然可以正常工作，RAM中信息不丢失</p></li><li><p>该芯片有两个端口：70h和71h，CPU通过这两个端口来读写CMOS RAM</p></li><li><p>70h为地址端口，存放要访问的CMOS RAM单元的地址；71h为数据端口，存放从选定的CMOS RAM单元中读取的数据，或要写入其中的数据。</p><p>比如：要读取cmos 2号单元的内容</p><div class="code-wrapper"><pre><code class="hljs txt">out 70h,2;①将2送入端口70hin al,71h;②从端口71h读出2号单元的内容</code></pre></div><p>具体内容如下：</p><div class="code-wrapper"><pre><code class="hljs txt">assume cs:codecode segmentstart:mov al,2out 70h,alin al,71hmov ax,4c00hint 21hcode endsend start</code></pre></div><p>调式上述程序如下：</p><img src="/2022/08/20/22-0820-10/image-20220904163101938.png" class="" title="image-20220904163101938"><p>执行完 in al,71 指令后，al由 02 变成了 48，而2号单元对应的是分钟，此时恰好是48分</p></li></ol><h1 id="shl-shr指令"><a class="markdownIt-Anchor" href="#shl-shr指令"></a> shl、shr指令</h1><p>shl（l=left 逻辑左移指令）和 shr（r=right 逻辑右移指令）</p><h2 id="shl"><a class="markdownIt-Anchor" href="#shl"></a> shl</h2><p>shl：将一个寄存器或内存单元中的数据向左移位，将<code>最后移出</code>的一位写入CF中，最低位用0补位</p><p>例如：</p><div class="code-wrapper"><pre><code class="hljs txt">mov al,01001000bshl al,1;从右向左移1位执行上面指令后al=10010000 CF=0然后再次执行 sh1 al,1 指令，执行后结果如下：al=00100000 CF=1</code></pre></div><p>如果一次移动多位，位数大于1时，必须将移动位数放在cl中</p><p>比如：我们向左移动5位，如下</p><div class="code-wrapper"><pre><code class="hljs txt">mov al,01010001bmov cl,5shl al,cl</code></pre></div><h2 id="shr"><a class="markdownIt-Anchor" href="#shr"></a> shr</h2><p>shr：将一个寄存器或内存单元中的数据向右移，将<code>最后移出</code>的一位写入CF中，最高位用0补位</p><div class="code-wrapper"><pre><code class="hljs txt">mov al,01001001bshr al,1;执行后al=00100100b cf=1</code></pre></div><h1 id="外中断"><a class="markdownIt-Anchor" href="#外中断"></a> 外中断</h1><p>外中断分为可屏蔽和不可屏蔽，CPU通过标志寄存器的IF位来判断是可屏蔽还是不可屏蔽，可屏蔽可以不响应（当然也可以响应）。如果不可屏蔽，则必须响应。IF=0为可屏蔽中断，IF=1为可屏蔽中断</p><p>可屏蔽外中断流程：</p><ol><li>中断后，取中断类型码 n（是为了定位中断例程的入口地址）</li><li>标志寄存器入栈，设置 IF=0 TF=0（pushf）</li><li>cs、ip入栈</li><li>ip=n*4，cs=nx4+2</li></ol><p>不可屏蔽中断流程：</p><ol><li>标志寄存器入栈，IF=0 TF=0（不可屏蔽中断类型码固定是2，不需要取中断类型码）</li><li>cs、ip入栈</li><li>ip=n*4，cs=nx4+2</li></ol><p>理解可屏蔽中断和不可屏蔽中断：比如，我们在键盘上按下按键，就属于可屏蔽中断，有时候会显示，有时候不显示</p><img src="/2022/08/20/22-0820-10/image-20220904163423875.png" class="" title="image-20220904163423875"><p>键盘处理过程如下：</p><ol><li><p>键盘上的每个键相当于一个开关，键盘中有一个芯片对键盘上的每一个键的开关状态进行扫描（判断我们到底有没有按这个按键）</p></li><li><p>按下一个键，开关接通，该芯片产生一个扫描码，扫描码就说明了你按的是哪个键，扫描码会送到接口芯片的寄存器中，外设都是通过端口来读取数据的，键盘的端口地址为60h</p></li><li><p>按下一个键产生的扫描码又称为通码，松开一个键产生扫描码称为断码。扫描码为一个字节。通码的第7位为0，断码的第7位为1</p><p>比如：g键的通码为 22h （对应二进制为 00100010 ），断码只需要将通码二进制第7位变为1即可，即 10100010 ，对应十六进制为a2h</p></li><li><p>键盘的输入到达60h端口，相关芯片给CPU发出了中断类型码为9的可屏蔽中断信息，CPU检测到该信息后，如果这时IF=1,则响应，去执行int 9中断例程</p></li><li><p>BIOS提供了int 9中断例程用来进行基本的键盘输入处理</p><p>int 9 中断例程进行基本的键盘输入处理大致如下：</p><ol><li>读出60h端口中的扫描码</li><li>如果是字符键的扫描码，将该扫描码和对应的ASCII码送入内存的BIOS键盘缓冲区，如果是控制键比如CTRL和CAPSLOCK，则将其转变为状态字节（用二进制记录控制键和切换键状态的字节），写入内存中存储状态的字节单元</li><li>对键盘系统进行相关控制</li></ol></li></ol><p>BIOS键盘缓冲区用于存放 int 9 中断例程所接收的键盘输入内存区，该内存区可以存储15个键盘输入，用一个字单元存放扫描码和ASCII码，高位字节存放扫描码，低位存放ASCII码</p><p>如果我们在键盘上按的是控制键，那么会存储在内存单</p><div class="code-wrapper"><pre><code class="hljs txt">;显示0040:17存储的字节内容，该部分代码主要做演示用assume cs:code,ss:stackstack segment stackdb 128 dup (0)stack endscode segmentstart:mov bx,stackmov ss,bxmov sp,128mov bx,0b800hmov es,bxmov bx,40Hmov ds,bxmov si,17Hs: mov di,160*10+40*2mov al,ds:[si]call show_sjmp sshow_s:push cxpush axpush dspush espush sipush dimov cx,8show:mov dx,0shl al,1adc dx,30Hmov es:[di],dladd di,2loop show pop dipop sipop espop dspop axpop cxretmov ax,4c00h  ;ah=4c al=00int 21hcode endsend start</code></pre></div><p>编译上述程序，如下：</p><img src="/2022/08/20/22-0820-10/image-20220904163459454.png" class="" title="image-20220904163459454"><p>当我们按下shift键时，如下：</p><img src="/2022/08/20/22-0820-10/image-20220904163505204-16622805054141-16622805063062.png" class="" title="image-20220904163505204"><p>这8个0表示的含义如下：</p><ul><li>字节第0位：键盘右边的shift状态，1表示按下</li><li>字节第1位：键盘左边的shift状态，1表示按下</li><li>字节第2位：键盘Ctrl状态，1表示按下</li><li>字节第3位：键盘Alt状态，1表示按下</li><li>字节第4位：键盘ScrollLock状态，置为1表示Scroll灯亮</li><li>字节第5位：键盘NumLock状态，置为1表示小键盘已开启</li><li>字节第6位：键盘CapsLock状态，置为1表示输入大写字母</li><li>字节第7位：键盘Insert状态，置为1表示处于删除状态</li></ul><h1 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h1><p>作业：编写程序覆盖int 9程序，按照自己意图来处理键盘的输入，比如在屏幕中间依次显示a~z，在显示的过程中，按下Esc键改变显示的颜色</p><p>思路：</p><ol><li>重写 int 9 中断例程，把原来的 int 9 中断例程覆盖掉 ，重写的内容如下大致如下</li><li>首先要判断我们按下的按键是不是ESC按键，需要先从60h端口读取出从键盘输入的内容（扫描码）（ in,al ）</li><li>ESC属于字符键，然后会将扫描码和对应的ASCII码送入内存的BIOS键盘缓冲区，然后对键盘系统进行相关控制（通过调用BIOS原来的 int 9 中断例程来实现 ）</li><li>由于上面第3步中要调用原来的 int 9 例程，所以我们要调用没有覆盖前的 int 9 中断例程，就需要保存原来 int 9 中断例程的入口地址（原来 int 9 中断例程入口地址 CS : IP = 9×4 : 9×4+2），将入口地址 CS:IP 保存到 0:200、0:202 这里，用data段保存段地址和偏移地址</li><li>然后标志寄存器入栈 IF =0、TF=0（pushf）</li><li>然后CS:IP入栈、跳转到CS:IP（call dword ptr ds[0]）</li></ol><div class="code-wrapper"><pre><code class="hljs txt">;请将代码编写完成assume cs:code,ss:stackstack segment stackdb 128 dup (0)stack endsdata segmentdw 0,0;存放段地址和偏移地址data endscode segmentstart:mov ax,stackmov ss,axmov sp,128mov ax,datamov ds,ax;将原来的int 9中断例程入口地址进行保存，方便之后使用mov ax,0mov es,axpush es:[9*4]pop ds:[0]push es:[9*4+2]pop ds:[2];覆盖原来的int 9，在中断向量表中设置我们新的int 9中断例程的入口地址mov es:[9*4],offset myint9mov es:[9*4+2],csmov ax,0b800hmov es,axmov ah,&#x27;a&#x27;s:mov es:[160*12+40*2],ahcall sleepinc ahcmp ah,&#x27;z&#x27;jna s;把原来的int9入口地址恢复mov ax,0mov es,axpush ds:[0]pop es:[9*4]push ds:[2]pop es:[9*4+2]mov ax,4c00hint 21hsleep:push axpush dxmov dx,10h;循环1000 0000h次mov ax,0s1:sub ax,1sbb dx,0cmp ax,0jne s1cmp dx,0jne s1pop dxpop axretmyint9:push axpush bxpush esin al,60h;读取60h端口扫描码pushfcall dword ptr ds:[0]cmp al,01h;判断是不是esc键jne myint9endmov ax,0b800hmov es,axinc byte ptr es:[160*120+40*2+1]iretmyint9end:pop espop bxpop axiretcode endsend start</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>16位汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编day9</title>
    <link href="/2022/08/20/22-0820-09/"/>
    <url>/2022/08/20/22-0820-09/</url>
    
    <content type="html"><![CDATA[<h1 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h1><div class="code-wrapper"><pre><code class="hljs txt">assume cs:codecode segmentstart:mov ax,0mov dx,1mov bx,1div bxmov ax,4c00hint 21hcode endsend start</code></pre></div><p>把上面的程序编译成ayu.exe，由于除数为bx（16位），那么被除数一定为32位，被除数的高位存放在dx中，低位存放在ax中，那么根据上述程序，除数bx=1h，被除数为dx中高位的1和ax中存放的低位0，也就是10000H，那么10000H/1H=10000H，而由于最后的结果存放在ax中，但是10000H远远超出了ax能存放的范围，所以会溢出，会显示出的内容如下：（注意：这个除法溢出的中断要在虚拟机windows2003下执行，在win10的dosbox中不会提示Divide overflow）</p><img src="/2022/08/20/22-0820-09/image-20220904160052203.png" class="" title="image-20220904160052203"><p>这里将 Divide overflow 改成显示 geinaizigegeshaozhi</p><p>整体思路如下：</p><ol><li>除法溢出CPU拿到0号中断类型码去中断向量表找到我们程序的入口地址</li><li>我们程序执行向屏幕上打印naizigegeshaozhi</li><li>程序返回DOS</li></ol><div class="code-wrapper"><pre><code class="hljs txt">;内存中有一段安全空间，0:200~0:2FF ，下面程序将shaozhi标号处内容存储到内存的0:200处assume cs:codestack segment stackdb 128 dup (0)stack endsdata segmentdb &#x27;geinaizigegeshaozhi!!!&#x27;,0data endscode segmentstart:mov ax,stackmov ss,axmov sp,128mov ax,csmov ds,axmov si,offset shaozhimov ax,0mov es,axmov di,200Hmov cx,shaozhi_end - shaozhicldrep movsbmov ax,4c00hint 21h;向屏幕打印给乃子烧纸shaozhi:mov ax,1mov ax,1mov ax,4c00hint 21hshaozhi_end:nopcode endsend start</code></pre></div><p>编译上述程序，并且debug调试程序：</p><p>开始在内存地址为0:200上全是0，没有数据</p><img src="/2022/08/20/22-0820-09/image-20220904160257886.png" class="" title="image-20220904160257886"><p>然后 -U 调试</p><img src="/2022/08/20/22-0820-09/image-20220904160313336.png" class="" title="image-20220904160313336"><p>然后执行完程序</p><img src="/2022/08/20/22-0820-09/image-20220904160319741.png" class="" title="image-20220904160319741"><p>然后再次d查看0:200处的地址的内容</p><img src="/2022/08/20/22-0820-09/image-20220904160325978.png" class="" title="image-20220904160325978"><p>然后查看0:200对应的指令，发现我们确实把 <code>shaozhi</code> 标号处的4条指令放到了内存 0:200 处</p><img src="/2022/08/20/22-0820-09/image-20220904160332798.png" class="" title="image-20220904160332798"><p>然后我们把<code>shaozhi</code>标号处的内容换成<code>geinaizigegeshaozhi</code>，并且把 中断类型码为 0 的地址对应的内容改成 0:200，代码如下：</p><div class="code-wrapper"><pre><code class="hljs txt">assume cs:codestack segment stackdb 128 dup (0)stack endsdata segmentdata endscode segmentstart:mov ax,stackmov ss,axmov sp,128mov ax,csmov ds,axmov si,offset shaozhimov ax,0mov es,axmov di,200Hmov cx,shaozhi_end - shaozhicldrep movsb;将0号中断入口程序地址（除法溢出中断类型码是0）改成0:200地址的内容mov ax,0mov es,axmov word ptr es:[0*4],200Hmov word ptr es:[0*4+2],0;执行除法，使程序溢出mov ax,0mov dx,1mov bx,1div bxmov ax,4c00hint 21h;向屏幕打印给乃子烧纸shaozhi:jmp shaozhi_startdb &#x27;geinaizigegeshaozhi!!!&#x27;,0shaozhi_start:mov ax,0mov ds,axmov si,203hmov ax,0b800hmov es,axmov di,12*160+72show_string:mov dl,ds:[si]cmp dl,0je returnmov es:[di],diinc siadd si,2jmp show_stringreturn:mov ax,4c00hint 21hshaozhi_end:nopcode endsend start</code></pre></div><p>这里很奇怪，执行后，没有成功。。。实际应该是可以成功的。。。</p><h1 id="cpu如何判断是否中断"><a class="markdownIt-Anchor" href="#cpu如何判断是否中断"></a> CPU如何判断是否中断</h1><p>CPU怎么知道发生中断的，它是检测标志寄存器的TF位为1的话就引发中断过程，比如中断类型码为1，则中断过程如下：</p><ol><li>取得中断类型码1</li><li>标志寄存器入栈，TF、IF设置为0</li><li>cs、ip入栈</li><li>ip=1x4 、cs=1x4+2</li></ol><h1 id="cpu为什么提供中断功能"><a class="markdownIt-Anchor" href="#cpu为什么提供中断功能"></a> CPU为什么提供中断功能</h1><p>我们知道CPU执行程序时候是从CS:IP指向某个地址开始，自动向下读取指令执行，如果没有这个功能，CPU一加电，就从预设的CS:IP开始读取指令一直执行下去，不可能说执行完一条指令，去做别的事情，只有CPU提供中断后，才能够执行完一条指令后，去做一些其他的事情（比如：debug和其他断点调试就是利用CPU的中断，dosbox的-t参数就是中断，debug使用-t命令时候将TF设置1，使得CPU工作于单步中断下，在CPU执行完这条指令后就会引发单步中断）</p><p>为啥要设置TF=0 ？？</p><p>由于TF=1，cpu执行完一条指令后会引发单步中断，转去执行中断处理程序。所以为了避免一直中断，那么在进入中断处理程序之前，设置TF=0，从而避免CPU在执行中断处理程序的时候又发生中断过程导致一直中断，产生死循环</p><h1 id="中断例程"><a class="markdownIt-Anchor" href="#中断例程"></a> 中断例程</h1><p>中断处理程序也叫中断例程</p><p>int指令格式为：int n，n就代表中断类型码，功能是引发中断过程，和call命令类似</p><div class="code-wrapper"><pre><code class="hljs txt">assume cs:codecode segmentstart:int 0code endsend start</code></pre></div><p>编译上述程序，在windows2003下执行，然后就会报除法溢出错误（0号中断类型码为除法溢出）</p><img src="/2022/08/20/22-0820-09/image-20220904160804997.png" class="" title="image-20220904160804997"><p>编写一个中断例程，功能是返回一个word型数据的平方，编译如下程序为test.exe</p><div class="code-wrapper"><pre><code class="hljs txt">assume cs:codecode segmentstart:mov ax,1234int 7ch;调用7ch中断例程，拿到ax的平方mov ax,4c00hint 21hcode endsend start</code></pre></div><p>编写7ch中断例程，如下，然后编译成ayu.exe</p><div class="code-wrapper"><pre><code class="hljs TXT">assume cs:codecode segmentstart:mov ax,csmov ds,axmov si,offset sqrmov ax,0mov es,axmov di,200Hmov cx,offset sqrend - offset sqrcldrep movsbmov ax,0mov es,axmov word ptr es:[7ch*4],200Hmov word ptr es:[7ch*4+2],0mov ax,4c00hint 21hsqr:mul ax;mul乘法指令，即执行ax*ax，也就是ax²iret  ;call指令和ret配合，这里int和iret配合，iret的作用就是 1.pop ip  2.pop cs  3.popfsqrend:nopcode endsend star</code></pre></div><p>调试 ayu.exe 和 test.exe，先调试 ayu.exe ，如下：</p><img src="/2022/08/20/22-0820-09/image-20220904160854310.png" class="" title="image-20220904160854310"><img src="/2022/08/20/22-0820-09/image-20220904160857194-16622789373791-16622789382312.png" class="" title="image-20220904160857194"><p>然后调试 test.exe，引发7ch中断例程的IP为<code>7ch*4=1F0</code>地址处的值 ，CS为<code>7ch*4+2=1F2</code>地址处的值，即CS:IP=0:200</p><img src="/2022/08/20/22-0820-09/image-20220904160907876-16622789481813.png" class="" title="image-20220904160907876"><p>然后一步步调试，十进制1234转为16进制也就是3C44，然后3C44*3C44=173C44，存放在AX和DX两个寄存器中，高位在DX中，低位在AX中，如下：</p><img src="/2022/08/20/22-0820-09/image-20220904160940339.png" class="" title="image-20220904160940339"><h1 id="bios-dos"><a class="markdownIt-Anchor" href="#bios-dos"></a> BIOS、DOS</h1><p>在系统板的ROM种存放着一套程序，称为BIOS（基本输入输出系统），BIOS主要包含以下内容：</p><ol><li>硬件系统的检测和初始化程序</li><li>存储着外部中断和内部中断的中断例程</li><li>用于对硬件设备进行I/O操作的中断例程</li><li>其他和硬件系统相关的中断例程</li></ol><p>操作系统DOS提供了中断例程（如果操作系统为windows，那么windows系统API就类似中断例程），DOS的中断例程其实就是操作系统给我们程序员提供的编程资源 （我们可以直接int指令调用中断例程，类似上面的 int 7ch 直接得到 ax 的平方）</p><p>BIOS和DOS（操作系统）所提供的中断例程中包含了许多子程序（造好的轮子），这些子程序实现了我们在编程的时候经常要用的功能，所以我们要用这些功能的时候不用自己造轮子，直接int指令调用即可</p><p>BIOS和DOS中断例程安装过程：</p><ol><li>CPU一加电（开机），初始化CS=0FFFFH,IP=0,自动从FFFF:0单元开始执行程序，FFFF:0处有一条跳转指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序</li><li>初始化程序将把BIOS提供的中断例程的入口地址登记在中断向量表中</li><li>硬件检测和初始化完成后，调用19h(int 19h)进行操作系统的引导，从此之后计算机交由操作系统控制</li><li>操作系统（dos）启动后，除了完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量（提供的中断例程的入口地址登记在中断向量表中）</li></ol><h1 id="中断例程的多个子程序"><a class="markdownIt-Anchor" href="#中断例程的多个子程序"></a> 中断例程的多个子程序</h1><p>一个供程序员调用的中断例程中往往包含多个子程序，中断例程内部用传递进来的参数来决定执行哪一个子程序。BIOS和DOS提供的中断例程都用<code>ah</code>来传递内部子程序的编号</p><p>例如 int 10h 中断例程（int 10h是BIOS提供的）中包含了很多与屏幕输出相关的子程序</p><div class="code-wrapper"><pre><code class="hljs txt">assume cs:codecode segmentstart:mov ah,2;10h中断例程里的第2个子程序功能是设置光标;设置参数mov bh,0;显存第0页mov dh,5;第5行mov dl,12;第12列;参数设置完后调用中断例程int 10hcode endsend start</code></pre></div><p>编译上述程序，然后运行exe文件</p><img src="/2022/08/20/22-0820-09/image-20220904161236687.png" class="" title="image-20220904161236687"><div class="code-wrapper"><pre><code class="hljs txt">assume cs:codecode segmentstart:mov ah,2;设置光标位置mov bh,0mov dh,7mov dl,13int 10hmov ah,9;9号子程序，功能是在光标位置显示字符mov al,&#x27;X&#x27;mov bl,11001010b;00000100b颜色属性mov bh,0;第0页mov cx,5;字符重复个数int 10hcode endsend start</code></pre></div><p>编译中上述程序，执行</p><img src="/2022/08/20/22-0820-09/image-20220904161309656.png" class="" title="image-20220904161309656">]]></content>
    
    
    <categories>
      
      <category>16位汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编day8</title>
    <link href="/2022/08/20/22-0820-08/"/>
    <url>/2022/08/20/22-0820-08/</url>
    
    <content type="html"><![CDATA[<h1 id="cpu三种工作模式"><a class="markdownIt-Anchor" href="#cpu三种工作模式"></a> CPU三种工作模式</h1><ul><li><p>实模式：最早的PC机，没有windows系统，一开机就是dos窗口，缺陷就是不安全，程序可以随意访问任何的物理地址</p></li><li><p>保护模式：32位cpu带有保护模式，特权级 ，0~3，0为最高特权，是内核代码所运行的级别，3是最低权限，为用户程序的运行级别</p><p>PC加载操作系统的过程：开机—&gt;加电自检—&gt;从磁盘中寻找boot引导程序去加载内核—&gt;如果装的是windows系统（多任务系统），将由它把CPU切换到保护模式下运行</p></li><li><p>虚拟8086（dos）：比如：我们电脑中日常用的dos窗口、前面常用的dosbox都是虚拟出来的</p></li></ul><h1 id="中断"><a class="markdownIt-Anchor" href="#中断"></a> 中断</h1><p>中断分为内中断和外中断</p><h2 id="内中断"><a class="markdownIt-Anchor" href="#内中断"></a> 内中断</h2><p>内中断：发生了需要CPU立刻要去处理的信息。CPU发生中断的情况也是不同的，会产生了4种不同的中断信息，那就需要进行不同的处理，如下：</p><ul><li><p>除法错误（除法溢出）</p><img src="/2022/08/20/22-0820-08/image-20220904154211857.png" class="" title="image-20220904154211857"></li><li><p>单步调试，我们在前面的学习中经常用到dosbox单步调试（-t命令）</p></li><li><p>执行into指令</p></li><li><p>执行int指令</p></li></ul><h2 id="中断类型码"><a class="markdownIt-Anchor" href="#中断类型码"></a> 中断类型码</h2><p>中断类型码：CPU在接受到中断信息后，需要判断是啥类型的中断，中断类型码就标识了它是啥中断类型</p><ul><li>除法错误—&gt;中断类型码 0</li><li>单步执行—&gt;中断类型码 1</li><li>执行into指令—&gt;中断类型码 4</li><li>执行int指令（int n）—&gt;中断类型码 n</li></ul><h2 id="中断向量表"><a class="markdownIt-Anchor" href="#中断向量表"></a> 中断向量表</h2><p>中断向量表：通过中断类型码作为表项号去定位中断向量表的表项，从而获得程序的入口地址，对于8086机器，中断向量表指定存放在内存地址0000:0000到0000:03FF之间（一共124个单元）</p><p>中断向量表大致如下：</p><img src="/2022/08/20/22-0820-08/image-20220904154522947.png" class="" title="image-20220904154522947"><p>中断向量表的一个表项占4个字节（2个字)，高位地址存放段地址，低位地址存放偏移地址，比如：0号表项的中断处理程序的入口地址为 CS:IP = 0020:0100，那么0号表项具体如下：</p><img src="/2022/08/20/22-0820-08/image-20220904154621695.png" class="" title="image-20220904154621695"><p>作业：现在问：2号中断源处理程序的入口地址是啥？？？？</p><p>解答：</p><img src="/2022/08/20/22-0820-08/image-20220904154640150.png" class="" title="image-20220904154640150"><p>2号中断源处理程序的入口地址CS:IP = 0070:0008</p><h2 id="中断过程"><a class="markdownIt-Anchor" href="#中断过程"></a> 中断过程</h2><p>用中断类型码找到中断向量（中断向量表中的表项），用它设置CS:IP，这个称为中断过程，由CPU硬件自动完成</p><p>整个中断的过程大致如下：<br />CPU收到中断信息—&gt;要对中断信息做处理—&gt;首先将引发中断过程—&gt;硬件完成自动完成中断过程—&gt;CS:IP会指向中断处理程序的入口，CPU就会执行这个中断处理程序</p><p>注意：程序执行完中断处理程序后，肯定还要回到原程序继续往后执行，所以硬件肯定会把执行中断前的CS:IP的值保存起来（通过将CS和IP入栈来进行保存），然后执行完中断处理程序后，再将CS:IP指向之前的CS:IP，使程序继续向下执行</p><p>中断过程6部区：</p><ol><li>取得中断类型码N</li><li>标志寄存器的值入栈</li><li>设置标志寄存器的第8位TF和第9位EF的值，将这两个值改为0</li><li>CS入栈</li><li>IP入栈</li><li>从内存地址中找到中断类型码<code>N*4</code>和<code>N*4+2</code>的两个字单元中，读取中断处理程序的入口地址，设置IP和CS</li></ol><h2 id="iret指令"><a class="markdownIt-Anchor" href="#iret指令"></a> IRET指令</h2><p>IRET指令：中断返回，中断服务程序的最后⼀条指令。IRET指令将推⼊堆栈的段地址和偏移地址弹出，使程序返回到原来发⽣中断的地⽅。其作⽤是从中断中恢复中断前的状态。</p><p>IRET作用大致相当于如下3条指令的功能：</p><div class="code-wrapper"><pre><code class="hljs txt">POP IPPOP CSPOPF</code></pre></div><h2 id="外中断"><a class="markdownIt-Anchor" href="#外中断"></a> 外中断</h2><p>外中断 ：来自于 CPU 外部，CPU 检测到发送过来的中断信息，引发中断过程，处理外设的输入</p><p>主板和接口板上装有各种接口芯片，这些外设接口芯片里面有一些寄存器，CPU是把这些寄存器当作<strong>端口</strong>来访问。外设的输入不直接送入内存和CPU，而是送入相关接口芯片端口里面，cpu向外设的输出也是先送到端口，再由端口的相关芯片送到外设。（<strong>cpu通过端口和外部设备进行联系</strong>）</p><p>外中断源分为2种：</p><ul><li><p>可屏蔽中断，CPU可以不鸟你的外中断，搭不搭理你要看标志寄存器IF位的设置，IF=1要搭理你，IF=0不鸟你，不响应（几乎所有的外设引发的外中断都是可屏蔽中断）</p><p>如果IF=1，那么中断步骤如下：</p><ol><li>取得中断类型码</li><li>标志寄存器入栈 pushf</li><li>TF=0 IF=0</li><li>CS IP入栈</li><li>设置cs和ip指向处理中断的程序</li></ol></li><li><p>不可屏蔽中断。中断类型码固定是2，见到这个，CPU必须要引发中断过程</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>16位汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编Day7</title>
    <link href="/2022/08/20/22-0820-07/"/>
    <url>/2022/08/20/22-0820-07/</url>
    
    <content type="html"><![CDATA[<h1 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h1> <img src="/2022/08/20/22-0820-07/image-20220904115923463.png" class="" title="image-20220904115923463"><img src="/2022/08/20/22-0820-07/image-20220904115940443.png" class="" title="image-20220904115940443"><p>实现效果如下：</p><img src="/2022/08/20/22-0820-07/image-20220904120204099.png" class="" title="image-20220904120204099"><blockquote><p>这个题目好tm的难理解。。</p></blockquote><div class="code-wrapper"><pre><code class="hljs txt">作业解答:assume cs:code,ds:data,ss:stackdata segment    ;数据段    db  &#x27;geinaizishaozhi&#x27;      db  1000 0010B      ;闪烁(高亮)绿色    db  1010 0100B          ;高亮绿底红色    db  1111 0001B          ;高亮白底蓝色data endsstack segment stack   ;栈段    db 128 dup(0)stack endscode segment    start:        mov ax,stack        mov ss,sp        mov sp,128                ;数据从哪里来？？从data段中来        mov ax,data        mov ds,ax        mov si,0            mov bx,16                ;数据要到哪里去? 到显存中        mov ax,0b800H        mov es,ax        mov di,160*12+60        mov cx,3                ;处理数据    s0: push cx        push si        push di        mov cx,16            s:  mov dh,ds:[bx]          ;dx=dh+dl        mov dl,ds:[si]        mov es:[di],dx        inc si        add di,2        loop s                pop di        pop si        pop cx        add di,160        inc bx        loop s0                mov ax,4c00h        int 21h        code endsend start</code></pre></div><h1 id="call"><a class="markdownIt-Anchor" href="#call"></a> call</h1><p>day6 的学习中最后学习到了 <code>依据位移进行转移的call指令</code> ，今天学习下面的：</p><h2 id="转移的目的地址在指令中的call"><a class="markdownIt-Anchor" href="#转移的目的地址在指令中的call"></a> 转移的目的地址在指令中的CALL</h2><ul><li><p>转移的目的地址在指令中的CALL：<code>call for ptr 标号</code>实现是段间转移</p><img src="/2022/08/20/22-0820-07/image-20220904143244067.png" class="" title="image-20220904143244067"></li><li><p>转移地址在寄存器的call：相当于只会push一个ip，然后跳转一个16位寄存器（比如：jmp ax）</p></li><li><p>转移地址在内存中的call：有如下两种格式：</p><ul><li><code>call word ptr [内存单元地址]</code> （相当于先把ip放到栈中push ip，然后跳转到内存单元 jmp word ptr 内存单元）</li><li><code>call dword ptr [内存单元地址]</code>（相当于先push cs，再push ip，然后跳转到内存单元 jmp dword ptr 内存单元 ）</li></ul></li></ul><h1 id="call-ret-retf的结合"><a class="markdownIt-Anchor" href="#call-ret-retf的结合"></a> call、ret、retf的结合</h1><p>比如说我们对上面的作业设计成类似C语言的函数的结构，类似于先调用initReg函数，再调用showStr</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code,<span class="hljs-built_in">ds</span>:data,<span class="hljs-built_in">ss</span>:stackdata <span class="hljs-meta">segment</span><span class="hljs-comment">;数据段</span><span class="hljs-built_in">db</span><span class="hljs-string">&#x27;geinaizishaozhi&#x27;</span> <span class="hljs-built_in">db</span><span class="hljs-number">1000</span> <span class="hljs-number">0010B</span><span class="hljs-comment">;闪烁(高亮)绿色</span><span class="hljs-built_in">db</span><span class="hljs-number">1010</span> <span class="hljs-number">0100B</span>        <span class="hljs-comment">;高亮绿底红色</span><span class="hljs-built_in">db</span><span class="hljs-number">1111</span> <span class="hljs-number">0001B</span><span class="hljs-comment">;高亮白底蓝色</span>data endsstack <span class="hljs-meta">segment</span> stack   <span class="hljs-comment">;栈段</span><span class="hljs-built_in">db</span> <span class="hljs-number">128</span> dup(<span class="hljs-number">0</span>)stack endscode <span class="hljs-meta">segment</span><span class="hljs-symbol">start:</span><span class="hljs-keyword">call</span> initReg<span class="hljs-comment">;目的是初始化 </span><span class="hljs-keyword">call</span> showStr<span class="hljs-comment">;目的在屏幕上显示字符串</span><span class="hljs-symbol"></span><span class="hljs-symbol">initReg:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,stack<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>,<span class="hljs-built_in">sp</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>,<span class="hljs-number">128</span><span class="hljs-comment">;数据从哪里来？？从data段中来</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,data<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">16</span><span class="hljs-comment">;数据要到哪里去? 到显存中</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0b800H</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">160</span>*<span class="hljs-number">12</span>+<span class="hljs-number">60</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">3</span><span class="hljs-keyword">ret</span> <span class="hljs-symbol"></span><span class="hljs-symbol">showStr:</span><span class="hljs-symbol">s0:</span><span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><span class="hljs-keyword">push</span> <span class="hljs-built_in">si</span><span class="hljs-keyword">push</span> <span class="hljs-built_in">di</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">16</span><span class="hljs-symbol">s:</span><span class="hljs-keyword">mov</span> <span class="hljs-number">dh</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">bx</span>]<span class="hljs-comment">;dx=dh+dl</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">si</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">di</span>],<span class="hljs-built_in">dx</span><span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">2</span><span class="hljs-keyword">loop</span> s<span class="hljs-keyword">pop</span> <span class="hljs-built_in">di</span><span class="hljs-keyword">pop</span> <span class="hljs-built_in">si</span><span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">160</span><span class="hljs-keyword">inc</span> <span class="hljs-built_in">bx</span><span class="hljs-keyword">loop</span> s0<span class="hljs-keyword">ret</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span>code endsend start</code></pre></div><h1 id="mul乘法指令"><a class="markdownIt-Anchor" href="#mul乘法指令"></a> mul乘法指令</h1><p>mul乘法指令，要求两个数都是8位，或者2个数都是16做乘法，如果是8位乘法，一个默认放在al中，另一个在另外一个8位寄存器或者内存里面；如果是16位乘法，一个默认放在ax中，另一个在另外一个16位寄存器或者内存单元里面，8位的乘法结果在ax里面，16位乘法结果高位在DX，低位存放在AX中</p><p>比如：8位的乘法，10*5</p><img src="/2022/08/20/22-0820-07/image-20220904144158260.png" class="" title="image-20220904144158260"><p>比如：16位的乘法，64*2710的值，注意：这里的64和2710都是16进制，如果转为10进制的话就是<code>100*10000</code>，而8位寄存器最大值存放是255，这里显然必须要用到16位寄存器</p><img src="/2022/08/20/22-0820-07/image-20220904144208808.png" class="" title="image-20220904144208808"><p>高位存放在DX中，低位存放在AX中，两个合并后：F4240 即 1,000,000</p><h1 id="除法溢出"><a class="markdownIt-Anchor" href="#除法溢出"></a> 除法溢出</h1><blockquote><p>关于除法指令div前面已经学过</p></blockquote><img src="/2022/08/20/22-0820-07/image-20220904144328640.png" class="" title="image-20220904144328640"><p>如何解决除法溢出，解决除法溢出的公式如下：</p><p><code>X/N = int(H/N)*65536+[rem(H/N)65536+L]/N</code>该公式其实就是把x/n可能溢出的除法运算转变成多个不会产生溢出的除法运算</p><p>其中：X表示被除数，N表示除数，H表示X的高16位，L表示X的低16位，int()表示取商，rem()表示取余数</p><img src="/2022/08/20/22-0820-07/image-20220904144337906.png" class="" title="image-20220904144337906"><h1 id="标志flag寄存器"><a class="markdownIt-Anchor" href="#标志flag寄存器"></a> 标志（FLAG）寄存器</h1><p>标志寄存器的作用：</p><ul><li>存储相关指令的某些执行结果</li><li>用来为CPU执行相关指令提供依据</li><li>控制CPU的相关工作方式</li></ul><img src="/2022/08/20/22-0820-07/image-20220904145027592.png" class="" title="image-20220904145027592"><p>标志寄存器也是16位，也就是2个字节，标志寄存器存的信息通常被称为程序状态字（PSW），标志寄存器是按位起作用的，一共有16位，每个位的含义都是不同的</p><img src="/2022/08/20/22-0820-07/image-20220904145039141.png" class="" title="image-20220904145039141"><h2 id="zf标志位"><a class="markdownIt-Anchor" href="#zf标志位"></a> ZF标志位</h2><p>ZF标志（零标志位）：记录相关运算结果是否为0，如果ZF为1，代表运算结果为0，如果ZF为0，代表运算结果不为0</p><div class="code-wrapper"><pre><code class="hljs perl">mov ax,<span class="hljs-number">1</span><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">ax</span>,1  </span>;<span class="hljs-function"><span class="hljs-keyword">sub</span>减法指令</span><span class="hljs-function">执行上面两条命令后，<span class="hljs-title">ax</span>=0，则<span class="hljs-title">ZF</span>标志位为1</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">2</span><span class="hljs-keyword">sub</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">1</span>执行上面两条指令后，<span class="hljs-built_in">ax</span>≠<span class="hljs-number">0</span>，则ZF标志位为<span class="hljs-number">0</span></code></pre></div><img src="/2022/08/20/22-0820-07/image-20220904145146424.png" class="" title="image-20220904145146424"><p>由于ZF标志位和运算结果相关，那么ZF标志位就会影响到标志寄存器，在8086CPU指令集中，如下指令都会影响到标志寄存器的某些位（这里应该就是影响zf标志位）：<br />add、sub、mul、div、inc、or、and会影响标志寄存器的某些位</p><h2 id="pf标志位"><a class="markdownIt-Anchor" href="#pf标志位"></a> PF标志位</h2><p>PF标志位（奇偶数标志位）：相关指令之后，其结果所有的bit位中1的个数是否为偶数</p><div class="code-wrapper"><pre><code class="hljs txt">mov al,1add al,10执行后的结果为11（注意：这里是10进制的11，但是dosbox这么写貌似是16进制的，实际应该写成mov 10h这种形式才更加规范的表示16进制，后面学习反正也不用dosbox。。），ax对应的二进制就是00001011B，一共有3个(奇数个)1，则pf=0</code></pre></div><p>如下 为dosbox中，和上面例子有些区别。。。这里是16进制，上面例子是10进制的。。。</p><img src="/2022/08/20/22-0820-07/image-20220904145305977.png" class="" title="image-20220904145305977"><div class="code-wrapper"><pre><code class="hljs txt">mov al,1or al,2执行后的二进制结果为00000011B，有2个(偶数个)1，则pf=1</code></pre></div><h2 id="sf标志位"><a class="markdownIt-Anchor" href="#sf标志位"></a> SF标志位</h2><p>SF标志位（符号标志位）：这个标志位是对<code>有符号数</code>结果的记录，注意这里记录的是有符号数，比如：对于<code>10000001B</code>而言，如果是无符号数代表129，但如果换算成有符号数则代表-127，计算过程如下：</p><div class="code-wrapper"><pre><code class="hljs txt">10000001b的反码为11111110b，补码为11111111b（此亦是原码），即十进制的－127。补充反码和补码计算过程：正数的反码与其原码相同;负数的反码是对其原码逐位取反,但符号位除外。正数的补码与其原码相同,负数的补码是在其反码的末位加1</code></pre></div><p>相关指令执行后，其结果是否为负数，则SF=1，结果为非负数，则SF=0</p><div class="code-wrapper"><pre><code class="hljs txt">mov al,10000001Badd al,1B执行后结果为1000 0010B，1000 0010B有符号数转化后就是10进制的-126,由于是负数，sf=1</code></pre></div><div class="code-wrapper"><pre><code class="hljs txt">mov al,10000001Badd al,01111111B执行后结果为0，则sf=0</code></pre></div><h2 id="cf标志"><a class="markdownIt-Anchor" href="#cf标志"></a> CF标志</h2><p>CF标志：在进行<code>无符号运算</code>时，记录了2个数做加法的进位值，或是2个数做减法的借位值</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">98h</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">al</span>上述代码执行后，<span class="hljs-built_in">al</span>=<span class="hljs-number">30h</span>，cf=<span class="hljs-number">1</span>，cf记录了进位值</code></pre></div><p>两个数字做加法：</p><p>正常来说16进制的：98+98=130</p><img src="/2022/08/20/22-0820-07/image-20220904145736058.png" class="" title="image-20220904145736058"><p>通过计算器我们发现两个十六进制98相加后，对应10进制为 1 0011 0000 显然已经超出了16位，那么我们只能将最高位的1放到标志寄存器中，所以最终的结果为 110000B ，也就是30h</p><img src="/2022/08/20/22-0820-07/image-20220904145749740.png" class="" title="image-20220904145749740"><p>两个数字做减法：</p><div class="code-wrapper"><pre><code class="hljs txt">mov al,97hsub al,98h执行后al=FFh，CF=1，cf记录了借位值</code></pre></div><img src="/2022/08/20/22-0820-07/image-20220904145809148.png" class="" title="image-20220904145809148"><div class="code-wrapper"><pre><code class="hljs txt">sub al,al  执行后al=0，cf=0</code></pre></div><h2 id="of标志位"><a class="markdownIt-Anchor" href="#of标志位"></a> OF标志位</h2><p>OF标志：记录<code>有符号数</code>运算时是否发生了溢出，溢出，则OF=1，没有溢出，则OF=0（注意和CF做区分，CF是针对无符号数的）</p><div class="code-wrapper"><pre><code class="hljs dns">比如：<span class="hljs-number">88</span>有符号数(<span class="hljs-number">16</span>进制)，对应二进制为<span class="hljs-number">10001000</span>，这里的<span class="hljs-number">10001000</span>是补码，先将补码转为反码<span class="hljs-number">11110111</span>，然后将反码+<span class="hljs-number">1</span>转为原码<span class="hljs-number">1111 1000</span>，该原码高位第一个<span class="hljs-number">1</span>是符号位，剩下的<span class="hljs-number">111 1000</span>就是<span class="hljs-number">120</span>，也就是-<span class="hljs-number">120</span>F0有符号数(<span class="hljs-number">16</span>进制)，对应二进制为<span class="hljs-number">11110000</span>，也就是-<span class="hljs-number">16</span>（转化过程同上）mov al,<span class="hljs-number">88h</span>add al,F0执行指令相加后，-<span class="hljs-number">120</span>+(-<span class="hljs-number">16</span>)=<span class="hljs-number">136</span>，但是<span class="hljs-number">8</span>位的al寄存器范围为-<span class="hljs-number">128~127</span>，显然这里溢出了</code></pre></div><img src="/2022/08/20/22-0820-07/image-20220904145938288.png" class="" title="image-20220904145938288"><h2 id="df标志位"><a class="markdownIt-Anchor" href="#df标志位"></a> DF标志位</h2><p>DF标志位（方向标志位）：控制si、di的增减</p><ul><li>df=0时，si、di递增</li><li>df=1时，每次操作si、di递减</li></ul><h2 id="debug中标志寄存器的表示如下"><a class="markdownIt-Anchor" href="#debug中标志寄存器的表示如下"></a> debug中标志寄存器的表示如下</h2><table><thead><tr><th>标志</th><th>值为1的标记</th><th>值为0的标记</th></tr></thead><tbody><tr><td>of</td><td>OV (overflow)</td><td>NV(not overflow)</td></tr><tr><td>sf</td><td>NG(负数)</td><td>PL(正数)</td></tr><tr><td>zf</td><td>ZR(为0)</td><td>NZ(not zero 不为0)</td></tr><tr><td>pf</td><td>PE(偶数)</td><td>PO(奇数)</td></tr><tr><td>cf</td><td>CY(carry yes有进位或借位)</td><td>NC(not carry 没有进或借)</td></tr><tr><td>df</td><td>DN(向下)</td><td>UP(向上)</td></tr></tbody></table><h1 id="adc指令addcarry"><a class="markdownIt-Anchor" href="#adc指令addcarry"></a> adc指令（add+carry）</h1><p>adc指令（add+carry）：带进位的加法指令，会把CF位上记录的<code>进位值/借位值</code>加起来</p><div class="code-wrapper"><pre><code class="hljs txt">mov ax,2mov bx,1sub bx,ax  ;由于是无符号数，且1-2肯定是要借位的，CF=1adc ax,1   ;等价于ax+1，然后再加上cf，也就是ax+1+cf=2+1+1=4</code></pre></div><div class="code-wrapper"><pre><code class="hljs txt">mov ax,1add ax,ax;这里没有进位或借位，cf=0adc ax,5;ax+5+cf=2+5+9=7</code></pre></div><div class="code-wrapper"><pre><code class="hljs txt">利用adc对任意大的数据进行加法，计算1EF0001000H+2010001EF0H1EF0001000H = 001E F000 1000H2010001EF0H = 0020 1000 1EF0Hmov ax,001EHmov bx,F000Hmov cx,1000Hadd cx,1EF0Hadc bx,1000Hadc ax,0020H</code></pre></div><h1 id="sbb指令"><a class="markdownIt-Anchor" href="#sbb指令"></a> sbb指令</h1><p>sbb指令：带借位的减法指令（应用类似于adc）</p><h1 id="cmp比较指令"><a class="markdownIt-Anchor" href="#cmp比较指令"></a> cmp比较指令</h1><p>cmp比较指令：功能相当于减法指令，但是不保存结果，cmp指令执行后，对标志寄存器产生影响</p><div class="code-wrapper"><pre><code class="hljs txt">cmp ax,ax;相当于ax-ax，但是并不保存结果在ax中，仅仅是为了影响标志寄存器的相关位，该指令执行后，标志寄存器中的zf=1，pf=1，sf=0，cf=0，f=0无符号数的比较cmp ax,bx如果ax = bx 相减结果为0，所以zf=1如果ax 不等于 bx，相减结果不为0，所以zf=0如果ax &lt; bx 必然产生借位，所以cf=1如果ax &gt; bx 既不会产生借位，结果又不可能是0，所以cf=0并且zf=0如果ax 大于等于 bx，不会借位，cf=0如果ax 小于等于 bx，可能会产生借位，结果也可能为0，所以cf=1或zf=1通过这点我们就可以看出这指令的设计思路：通过做减法运算，影响标志寄存器，标志寄存器的相关位就记录了比较的结果</code></pre></div><h1 id="检测比较结果的条件转移指令"><a class="markdownIt-Anchor" href="#检测比较结果的条件转移指令"></a> 检测比较结果的条件转移指令</h1><blockquote><p>转移指令：即修改ip的指令，比如之前学过的jcxz指令</p></blockquote><p>cmp和检测标志位的条件转移配合使用，就像call和ret</p><div class="code-wrapper"><pre><code class="hljs txt">指令    含义     检测的相关标志位je   等于则转移   zf=1jne  不等于则转移  zf=0jb   低于则转移   cf=1 jnb  不低于则转移  cf=0ja   高于则转移    cf=0且zf=0jna  不高于则转移  cf=1或zf=1比如：实现条件判断……（相当于高级语言的if）如果ah = bh 则ah= ah+ah 否则ah=ah+bh实现的具体指令如下：cmp ah,bh;比较ah和bh的值je s;如果ah和bh相等，则跳转到s标号add ah,bhjmp ok;为了避免执行完add ah,bh后执行s标号处的指令，所以直接跳转到程序结束s:add ah,ahok:mov ax,4c00h;程序结束的地方int 21h</code></pre></div><h1 id="串传送指令"><a class="markdownIt-Anchor" href="#串传送指令"></a> 串传送指令</h1><h2 id="movsb"><a class="markdownIt-Anchor" href="#movsb"></a> movsb</h2><p>movsb：每次传送一个字节，将ds:si指向的内存单元中的字节送入es:di中，根据df的值，将si和di递增或递减</p><div class="code-wrapper"><pre><code class="hljs txt">mov es:[di],ds:[si] df=0的话inc siinc didf=1的话dec sidec di</code></pre></div><h2 id="movsw"><a class="markdownIt-Anchor" href="#movsw"></a> movsw</h2><p>movsw：每次传送一个字，将ds:si指向的内存单元中的字节送入es:di中，根据df的值，将si和di递增2或者递减2</p><div class="code-wrapper"><pre><code class="hljs txt">mov es:[di],ds:[si] df=0的话add si,2add di,2df=1的话sub si,2sub di,2</code></pre></div><h1 id="rep指令"><a class="markdownIt-Anchor" href="#rep指令"></a> rep指令</h1><p>rep指令：在CX不等于0的情况下，重复执行后面的指令，重复的次数也在CX中，重复一次后CX-1</p><div class="code-wrapper"><pre><code class="hljs txt">比如说:rep movsb 也就是一直执行movsb指令（当然还要看cx的值），等价于下面的指令：s: movsbloop s</code></pre></div><h1 id="cld-std指令"><a class="markdownIt-Anchor" href="#cld-std指令"></a> cld、std指令</h1><p>cld指令：将DF位设置为0</p><p>std指令：将DF位设置为1</p><div class="code-wrapper"><pre><code class="hljs txt">作业：;将data段中的第一个字符串复制到它后面的空间中data segmentdb &#x27;geinaizishaozhi!&#x27;db 16 dup (0)data endscode segment;设置ds:si指向data:0mov ax,datamov ds,axmov si,0mov es,axmov di,16mov cx,16cld;设置df=0，每次si和di递增rep movsb;如果每次传送一个字cx改成8，movsb替换成movswcode ends</code></pre></div><h1 id="pushf指令"><a class="markdownIt-Anchor" href="#pushf指令"></a> pushf指令</h1><p>pushf指令：将标志寄存器的值压栈</p><p>当前栈的内容</p><img src="/2022/08/20/22-0820-07/image-20220904153245753.png" class="" title="image-20220904153245753"><p>执行pushf后栈的内容</p><img src="/2022/08/20/22-0820-07/image-20220904153256032.png" class="" title="image-20220904153256032"><p>7202是标志寄存器的值，转化成二进制即：</p><div class="code-wrapper"><pre><code class="hljs txt">111 0010 0000 0010</code></pre></div><p>这16位就对应如下图：</p><img src="/2022/08/20/22-0820-07/image-20220904153322175.png" class="" title="image-20220904153322175"><h1 id="popf指令"><a class="markdownIt-Anchor" href="#popf指令"></a> popf指令</h1><p>popf指令：从栈顶弹出数据送入标志寄存器</p>]]></content>
    
    
    <categories>
      
      <category>16位汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编Day6</title>
    <link href="/2022/08/20/22-0820-06/"/>
    <url>/2022/08/20/22-0820-06/</url>
    
    <content type="html"><![CDATA[<h1 id="jcxz"><a class="markdownIt-Anchor" href="#jcxz"></a> jcxz</h1><p>上节课学了段内和段间转移，但实际在操作中，我们直接使用 jmp s 即可，不需要写成 jmp short s 或 jmp far s 这样 ,不用考虑其它，那些都是编译器要考虑的事情</p><p>转移地址在寄存器里面，如：jmp ax，jmp bx</p><p>转移地址在内存中（段内转移），如下：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0123H</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>],<span class="hljs-built_in">ax</span><span class="hljs-keyword">jmp</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>]   <span class="hljs-comment">;就是jmp到ds:0123地址的地方，执行后ip=0123h</span></code></pre></div><p>转移地址在内存中（段间转移），修改cs和ip偏移地址，高地址的字是目的段地址，低地址处存放的目的偏移地址，如下：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0123h</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>],<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">2</span>],<span class="hljs-number">0</span><span class="hljs-keyword">jmp</span> <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>]   <span class="hljs-comment">;执行完后，ip=0123H，cs=0，即cs:ip = 0000:0123</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs TXT">作业：;要求执行jmp指令后，cs:ip指向程序需要的第一条指令assume cs:codedate segmentdd 12345678Hdata endscode segmentstart:mov ax,datamov ds,axmov bx,0mov bx,???mov [bx+2],??? jmp dword ptr ds:[0]code endsend start解答：第一个？为0,第二个是cs</code></pre></div><p>有条件的跳转指令 jcxz ，所有有条件的转移指令都是短转移，范围是 -128~127，if cx 等于0，那么就会执行 jcxz ，也就是会 jmp short 标号，如果if cx不为0，那么就啥也不干（程序按顺序向下执行），恰好和loop指令相反（loop是cx不等于0的时候执行）</p><div class="code-wrapper"><pre><code class="hljs txt">作业：利用jcxz指令，实现在内存2000H段中查找到第一个值为0的字节，找到后将它的偏移地址存在dx中code segmentstart:mov ax,2000Hmov ds,axmov bx,0s:___mov ch,0___           ;这里ch和cl合并就是cx，cx=0时，jcxz跳转到ok标号处___mov cl,[bx]______jcxz ok______inc bx___jmp sok:mov dx,bxmov ax,4c00hint 21hcode endsend start</code></pre></div><p>loop指令也是转移指令，所有循环指令都是短转移，在对应的机器码中包含转移的偏移地址，-128~127</p><p>loop 标号，cx = cx -1，判断cx不等于0，转移到标号处执行指令，如果等于0什么也不做。</p><p>通过分析下面的程序，在运行前思考这个程序可以正确返回吗？？运行后再思考：为啥是这种结果？？？通过该程序加深对相关内容理解，注意jmp指令对应的机器码，cpu最终执行的是机器码</p><div class="code-wrapper"><pre><code class="hljs txt">assume cs:codesgcodesg segment        mov ax,4c00h        int 21hstart:  mov ax,0    s:  nop        nop        mov di,offset s        mov si,offset s2        mov ax,cs:[si]        mov cs:[di],ax    s0: jmp short s    s1: mov ax,0        int 21h        mov ax,0    s2: jmp short s1        nopcodesg endsend start</code></pre></div><h1 id="ret-retf-call"><a class="markdownIt-Anchor" href="#ret-retf-call"></a> ret、retf、call</h1><p>CALL、RET、RETF指令都是转移指令，其中CALL、RET修改ip，RETF同时修改cs和ip，可以通过这三个指令的配合实现子程序设计（相当于其它语言的函数功能）</p><h2 id="ret-retf"><a class="markdownIt-Anchor" href="#ret-retf"></a> ret、retf</h2><p>cpu执行ret指令时，把栈顶的数据赋值给ip，就等价于如下：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ip</span><span class="hljs-built_in">ip</span> = (<span class="hljs-built_in">ss</span>*<span class="hljs-number">16</span>+<span class="hljs-built_in">sp</span>) ,这里用括号表示<span class="hljs-built_in">ip</span>是<span class="hljs-built_in">ss</span>*<span class="hljs-number">16</span>+<span class="hljs-built_in">sp</span>地址对应的值<span class="hljs-built_in">sp</span> = <span class="hljs-built_in">sp</span>+<span class="hljs-number">2</span></code></pre></div><img src="/2022/08/20/22-0820-06/image-20220904114503770.png" class="" title="image-20220904114503770"><p>cpu执行retf指令时，把栈顶的数据赋值给ip，然后把第二次栈顶的数据赋值给cs，也就是pop两次，先pop ip，再pop cs，如下：</p><img src="/2022/08/20/22-0820-06/image-20220904114556768.png" class="" title="image-20220904114556768"><div class="code-wrapper"><pre><code class="hljs txt">作业:补全程序，实现从内存1000:0000处开始执行指令stack segmentdb 16 dup (0)stack endscode segmentstart:mov ax,stackmov ss,axmov sp,16mov ax,_1000h___push axmov ax,__0000h__push axretfcode endsend start</code></pre></div><h2 id="call"><a class="markdownIt-Anchor" href="#call"></a> call</h2><p>call指令：分为依据位移进行转移和转移目的地址在指令中</p><h3 id="依据位移进行转移的call指令"><a class="markdownIt-Anchor" href="#依据位移进行转移的call指令"></a> 依据位移进行转移的call指令</h3><ul><li><p>call 标号（将当前的ip压栈后，跳到标号处执行指令）</p><img src="/2022/08/20/22-0820-06/image-20220904114854730.png" class="" title="image-20220904114854730"><p>执行后ax的值为6，执行call s后，会把当前ip 0006放到栈内，然后跳到 s 标号处，执行pop ax命令，将栈顶的0006给ax，所以最终ax为6</p><p><strong>这里一定要记住：CPU执行命令的三部曲：</strong></p><ol><li>从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器</li><li><strong>IP+读取到的指令长度，指向下一条指令</strong>（所以上面执行call s前，当前的ip为3+3=6）</li><li>执行指令缓冲器中的指令</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>16位汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编Day5</title>
    <link href="/2022/08/20/22-0820-05/"/>
    <url>/2022/08/20/22-0820-05/</url>
    
    <content type="html"><![CDATA[<h1 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h1><div class="code-wrapper"><pre><code class="hljs txt">作业：1.将datasg段中每个单词的前四个字母改为大写字母，（每个段大小是16字节，对齐方便寻址）assume cs:codesg,ss:stacksg,ds:datasgdatasg segment  db &#x27;1. naizi      &#x27;  db &#x27;2. madou        &#x27;  db &#x27;3. hackr      &#x27;  db &#x27;4. sec66       &#x27;datasg ends解答：assume cs:code,ss:stacksg,ds:datasgdatasg segment  db &#x27;1. naizi&#x27;  db &#x27;2. madou&#x27;  db &#x27;3. hackr&#x27;  db &#x27;4. sec66&#x27;datasg endsstacksg segmentstack db 128 dup()stacksg endscode segmentstart:mov ax,stacksgmov ss,axmov sp,128mov ax,datasgmov ds,axmov cx,4mov bx,0s:push cxmov si,0    mov cx,5s1:and byte ptr 3[bx][si],11011111B inc siloop s1add bx,16pop cxloop smov ax,4c00hint 21hcode endsend start</code></pre></div><h1 id="offset"><a class="markdownIt-Anchor" href="#offset"></a> offset</h1><p>offset 是由编译器处理的符号，作用是取标号的<code>偏移地址</code></p><p>比如：</p><div class="code-wrapper"><pre><code class="hljs X86ASM"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codecode <span class="hljs-meta">segment</span><span class="hljs-symbol">start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,offset start    <span class="hljs-comment">;相当于mov ax,0</span><span class="hljs-symbol">s:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,offset s        <span class="hljs-comment">;相当于mov ax,3，由于前面的mov ax,offset start机器码占三个字节，所以这里偏移3，即mov ax,3</span>code endsend start</code></pre></div><p>如下：</p><img src="/2022/08/20/22-0820-05/image-20220904102253206.png" class="" title="image-20220904102253206"><p>注意：</p><div class="code-wrapper"><pre><code class="hljs txt">bx不能和bp加在一起寻址，如：[bx+bp]si不能和di加在一起寻址，如：[si+ds]可以用bx+si或di  bp+si或di</code></pre></div><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codecode <span class="hljs-meta">segment</span><span class="hljs-symbol">s:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">bx</span>           <span class="hljs-comment">;将mov ax,bx指令放到nop处</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,offset s         <span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,offset s0<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">cs</span>:[<span class="hljs-built_in">si</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">cs</span>:[<span class="hljs-built_in">di</span>],<span class="hljs-built_in">ax</span><span class="hljs-symbol">s0:</span><span class="hljs-keyword">nop</span><span class="hljs-keyword">nop</span>code endsend s</code></pre></div><p>详解：</p><p>上述代码目的如下：</p><img src="/2022/08/20/22-0820-05/image-20220904102603672.png" class="" title="image-20220904102603672"><p>调式代码：</p><img src="/2022/08/20/22-0820-05/image-20220904102612033.png" class="" title="image-20220904102612033"><img src="/2022/08/20/22-0820-05/image-20220904102616212.png" class="" title="image-20220904102616212"><p>注意：这里在-t的话，下一步也就是执行mov ax,cs:[si]</p><img src="/2022/08/20/22-0820-05/image-20220904102625227.png" class="" title="image-20220904102625227"><p>执行mov ax,cs:[si]，此时cs为076a，si为0000，也就是cs:si，076a:0地址对应的值如下：</p><img src="/2022/08/20/22-0820-05/image-20220904102633273.png" class="" title="image-20220904102633273"><p>而8BC3也就是mov ax,bx的机器码</p><img src="/2022/08/20/22-0820-05/image-20220904102641288.png" class="" title="image-20220904102641288"><p>然后我们 -T 执行，ax的值变成了C38B，然后再次-T，就会执行mov cs:[di],ax</p><img src="/2022/08/20/22-0820-05/image-20220904102647758.png" class="" title="image-20220904102647758"><p>注意：cs:di是076A:000E，而076a:000E默认对应的机器码是09，执行 NOP指令</p><img src="/2022/08/20/22-0820-05/image-20220904102655826.png" class="" title="image-20220904102655826"><p>执行完mov cs:[di],ax就会将ax的值C38B给076A:000E，那么076A:000E对应机器码就是C38B，NOP指令就会变成mov ax,bx</p><p>我们发现-T执行完 mov cs:[di],ax 后，本来下面应该是执行NOP指令，但是NOP指令已经变成了mov ax,bx，所以下面执行mov ax,bx</p><img src="/2022/08/20/22-0820-05/image-20220904102705040.png" class="" title="image-20220904102705040"><p><strong>注意：</strong><br />这里的cs:[si]，其中cs是指令寄存器的段地址，而[si]是指令寄存器的偏移地址，前面最常用的就是ds:[0]这种，注意这里的ds不能省略，不能写成 [0]，但是 ds:[bx] 这样的是可以省略ds，写成[bx]（因为汇编编译器和debug对指令的处理不同，详见：汇编day3）</p><h1 id="转移指令jmp"><a class="markdownIt-Anchor" href="#转移指令jmp"></a> 转移指令（jmp）</h1><p>可以修改ip，或者同时修改cs和ip的指令统称之为转移指令</p><p>只修改ip，称之为段内转移，比如：jmp ax</p><p>同时修改cs和ip，称之为段间转移，比如：jmp 1000:0</p><p>偏移地址（寻址范围）最大ffff，转移指令对IP修改的范围不同，段内转移又分为：短转移和近转移</p><p>短转移修改IP的范围为：-128~127（也就是ff 256）</p><p>近转移修改IP的范围为：-32768~32767（也就是ffff 65536）</p><p>转移指令分为以下几类：</p><ul><li>无条件转移指令（如jmp）</li><li>条件转移指令（可以帮助我们做一些类似c语言中的if操作）</li><li>循环转移指令（如：loop）</li><li>中断（后面会学）</li></ul><p>依据位移进行转移的jmp指令，jmp short 标号 （实现段内短转移），short指明的是进行短转移，标号指明要转移的目的地，转移结束后，CS:IP应该指向标号处的指令，范围是8位（-128~127），ip+8位位移</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codecode <span class="hljs-meta">segment</span><span class="hljs-symbol">start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">123h</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><span class="hljs-keyword">jmp</span> short s<span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">1</span><span class="hljs-symbol">s:</span><span class="hljs-keyword">inc</span> <span class="hljs-built_in">ax</span>code endsend start</code></pre></div><p>调式上述代码，有如下疑惑 ？</p><img src="/2022/08/20/22-0820-05/image-20220904112838381.png" class="" title="image-20220904112838381"><p>正常的CPU执行指令的过程如下：</p><ol><li>从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器</li><li>IP+读取到的指令长度，指向下一条指令</li><li>执行指令缓冲器中的指令</li></ol><p>对于上述代码，则过程如下：</p><ol><li>当执行到jmp指令时候，也就是cs:ip = 076a:0006 时，对应机器码为EB03</li><li>读取指令EB03进入指令缓冲器</li><li>IP+2=<code>0008H</code>（EB03的长度为2），cs:ip指向076a:0008，也就是指向add ax,1</li><li>执行缓冲区指令EB<code>03</code></li><li>然后执行EB03后，进行跳转，跳转到000B，cs:ip指向inc ax（注意：这里的000B实际就是<code>0008+03</code>，EB03就是告诉CPU要转移的位移，当然这里就是转移3）</li></ol><p>jmp near ptr 标号，实现段内近转移，范围是16位（-32768~32767），ip+16位位移</p><p>jmp far ptr 标号，实现段间转移，又称为远转移。cs=标号所在段的段地址，ip=标号所在段的偏移地址，far ptr 指明了指令用标号的段地址和偏移地址修改cs和ip</p>]]></content>
    
    
    <categories>
      
      <category>16位汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编Day4</title>
    <link href="/2022/08/20/22-0820-04/"/>
    <url>/2022/08/20/22-0820-04/</url>
    
    <content type="html"><![CDATA[<h1 id="and和or指令"><a class="markdownIt-Anchor" href="#and和or指令"></a> AND和OR指令</h1><p>and：逻辑与，按位进行与运算，两个1才为1，不然为0</p><p>or：逻辑或指令，按位进行计算，有一个1就为1，不然为0</p><h1 id="字符串定义"><a class="markdownIt-Anchor" href="#字符串定义"></a> 字符串定义</h1><div class="code-wrapper"><pre><code class="hljs livecodeserver">assume cs:code<span class="hljs-keyword">string</span> <span class="hljs-keyword">segment</span>db <span class="hljs-string">&#x27;ayu&#x27;</span><span class="hljs-keyword">string</span> <span class="hljs-keyword">ends</span>code <span class="hljs-keyword">segment</span><span class="hljs-built_in">start</span>:mov ax,<span class="hljs-keyword">string</span>code <span class="hljs-keyword">ends</span><span class="hljs-function"><span class="hljs-keyword">end</span> <span class="hljs-title">start</span></span></code></pre></div><p>然后调试</p><img src="/2022/08/20/22-0820-04/image-20220902095749648.png" class="" title="image-20220902095749648"><p><strong>疑惑：</strong><code>db 'ayu'</code>，到底存储到代码段cs中，还是数据段ds中呢 ？（理论肯定是存在数据段ds中的）</p><p>这里采用mov ax,string来测试，发现mov ax,string就是mov ax,076a，所以显然<code>db 'ayu'</code>被存放到了076a，根据上图中ds的起始地址为075a，而cs的起始地址为076b，所以经过分析<code>db 'ayu'</code>确实被放到了数据段中</p><h1 id="psp区"><a class="markdownIt-Anchor" href="#psp区"></a> PSP区</h1><p>程序加载后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为0，则程序所在的内存区的地址为  ds:0，这个内存区的前256个字节（256对应16进制0100）中存放的是PSP，DOS用来和程序进行通信。从256字节处向后的空间存放的是程序。</p><img src="/2022/08/20/22-0820-04/image-20220902102015177.png" class="" title="image-20220902102015177"><p>注意：上图中为啥不写SA+0100H呢？？？？而是用的SA+10H呢？？？</p><p>正常来说应该是<code>SA+0100H:0</code>那么对应实际物理地址就是<code>SA*16+256 = SA*16+16*16 = 16(SA+16) = 16(DS+16)</code> (实际地址 = 段地址*16+偏移地址，这里的段地址和偏移地址换算成10进制运算)。而真正CS:IP对应的实际物理地址为<code>CS*16+IP</code>，而偏移地址IP开始为0，也就是<code>CS*16</code>，所以<code>DS+16 = CS</code>，由于这里采用的是10进制运算，16 就是十六进制的10h，所以<code>ds+10h = cs</code></p><p>比如：上面的ds=075a，那么psp的内容就是从075a:0到075a+10h:0，也就是075a:0到076a:0，而真正程序是从076a:0开始的，所以我们查看076a:0就可以看到我们定义的数据<code>db 'ayu'</code></p><img src="/2022/08/20/22-0820-04/image-20220903160907793.png" class="" title="image-20220903160907793"><p>但是这里076a:0为啥并不是CS:IP？？？？</p><img src="/2022/08/20/22-0820-04/image-20220903160916449.png" class="" title="image-20220903160916449"><p>可能是因为<code>db 'ayu'</code>是数据，但是CS寄存器存放的是指令，也就是说CS:IP指向存放指令的地方，而076a到076b这里面存放的是一些数据，就比如：刚才我们定义的段<code>db 'ayu'</code>，类似如下图：</p><img src="/2022/08/20/22-0820-04/image-20220903160925092.png" class="" title="image-20220903160925092"><p>现在我们将程序删除string段改成如下：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codecode <span class="hljs-meta">segment</span><span class="hljs-symbol">start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span>code endsend start</code></pre></div><p>重新debug后，如下：恰好DS和CS差10H，那么上面的猜测可能就是正确的</p><img src="/2022/08/20/22-0820-04/image-20220903160955361.png" class="" title="image-20220903160955361"><h1 id="寄存器si-di"><a class="markdownIt-Anchor" href="#寄存器si-di"></a> 寄存器SI、DI</h1><p>si和di功能和bx差不多的用法，但是不能和bx一样分成两个8位的寄存器</p><p>对于bx，经常的用法为：mov bx,0 或者mov bx,[0]，同理对于si、di也可以这样用：mov si,0 或者 mov si,[0]、mov di,0 或者 mov di,[0] 等</p><h1 id="寻址方式总结"><a class="markdownIt-Anchor" href="#寻址方式总结"></a> 寻址方式总结</h1><ul><li>直接寻址，比如：[0]、[1]</li><li>寄存器间接寻址，比如：[bx]、[si]、[di]、[bp]</li><li>寄存器相对寻址，比如：[bx+1]、[si+2] 等</li><li>基址加变址寻址，比如：[bx+si]、[bx+di]等</li><li>相对基址加变址寻址，比如：[bx+si+1]、[bx+di+2]</li></ul><div class="code-wrapper"><pre><code class="hljs x86asm">作业:<span class="hljs-comment">;将naizi、madou、caiji、linhu首字母变成大写</span><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code,<span class="hljs-built_in">ds</span>:datadata <span class="hljs-meta">segment</span><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;1. naizi........&#x27;</span><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;2. madou........&#x27;</span><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;3. caiji........&#x27;</span><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;4. linhu........&#x27;</span>data endscode <span class="hljs-meta">segment</span><span class="hljs-symbol">start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,data<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">0</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">4</span><span class="hljs-symbol">s:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[<span class="hljs-built_in">di</span>+<span class="hljs-number">3</span>]<span class="hljs-keyword">and</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">11011111B</span>  <span class="hljs-comment">;将首字母变成大写</span><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">di</span>+<span class="hljs-number">3</span>],<span class="hljs-built_in">al</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">16</span><span class="hljs-keyword">loop</span> s:<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span>code endsend start用两个循环实现把所有字母变成大写<span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code,<span class="hljs-built_in">ds</span>:datadata <span class="hljs-meta">segment</span><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;naizi...........&#x27;</span><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;madou...........&#x27;</span><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;caiji...........&#x27;</span><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;linhu...........&#x27;</span>data endsstack <span class="hljs-meta">segment</span><span class="hljs-built_in">dw</span> <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>  <span class="hljs-comment">;设置栈用于存放cx</span>code <span class="hljs-meta">segment</span><span class="hljs-symbol">start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,stack<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>,<span class="hljs-number">16</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,data<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">4</span><span class="hljs-symbol"></span><span class="hljs-symbol">s0:</span><span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">5</span><span class="hljs-symbol"></span><span class="hljs-symbol">s:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[<span class="hljs-built_in">bx</span>+<span class="hljs-built_in">si</span>]<span class="hljs-keyword">and</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">11011111b</span><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-built_in">si</span>],<span class="hljs-built_in">al</span><span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><span class="hljs-keyword">loop</span> s<span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">16</span><span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><span class="hljs-keyword">loop</span> s0<span class="hljs-keyword">loop</span> s<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>code endsend start</code></pre></div><h1 id="ptr"><a class="markdownIt-Anchor" href="#ptr"></a> ptr</h1><p>下面的指令中，寄存器指明了指令进行的是字操作：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">1</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>]     <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>],<span class="hljs-built_in">ax</span><span class="hljs-keyword">inc</span> <span class="hljs-built_in">ax</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">1000</span></code></pre></div><p>下面的指令中，寄存器指明了指令进行的是字节操作（因为是al）：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">1</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">bl</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>],<span class="hljs-built_in">al</span><span class="hljs-keyword">inc</span> <span class="hljs-built_in">al</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">100</span></code></pre></div><p>在没有寄存器名存在的情况下，既都是在内存，得用操作符 X ptr 指明内存单元的长度，X在汇编指令中可以为byte，word或者DWORD。要不然内存是片连续的区域，操作就乱了</p><p>例如：</p><p>下面的指令中，用word ptr 指明了指令访问的内存单元是一个字单元：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>],<span class="hljs-number">1</span><span class="hljs-keyword">inc</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>]<span class="hljs-keyword">inc</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>]<span class="hljs-keyword">add</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>],<span class="hljs-number">2</span></code></pre></div><p>下面的指令中，用byte ptr 指明了指令访问的内存单元是一个字节单元：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>],<span class="hljs-number">1</span><span class="hljs-keyword">inc</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>]<span class="hljs-keyword">inc</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>]<span class="hljs-keyword">add</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>],<span class="hljs-number">2</span></code></pre></div><p>在没有寄存器参与的内存单元访问指令中，用word prt 或byte ptr 显性地指明所要访问的内存单元的长度是很必要的。否则，CPU无法得知所要访问的单元，还是字节单元。假如我们用Debug查看内存的结果如下：</p><p>2000：1000 FF FF FF FF FF FF …</p><p>那么指令：<br />mov ax,2000H<br />mov ds,ax<br />mov byte ptr [1000H],1<br />将使内存中的内容变为：<br />2000: 1000 01 FF FF FF FF FF …</p><p>而指令：<br />mov ax,2000H<br />mov ds,ax<br />mov word ptr [1000H],1<br />将使内存中的内容变为：<br />2000：1000 01 00 FF FF FF FF …</p><h1 id="综合应用"><a class="markdownIt-Anchor" href="#综合应用"></a> 综合应用</h1><div class="code-wrapper"><pre><code class="hljs autoit">关于公司的一条记录如下：公司名称：<span class="hljs-built_in">DEC</span>公司姓名：naizi排名：<span class="hljs-number">250</span>收入：<span class="hljs-number">20</span>著名产品：pos</code></pre></div><img src="/2022/08/20/22-0820-04/image-20220903162344655.png" class="" title="image-20220903162344655"><p>现在进行如下操作：<br />修改排名为100<br />收入为50<br />产品变成amd</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">seg</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">60h</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">8</span>],<span class="hljs-number">100</span>  <span class="hljs-comment">;该指令也可写成mov word ptr [bx].8,100 </span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">10</span>],<span class="hljs-number">50</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">12</span>+<span class="hljs-built_in">si</span>],<span class="hljs-string">&#x27;A&#x27;</span> <span class="hljs-comment">;该指令也可写成mov byte ptr [bx][si].12,&#x27;A&#x27; 或写成mov byte ptr [bx].12[si],&#x27;A&#x27;</span><span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">12</span>+<span class="hljs-built_in">si</span>],<span class="hljs-string">&#x27;M&#x27;</span><span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">12</span>+<span class="hljs-built_in">si</span>],<span class="hljs-string">&#x27;D&#x27;</span></code></pre></div><h1 id="div除法指令"><a class="markdownIt-Anchor" href="#div除法指令"></a> div除法指令</h1><p>除法：有8位和16位两种，在一个寄存器或者内存单元中</p><p>被除数：如果除数为8位，被除数为16位，默认放在ax中，如果除数为16位，被除数一定为32位，在dx和ax中存放，dx存放高16位，ax存放低16位（注意：被除数一定比除数值大，除数是16位，则被除数一定是32位）</p><p>结果存放：如果除数为8位，则AL存放除法操作的商，AH存放除法操作的余数；如果除数是16位，则AX存放除法的商，DX存放余数</p><p>div byte ptr ds:[0] 的含义：由于在这里div后面是byte字节，也就是除数是8位，那么被除数一定为16位，AL存放ax÷(ds×16+0) 的商，AH存放ax÷(ds×16+0)的余数</p><p>div word ptr ds:[0] 的含义：由于在这里div后面是word字，也就是除数为16位，那么被除数一定为32位，AX存放的是 (dx×10000H+ax)÷(ds×16+0)的商，DX存放的是 (dx×10000H+ax)÷(ds×16+0)的余数</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-comment">;计算100001/100</span><span class="hljs-comment">;100001大于65535，所以用ax加dx两个寄存器联合存放，100001转化成16进制为186A1H</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,<span class="hljs-number">1</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">86A1H</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">100</span><span class="hljs-keyword">div</span> <span class="hljs-built_in">bx</span><span class="hljs-comment">;ax=商，dx=余数</span></code></pre></div><h1 id="伪指令-db-dw-dd"><a class="markdownIt-Anchor" href="#伪指令-db-dw-dd"></a> 伪指令 db 、dw 、dd</h1><p>dd 定义两个字型数据：double word</p><p>dup指令：进行数据重复</p><p>db 3 dup(0) 相当于 db 0,0,0</p><p>db 3 dup(0,1,2) 相当于 db 0,1,2,0,1,2,0,1,2</p>]]></content>
    
    
    <categories>
      
      <category>16位汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编Day3</title>
    <link href="/2022/08/20/22-0820-03/"/>
    <url>/2022/08/20/22-0820-03/</url>
    
    <content type="html"><![CDATA[<h1 id="bx-loop指令"><a class="markdownIt-Anchor" href="#bx-loop指令"></a> [bx]、loop指令</h1><h2 id="bx"><a class="markdownIt-Anchor" href="#bx"></a> [bx]</h2><p>前面day2天学习中，我们了解到了[0]的用法，如下：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">1000H</span> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">bx</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[<span class="hljs-number">0</span>]</code></pre></div><p>但这里中括号中的0是常量，我们还可放变量，比如：[bx]</p><div class="code-wrapper"><pre><code class="hljs X86ASM"><span class="hljs-comment">;如果ds已经是2000H</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">10</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,[<span class="hljs-built_in">bx</span>]<span class="hljs-comment">;这个指令就相当于mov ax,2000H:10,也就是把2000H:10这个字型数据给ax</span><span class="hljs-comment">;如果是mov dl,[0]，那么这个是把字节型数据给mov，因为dl只有8位</span></code></pre></div><p>inx bx 指令的作用是让bx+1，相当于bx=bx+1或者是bx++</p><h2 id="loop指令"><a class="markdownIt-Anchor" href="#loop指令"></a> loop指令</h2><p>loop 指令，在汇编里面代表循环，类似于c语言的while、for循环。</p><p>loop 指令的使用格式：<code>loop 标号</code>，CPU 执行 loop 指令时，首先执行 CX = CX-1，然后判断 CX 的值，CX的值如果不为0，就会跳到标号处执行程序，如果为0，就按顺序向下执行。</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-comment">;比如：如果要用指令实现2的三次方，可用如下方法</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">2</span><span class="hljs-comment">;ax=2</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">ax</span><span class="hljs-comment">;ax=2+2=4  </span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">ax</span><span class="hljs-comment">;ax=4+4=8</span><span class="hljs-comment">;但是这里如果要实现2的12次方呢？？？用上面的方法一直加下去就不太好，这里就用循环实现，用如下代码实现</span><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codecode <span class="hljs-meta">segment</span>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">2</span>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">11</span>    <span class="hljs-symbol"></span><span class="hljs-symbol">s:</span>  <span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">ax</span>    <span class="hljs-keyword">loop</span> s            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span>    <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span>code endsend</code></pre></div><p>对上面2的12次方debug下，-u后我们发现ayu.exe会先执行mov ax,0002，然后再执行mov cx,000B，一直向下执行下去，然后到loop指令的时候，会再跳回到上面的add ax,ax指令</p><img src="/2022/08/20/22-0820-03/image-20220830212722071.png" class="" title="image-20220830212722071"><p>然后我们可以-t来一条条的指令看下</p><img src="/2022/08/20/22-0820-03/image-20220830212728134.png" class="" title="image-20220830212728134"><p>注意，上面的第二条指令<code>mov cx,000B</code>，这里000B实际就是十进制的11，也就是源程序中的<code>mov cx,11</code>，当然mov cx,11也可以写成<code>mov cx,0BH</code>，这里必须是0BH，不能写成BH，在汇编中数据不能以字母开头，所以在前面加个0</p><img src="/2022/08/20/22-0820-03/image-20220830212735344.png" class="" title="image-20220830212735344"><p>cx存放的是程序（机器码）长度（字节数），一共15个字节，也就是十六进制的F</p><img src="/2022/08/20/22-0820-03/image-20220830212744246.png" class="" title="image-20220830212744246"><div class="code-wrapper"><pre><code class="hljs txt">作业:编程，用加法计算123*236,结果存在ax中123*236就是236个123相乘，即123×123×123×123...代码如下：code segmentmov ax,123mov cx,236s:add ax,axloop smov ax,4c00hint 21hcode endsend</code></pre></div><h1 id="debug和汇编编译器处理指令的区别"><a class="markdownIt-Anchor" href="#debug和汇编编译器处理指令的区别"></a> Debug和汇编编译器处理指令的区别</h1><p>用debug输入如下指令</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">2000h</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[<span class="hljs-number">0</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">bl</span>,[<span class="hljs-number">1</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,[<span class="hljs-number">2</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>,[<span class="hljs-number">3</span>]</code></pre></div><img src="/2022/08/20/22-0820-03/image-20220902093058566.png" class="" title="image-20220902093058566"><p>然后用编译器编译和debug如下程序</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codecode <span class="hljs-meta">segment</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">2000h</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[<span class="hljs-number">0</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">bl</span>,[<span class="hljs-number">1</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,[<span class="hljs-number">2</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>,[<span class="hljs-number">3</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span>code endsend</code></pre></div><img src="/2022/08/20/22-0820-03/image-20220902093112633.png" class="" title="image-20220902093112633"><p>那么，我们如何解决上面的问题呢？？把代码改成如下，添加上段前缀<code>ds:</code>，然后编译器就会把[0]当成地址处理了</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codecode <span class="hljs-meta">segment</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">2000h</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">bl</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-number">1</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-number">2</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-number">3</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span>code endsend</code></pre></div><p>或者用类似如下的形式也可以mov al,<code>[bx]</code>，中括号里面为变量，而不是常量0，如果要用ss段寄存器，那么前面必须有<code>ss:</code>[bx]，而默认中括号前啥都没有就是ds寄存器</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codecode <span class="hljs-meta">segment</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">2000h</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[<span class="hljs-built_in">bx</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">ss</span>:[<span class="hljs-built_in">bx</span>]<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span>code endsend</code></pre></div><p>注意：我们以后写代码用200:2FF这段空间，这个空间是没有用的，向别的内存空间中写入可能直接会导致死机或者其他的事情。。。</p><img src="/2022/08/20/22-0820-03/image-20220902093157911.png" class="" title="image-20220902093157911"><div class="code-wrapper"><pre><code class="hljs txt">作业:将内存ffff:0到fff:c的单元中的数据复制到0:200到0:20c单元中，注意：0:200到0:20c等价于0020:0到0020:c，因为合成后物理地址都一样assume cs:codecode segmentmov bx,0mov cx,0CHs:mov ax,0ffffhmov ds,axmov dx,[bx]mov ax,0020hmov ds,axmov [bx],dxadd bx,2loop smov ax,4c00hint 21hcode endsend;除了上述方法，还可以用es这个段地址寄存器来实现assume cs:codecode segmentmov bx,0mov cx,0CHmov ax,0ffffhmov ds,axmov ax,0020hmov es,axs:mov dx,[bx]mov es:[bx],dx   ;es不可省略，分号是汇编的注释符号add bx,2loop smov ax,4c00hint 21hcode endsend</code></pre></div><p>上面的程序中是只有一个段的<code>code segment</code>，也就是代码段，但是有的包含多个段，比如，同时包含代码段和数据段，那么数据段肯定要在内存中占用一定的空间，操作系统就会给数据段分配一定的空间，注意：操作系统给程序分配的空间都是安全的，因为操作系统不会让一个程序所用空间和其他程序或操作系统自己空间相冲突</p><p>程序获取所需要的空间有2种方法：</p><ol><li>加载程序的时候为程序分配内存</li><li>在程序执行过程中向系统申请（c语言的malloc）</li></ol><h1 id="start用法"><a class="markdownIt-Anchor" href="#start用法"></a> Start用法</h1><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codecode <span class="hljs-meta">segment</span><span class="hljs-built_in">dw</span> <span class="hljs-number">123h</span>,<span class="hljs-number">0456h</span>,<span class="hljs-number">0abch</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0ffffh</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span> code endsend</code></pre></div><p>编译，调试上面的程序，我们发现并不是从mov ax,0ffffh开始执行的，如果想从正常从mov ax,0ffffh开始执行的话，需要加上start</p><img src="/2022/08/20/22-0820-03/image-20220902094335774.png" class="" title="image-20220902094335774"><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codecode <span class="hljs-meta">segment</span><span class="hljs-built_in">dw</span> <span class="hljs-number">123h</span>,<span class="hljs-number">0456h</span>,<span class="hljs-number">0abch</span> <span class="hljs-comment">;定义字型数据，数据之间有逗号隔开</span><span class="hljs-symbol">start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0ffffh</span>  <span class="hljs-comment">;这里的start可以定义成任意名称</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span> code endsend start</code></pre></div><p>重新编译，调试，就是从mov ax,0ffffh正常开始执行了，并且我们发现cs:ip变成了076A:0006，偏移地址ip变成了0006，恰好我们定义了三个字型数据，也就是6个字节</p><img src="/2022/08/20/22-0820-03/image-20220902094608872.png" class="" title="image-20220902094608872"><p>查看076a:0的地址内容，就发现了我们的字型数据</p><img src="/2022/08/20/22-0820-03/image-20220902094810500.png" class="" title="image-20220902094810500"><h1 id="定义栈段"><a class="markdownIt-Anchor" href="#定义栈段"></a> 定义栈段</h1><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code,<span class="hljs-built_in">ds</span>:data,<span class="hljs-built_in">ss</span>:stackdata <span class="hljs-meta">segment</span><span class="hljs-built_in">dw</span> <span class="hljs-number">0123h</span>,<span class="hljs-number">0456h</span>data endsstack <span class="hljs-meta">segment</span><span class="hljs-built_in">dw</span> <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>  <span class="hljs-comment">;栈的内存空间</span>stack endscode <span class="hljs-meta">segment</span><span class="hljs-symbol">start:</span>     <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,data<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,stack<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>,<span class="hljs-number">10h</span>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span>    <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span>code endsend start</code></pre></div><div class="code-wrapper"><pre><code class="hljs txt">课后作业：1.编程向内存0:200~0:23F依次传送数据0~63(3FH) 备注：只能使用9条指令 包括mov ax,4c00h int 21h解答：assume cs:codecode segmentmov cx,3Fhmov ax,0mov ds,axmov bx,0s:mov [bx+200],blinc blloop smov ax,4C00hint 21hcode endsend2. 下面程序的功能是将&quot;mov ax,4c00h&quot;之前的指令复制到内存0:200处，补全程序用debug调试，跟踪运行结果assume cs:codecode segment    mov ax,__cs___ ;注意复制的是指令，指令在cs寄存器中    mov ds,ax    mov ax,0020h  ;注意：0:0200等价于0020:0，合成后物理地址一样    mov es,ax    mov bx,0    mov cx,__17h__ ;这里为啥是17h，看下面解析s:  mov al,[bx]    mov es:[bx],al    inc bx    loop s        mov ax,4c00h    int 21hcode endsend  3.编写code段中的代码，将naizi段和madou段中的数据依次相加，将结果存到feiwudidi段assume cs:codenaizi segment db 1,2,3,4,5,6,7,8naizi endsmadou segment db 1,2,3,4,5,6,7,8madou endsfeiwudidi segment db 0,0,0,0,0,0,0,0feiwudidi endscode segmentstart:   ?code endsend start解答：assume cs:codenaizi segment db 1,2,3,4,5,6,7,8naizi endsmadou segment db 1,2,3,4,5,6,7,8madou endsfeiwudidi segment db 0,0,0,0,0,0,0,0feiwudidi endscode segmentstart:mov ax,feiwudidimov es,axmov bx,0mov cx,8s:mov ax,naizimov ds,axmov dl,[bx]mov ax,madoumov ds,axadd dl,[bx]mov es:[bx],dlinc bxloop scode endsend start4.编写code段中的代码，用push指令将a段中的前8个字型数据逆序存储到b段中assume cs:codea segment    dw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fha endsb segment    dw 0,0,0,0,0,0,0,0b endscode segment    start: ?code endsend start解答：assume cs:codea segment    dw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fha endsb segment    dw 0,0,0,0,0,0,0,0b endscode segment    start:mov ax,b    mov ss,ax ;设置栈    mov sp,16 ;设置栈偏移地址 ;10进制的16        mov ax,a    mov ds,ax    mov bx,0        mov cx,8  ;控制循环次数    s:push [bx]  ;入栈    add bx,2    loop s            code endsend start</code></pre></div><p>第2题解析：</p><img src="/2022/08/20/22-0820-03/image-20220902094927400.png" class="" title="image-20220902094927400">]]></content>
    
    
    <categories>
      
      <category>16位汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编day2</title>
    <link href="/2022/08/20/22-0820-02/"/>
    <url>/2022/08/20/22-0820-02/</url>
    
    <content type="html"><![CDATA[<h1 id="内存中字节的存储方式"><a class="markdownIt-Anchor" href="#内存中字节的存储方式"></a> 内存中字节的存储方式</h1><p>8086 CPU是用16位寄存器来存储一个字，内存单元是以字节划分的，如下：0,1,2,3， 0,1两个内存单元存放的就是4E20H</p><img src="/2022/08/20/22-0820-02/image-20220830202004406.png" class="" title="image-20220830202004406"><h1 id="ds段寄存器和address"><a class="markdownIt-Anchor" href="#ds段寄存器和address"></a> DS段寄存器和[address]</h1><p>在CPU要读写内存单元的时候，我们必须得给出内存单元的地址才行呀，那么在8086 CPU里，内存地址由段地址+偏移地址组成，里面有一个DS的段寄存器来存放段地址</p><p>比如：我们这里要读取10000H内存单元的内容，如下：</p><div class="code-wrapper"><pre><code class="hljs X86ASM"><span class="hljs-keyword">mov</span>  <span class="hljs-built_in">bx</span>,<span class="hljs-number">1000H</span>   <span class="hljs-comment">;将1000H给bx通用寄存器</span><span class="hljs-keyword">mov</span>  <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">bx</span>      <span class="hljs-comment">;将bx的值赋值给ds段寄存器，也就是此时段寄存器存放着1000H</span><span class="hljs-keyword">mov</span>  <span class="hljs-built_in">al</span>,[<span class="hljs-number">0</span>]     <span class="hljs-comment">;注意：因为cpu读取数据时要知道段地址+偏移地址的，ds:[0] == 段地址:偏移地址，而中括号里面的0表示的就是偏移地址，中括号表示的是内存单元，上面读取10000H，如果要读取10001H，那么偏移1即可</span></code></pre></div><p>通过上面的三个指令，就可以让al寄存器读取到10000H内存单元的数据，但是如何反过来让寄存器的值赋值到内存单元？？？？通过<code>mov 内存单元地址:寄存器</code>  即可</p><p>注意：这里一定不能把1000H直接赋值给ds段寄存器，而是通过另一个寄存器bx间接将1000H赋值给段寄存器</p><h1 id="代码段和数据段"><a class="markdownIt-Anchor" href="#代码段和数据段"></a> 代码段和数据段</h1><p>我们可以将<code>一段内存定义为一个段</code>。用一个段地址指示段，用偏移地址访问段内的单元。这完全是我们自己可以决定的。</p><p>代码段：用来存放代码（通过用来存放程序执行的指令），段的基地址放在寄存器 CS 中，指令指针寄存器 IP 用来表示下一条指令在段中的偏移地址</p><p>数据段：用来存放程序处理的数据（通常用来存放程序中已初始化的（非 0）全局变量和静态局部变量），段的基地址存放在寄存器 DS 中。对数据段中的某个数据进行操作时，直接在汇编代码中通过立即数或寄存器来指定偏移地址</p><div class="code-wrapper"><pre><code class="hljs x86asm">作业:写几条指令，累加数据段中的前<span class="hljs-number">3</span>个字型数据，段地址为<span class="hljs-number">123BH</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span>   <span class="hljs-comment">;先把ax的数据置空</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">123BH</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,[<span class="hljs-number">0</span>]   <span class="hljs-comment">;也可以写成add ax,ds:[0]</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,[<span class="hljs-number">2</span>] <span class="hljs-comment">;这里为啥是2呢，因为这里是“字”型数据，所以为16位，也就2个存储单元（2个字节），所以每次增加2</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,[<span class="hljs-number">4</span>]</code></pre></div><p>作业解析：</p><img src="/2022/08/20/22-0820-02/image-20220830203705980.png" class="" title="image-20220830203705980"><p><code>add ax,[0]</code>也就是把3412这个数据给ax，然后<code>add ax,[2]</code>把7856这个数据给ax，<code>add ax,[4]</code>把6622这个数据给ax，这样就累加了前3个字型数据</p><h1 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h1><p>栈是特殊的访问方式的存储结构，CPU都有栈的设计，CPU提供相关指令以栈的方式读取内存空间，我们编程的时候可以将一段内存当作栈来使用，栈可以用于存储临时数据。</p><p>栈的结构如下：</p><img src="/2022/08/20/22-0820-02/image-20220830203831861.png" class="" title="image-20220830203831861"><p>栈有点类似于杯子，如果以a、b、c进栈，然后出栈的时候就是c、b、a，同时始终有一个标记指向栈顶，如果c出栈之后，那么标记就指向b</p><h2 id="入栈-出栈"><a class="markdownIt-Anchor" href="#入栈-出栈"></a> 入栈、出栈</h2><p>有两条指令可以操作栈，PUSH（入栈）、POP（出栈），入栈和出栈都是以<code>字</code>为单位</p><p>如：比如：<code>push ax</code>就是将ax的值放入栈，<code>pop ax</code>将栈顶的值出栈放入ax</p><p><strong>栈中数据的存放位置</strong></p><p>比如ax=1000H，然后我们 push ax，把ax的值压栈，注意：这里最下面是高地址，所以存放1000H时候，下面10，上面是00。然后让ax=2000H，再次 push ax 压栈，如下：</p><img src="/2022/08/20/22-0820-02/image-20220830204440835.png" class="" title="image-20220830204440835"><p>现在，我们要取出ax的值1000H，是不是只要执行pop ax 即可呢？？肯定不是，如果我们pop ax的话取出的值实际是2000H，pop指令肯本不知道ax是啥东西，只会取出栈顶的数据，那么我们如何取出ax的值呢？？？</p><p>可以先pop取出2000H，然后放到bx寄存器中，然后再取出1000H即可</p><h2 id="ss-sp寄存器"><a class="markdownIt-Anchor" href="#ss-sp寄存器"></a> SS、SP寄存器</h2><p>上面了解了栈，虽然在内存中是可以方便的定义一个栈了，但是，我们为什么要定义这么一个栈呢？自然，是为了操作方便，同时提供给 CPU 使用的，既然 CPU 要使用的话，自然，CPU 又必须根据一定的方式找到这个栈，而这就需要使用 SS 和 SP 寄存器了</p><p>栈顶的段地址存放在 SS 中，偏移地址在 SP 中，<code>任意时刻</code>，SS:SP就可以知道栈顶在哪里</p><p>如下：栈顶就是073F:00FD</p><img src="/2022/08/20/22-0820-02/image-20220830205442039.png" class="" title="image-20220830205442039"><p>再举个栗子，如下是内存中的栈</p><p>执行AX = 1122H，然后 PUSAH AX，执行后如下图，这里的栈顶SS:SP为1000H:000EH，那么这个栈顶是看出来的呀？因为SS是栈段地址，SP是栈的偏移地址，由于段地址×16+偏移地址就是实际的物理地址，而物理地址为1000EH，所以拆解1000EH即可得到SS为1000H，而SP为000EH</p><img src="/2022/08/20/22-0820-02/image-20220830205523642.png" class="" title="image-20220830205523642"><p>然后再次压栈，bx = 6677H，push bx，执行压栈后，SP的值发生变化，sp = sp-2，原本sp=000EH，减2后，sp=000C。而这里段地址SS肯定是不发生变化的，那么SS:SP = 1000H:000CH，如下图：</p><img src="/2022/08/20/22-0820-02/image-20220830205647442.png" class="" title="image-20220830205647442"><p>然后执行出栈操作，pop ax，注意：这里pop出ax的值为6677H，然后再执行SP = SP + 2，执行后sp的值由000CH变成000EH，如下图 ：</p><img src="/2022/08/20/22-0820-02/image-20220830205654587.png" class="" title="image-20220830205654587"><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">作业:</span>将10000H-1000FH这段空间当作栈，初始状态栈是空的，此时SS=1000H，SP=？？ （特别注意）0010H</code></pre></div><p>解析：</p><p>如下图，栈是空的</p><img src="/2022/08/20/22-0820-02/image-20220830205826726.png" class="" title="image-20220830205826726"><p>如果这里我们压入数据 1122H，这里那么毫无疑问，如下图：</p><img src="/2022/08/20/22-0820-02/image-20220830205835841.png" class="" title="image-20220830205835841"><p>但是这里问题是没有任何数据，那么我们直接把刚才写入的数据出栈即可，sp由000EH减2，如下图：</p><img src="/2022/08/20/22-0820-02/image-20220830205845476.png" class="" title="image-20220830205845476"><p>最终得到SP=0010H</p><h2 id="栈溢出"><a class="markdownIt-Anchor" href="#栈溢出"></a> 栈溢出</h2><p>如果栈内存大小就是4个字节，那么我们向里面压入数据，1122H、3344H，如下，已经放满了数据了</p><img src="/2022/08/20/22-0820-02/image-20220830205956602.png" class="" title="image-20220830205956602"><p>但是如果我们持续push压入数据的话，那么就会覆盖掉其它的数据，如下，并且如果压入的指令的话，并且把指令压入了CS:IP指向的内存空间，而8086 cpu任意时刻都会从CS:IP指向的内存中读取指令，那么程序就直接执行我们压入的指令了</p><img src="/2022/08/20/22-0820-02/image-20220830210005867.png" class="" title="image-20220830210005867"><p>pop可能造成栈顶越界，栈顶到了其它的内存空间</p><img src="/2022/08/20/22-0820-02/image-20220830210014390.png" class="" title="image-20220830210014390"><p>为了防止上面的溢出或者越界，CPU最好能够记录栈顶的上限和下限在哪里，这样一直pop就不越界，但这里学习的16位cpu没有该功能，32位的是有这个功能的。（金丝雀保护机制，后续再学习）</p><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">作业:</span>补齐下面程序，使他可以将10000H-1000FH中的8个字，逆序复制到20000H-2000FH中mov ax,2000hmov ds,ax- - -在此处补充指令- - - pop [E]pop [C]pop [A]pop [8]pop [6]pop [4]pop [2]pop [0]<span class="hljs-section">解答:</span>mov ax,2000hmov ds,ax- - - mov bx,1000h  mov ss,bx  //设置栈顶SSmov sp,0   //设置栈顶SP- - -pop [E]  //出栈把值放到内存地址中，这里的内存地址前面mov ax,2000h、mov ds,ax设置好了段地址2000h，[E]即偏移地址，两个一合成，段地址2000h×16+偏移地址000E得到内存中物理地址2000EHpop [C]  pop [A]pop [8]pop [6]pop [4]pop [2]pop [0]</code></pre></div><h2 id="对栈的分析"><a class="markdownIt-Anchor" href="#对栈的分析"></a> 对栈的分析</h2><p>向2000:0写入11,22,33,44,55,66</p><img src="/2022/08/20/22-0820-02/image-20220830210632162.png" class="" title="image-20220830210632162"><p>然后把ss:sp设置成2000:0</p><img src="/2022/08/20/22-0820-02/image-20220830210639111.png" class="" title="image-20220830210639111"><p>设置后，类似如下：</p><img src="/2022/08/20/22-0820-02/image-20220830210646646.png" class="" title="image-20220830210646646"><h3 id="pop出栈分析"><a class="markdownIt-Anchor" href="#pop出栈分析"></a> POP出栈分析</h3><p>然后-a设置来执行pop ax指令</p><img src="/2022/08/20/22-0820-02/image-20220830210708912.png" class="" title="image-20220830210708912"><p>-t执行后，sp的值加了2，并且ax的值变成了2211</p><img src="/2022/08/20/22-0820-02/image-20220830210716264.png" class="" title="image-20220830210716264"><p>pop出栈后，我们再次查看2000:0这里的数据，发现了11,22已经出栈了</p><img src="/2022/08/20/22-0820-02/image-20220830210723248.png" class="" title="image-20220830210723248"><p>然后再次执行pop ax操作，ax的值变成了4433，并且原本的33,44也已经出栈了</p><img src="/2022/08/20/22-0820-02/image-20220830210730955.png" class="" title="image-20220830210730955"><h3 id="push入栈分析"><a class="markdownIt-Anchor" href="#push入栈分析"></a> PUSH入栈分析</h3><p>同样2000:0处数据如下：</p><img src="/2022/08/20/22-0820-02/image-20220830210933972.png" class="" title="image-20220830210933972"><p>然后把ss:sp改成2000:4，图解如下:</p><img src="/2022/08/20/22-0820-02/image-20220830210941315.png" class="" title="image-20220830210941315"><p>然后把ax的值改成0000，并且push ax的值，然后sp的值由4变成了2</p><img src="/2022/08/20/22-0820-02/image-20220830210947907.png" class="" title="image-20220830210947907"><p>同时我们查看d2000:0的数据</p><img src="/2022/08/20/22-0820-02/image-20220830210954995.png" class="" title="image-20220830210954995"><p>压入ax的值0000后，如下：</p><img src="/2022/08/20/22-0820-02/image-20220830211001586.png" class="" title="image-20220830211001586"><p>然后再次压入ax的值0000</p><img src="/2022/08/20/22-0820-02/image-20220830211008964.png" class="" title="image-20220830211008964"><p>图解如下：</p><img src="/2022/08/20/22-0820-02/image-20220830211016110.png" class="" title="image-20220830211016110"><p>在这里压栈要注意下，经常容易有个误区：</p><p>当sp为4时，如果mov ax,0，然后push ax的话，之前一直以为压入栈内的0在如下位置，实际并不是。这里可以结合上面的作业题（当栈为空的时候，求解sp的值）多加理解</p><img src="/2022/08/20/22-0820-02/image-20220830211027991.png" class="" title="image-20220830211027991"><h1 id="汇编源程序执行过程"><a class="markdownIt-Anchor" href="#汇编源程序执行过程"></a> 汇编源程序执行过程</h1><ol><li>文本编辑汇编代码</li><li>使用汇编语言编译程序对源程序进行编译生成目标文件</li><li>再用连接程序对目标文件进行连接，生成可在操作系统中直接运行的可执行文件</li></ol>]]></content>
    
    
    <categories>
      
      <category>16位汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编Day1</title>
    <link href="/2022/08/20/22-0820-01/"/>
    <url>/2022/08/20/22-0820-01/</url>
    
    <content type="html"><![CDATA[<h1 id="进制基础"><a class="markdownIt-Anchor" href="#进制基础"></a> 进制基础</h1><ul><li>bit（比特） = 一个bit是一个0或1，叫做一个二进制位</li><li>byte（字节）=  1byte 是 8 个比特</li><li>16进制 = 4个2进制</li></ul><h1 id="汇编语言组成"><a class="markdownIt-Anchor" href="#汇编语言组成"></a> 汇编语言组成</h1><ul><li>汇编指令：由CPU执行，是机器码的助记符，有对应的机器码</li><li>伪指令：由编译器执行，没有对应的机器码，计算机不执行</li><li>其它符号：比如：+－*/ 由编译器识别执行，没有对应机器码</li></ul><h1 id="cpu组成"><a class="markdownIt-Anchor" href="#cpu组成"></a> CPU组成</h1><p>一个典型的CPU大概由运算器、控制器、寄存器构成。外部总线实现CPU和主板上其他器件的联系，内部总线实现CPU内部各个部件的链接</p><h1 id="寄存器-存储器-内存的区别"><a class="markdownIt-Anchor" href="#寄存器-存储器-内存的区别"></a> 寄存器、存储器、内存的区别</h1><ul><li>寄存器：是cpu组成部分，作用是将寄存器内的数据执行算术及逻辑运算，是操作数据的地方（当然也可以存储数据和指令）</li><li>存储器：在cpu外，一般指的是硬盘、U盘等可以在切断电源后保存资料的设备，是存放数据的地方。</li><li>更通俗的解释如下：（参考自知乎）<ul><li>解释一：<ul><li>寄存器就是你的口袋。身上只有那么几个，只装最常用或者马上要用的东西。</li><li>内存就是你的背包。有时候拿点什么放到口袋里，有时候从口袋里拿出点东西放在背包里。</li><li>辅存（外存）就是你家里的抽屉。可以放很多东西，但存取不方便。</li></ul></li><li>解释二：如果把被储存的东西比作能量<ul><li>寄存器就是 ATP，可以随时拿来用，性能高，但数量有限；</li><li>内存就是葡萄糖，性能一般，但是存量可以比较多；</li><li>外存（比如硬盘）就是脂肪，容量可以非常大，性能很差，要先转化为葡萄糖（存进内存），然后转化为 ATP（放到寄存器）才能直接利用（存取）。</li></ul></li><li>解释三：按最简单的数据的存储和操作距离来理解它们的区别：<ul><li>CPU（数据的操作）&lt;- - - &gt;缓存（数据的存储）&lt;- - - &gt;寄存器（指令等存储）&lt;- - -&gt;内存（需要等待的所有数据的存储）&lt;- - -&gt;外部存储器（硬盘、光盘等）</li></ul></li></ul></li></ul><h1 id="8086-cpu"><a class="markdownIt-Anchor" href="#8086-cpu"></a> 8086 CPU</h1><p>8086 CPU （Intel 8086 是一个由Intel于1978年所设计的16位微处理器芯片，是x86架构的鼻祖）有14个16位寄存器 AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW，其中AX，BX，CX，DX 这4个通常用来存放一般性数据，被称为通用寄存器</p><p>注意：8086 CPU 的上一代，也就是8086 CPU 的老爸实际是8位的，当然8086是16位的兼容8位的，所以为了兼容上一代的CPU， AX 寄存器（16位）可以分为两个<code>独立</code>的8位寄存器 AH，AL。同理，BX可分为BH、BL。CX分为CH、CL。DX分为DH、DL。</p><p>8086 cpu可以一次处理2种尺寸数据：<code>字节(byte)和字(word) ，一个字等于两个字节</code></p><h1 id="简单汇编指令"><a class="markdownIt-Anchor" href="#简单汇编指令"></a> 简单汇编指令</h1><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">18</span>    <span class="hljs-comment">;将18送入寄存器AX    AX = 18</span><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-number">88</span>    <span class="hljs-comment">;将88送入寄存器AH中   AH=88</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">8</span>     <span class="hljs-comment">;AX = AX+8</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">bx</span>    <span class="hljs-comment">;AX的值 = BX</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">bx</span>    <span class="hljs-comment">;ax = ax+bx</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">bl</span> <span class="hljs-comment">;这条指令是不正确的，ax是16位寄存器，bl是8位的，前后必须保持一致</span></code></pre></div><p>作业：</p><div class="code-wrapper"><pre><code class="hljs x86asm">程序段中的指令     指令执行后<span class="hljs-built_in">AX</span>中的值    指令执行后<span class="hljs-built_in">BX</span>中的值<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4E20H</span>      <span class="hljs-number">4E20H</span>                   <span class="hljs-number">0000H</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">1406H</span>      <span class="hljs-number">6226H</span>                   <span class="hljs-number">0000H</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">2000H</span>      <span class="hljs-number">6226H</span>                   <span class="hljs-number">2000H</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">bx</span>         <span class="hljs-number">8226H</span>                   <span class="hljs-number">2000H</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-built_in">ax</span>         <span class="hljs-number">8226H</span>                   <span class="hljs-number">8226H</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">bx</span>           ?                     <span class="hljs-number">8226H</span>注意:后面的H字母表示十六进制数（Hex）计算：<span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">1406H</span><span class="hljs-comment">;也就是16进制4E20+1406=6226，直接用计算器</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">bx</span><span class="hljs-comment">;也就是16进制ax=6226+2000=8626</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">bx</span><span class="hljs-comment">;也就是ax=8226+8226=1 044C</span>注意：这里最后？计算出来的结果为1044C，但是由于<span class="hljs-built_in">AX</span>是<span class="hljs-number">16</span>位寄存器，所以最前面的<span class="hljs-number">1</span>溢出了，得到的？值为044C</code></pre></div><h1 id="8086-cpu寻址能力"><a class="markdownIt-Anchor" href="#8086-cpu寻址能力"></a> 8086 CPU寻址能力</h1><p>8086有20根总线，可以传送20位地址，每个地址都可以存放0或1，寻址能力即<code>2^20=1048576 bit</code>，即寻址能力为1M，cpu和内存之间通过20条地址总线相连接，可以传送20位地址，寻址能力达到1MB。但是16寄存器寻址能力是2的16次方，也就是65536bit，只有64KB，这显然是不合适的</p><p>那么内部寄存器为16位，那么如何来寻找20位地址？？采用地址合成（两个16位进行地址合成得到20位）</p><img src="/2022/08/20/22-0820-01/image-20220829104830861.png" class="" title="image-20220829104830861"><p>例如，1230和00C8进行合成，步骤如下：</p><img src="/2022/08/20/22-0820-01/image-20220829104840678.png" class="" title="image-20220829104840678"><p>寻址123c8H的内存单元  地址加法器采用段地址 x 16 + 偏移地址的方法合成<code>物理地址</code>，其实就是用一个基础地址加上一个偏移地址</p><p>注意：</p><ul><li>这里的段地址×16，段地址是1230，这是十六进制，但是16是十进制，所以我们把1230转为十进制，也就是4656，然后再用4656×16=74496，而76696转为十六进制就是12300</li><li>或者这样想也行，段地址*16相当于这个 “16进制数” 左移1位，后面补个0，1230就变成了12300</li></ul><h2 id="段地址和偏移地址的理解"><a class="markdownIt-Anchor" href="#段地址和偏移地址的理解"></a> 段地址和偏移地址的理解</h2><blockquote><p>转载：<a href="https://blog.csdn.net/qq_18360881/article/details/107225697">https://blog.csdn.net/qq_18360881/article/details/107225697</a></p></blockquote><p>如果让你去一个地方，这个地方叫野猪窝（哈哈，这是个地名），那你知道怎么走吗？如果你不知道地址，你是不是会把中国遍历一下。也挺好，你可能会找到若干个野猪窝。如果我告诉你，这个地方在陕西省西安市蓝田县汤峪镇。你是不是很快就能找到目标?</p><p>先别急，让我们一步一步来，假设你的定位范围是整个地球，首先我告诉你在中国，那么你就可以过滤掉美国，日本，英国等一系列国家，从而在我们中国内部进行检索。这时我又告诉你在陕西省，那么你离目标是不是又近了一步？然后是西安市、蓝田县······一步一步的，你就找到了这个地方。</p><p>在上面的介绍中，中国可以认为是一级段地址，通过他可以过滤掉一系列其他国家，进行下一级行政单位（省份）的确定，陕西省是中国的偏移地址，进入中国范围后，可以通过陕西省过滤掉我国的其他省份，同样陕西省也是他下一级行政单位（西安市）的段地址，依次递推。这是不是就明了许多了？</p><p>我们将这个概念再带回计算机上，假设你现在有1024字节的内存，你将他们分为四个段，每个段有256个字节。把这四个段分别编号为A，B，C，D。当你想要唯一的定位一个字节时，你应当先找到他所在的段地址，然后就可以排除其他三个段地址了。这样你的检索范围就会大大缩小。比如说你要检索的数据在C段，那你就可以只检索C段内的256个字节，如果再告诉你偏移地址，比如说是第123个字节，那么就很容易定位了。</p><h2 id="物理地址段地址16偏移地址的含义"><a class="markdownIt-Anchor" href="#物理地址段地址16偏移地址的含义"></a> 物理地址=段地址*16+偏移地址的含义</h2><blockquote><p>转载：<a href="https://zhuanlan.zhihu.com/p/443067188">https://zhuanlan.zhihu.com/p/443067188</a></p></blockquote><p>“段地址 x 16 + 偏移地址 = 物理地址” 的本质含义是：CPU在访问内存时，用<strong>基础地址</strong>（段地址 x 16）和基于基础地址的<strong>偏移地址</strong>相加，给出内存单元的物理地址。</p><p>比如：</p><img src="/2022/08/20/22-0820-01/image-20220830093931526.png" class="" title="image-20220830093931526"><p>此时 你从家出发前往图书馆，你询问我如何前往，我可以告诉你两种方式：</p><ol><li>从家出发，走2326m到达图书馆。这2326m就可以看作图书馆的物理地址。</li><li>从家出发，走2000m到达饭馆，吃个饭在走326m到达图书馆。这里的2000m可以看作相对于家的基础地址，第二个326m相对于基础地址的偏移地址（以基础地址为起点的地址）</li></ol><ul><li>第一种方法直接给出物理地址。</li><li>第二种方法是用基础地址和偏移地址相加得到物理地址。（进一步展现了物理地址=段地址*16+偏移地址）</li></ul><p>此时我们为以上描述增加一些限制条件，比如，只能通过纸条来传递信息</p><p>你问我去图书馆怎么走，显然我需要一个可以容纳4位数据的纸条，才能写下2326这个数据。</p><img src="/2022/08/20/22-0820-01/image-20220830094506657.png" class="" title="image-20220830094506657"><p>可是不巧的是， 我没有能容纳4位数据的纸条，仅有两张可以容纳3位数据的纸条。那么我只能以这种方式告诉你</p><img src="/2022/08/20/22-0820-01/image-20220830094948537.png" class="" title="image-20220830094948537"><p>在第一张纸上写上 232（段地址），在第二张纸上写上006（偏移地址）。假设我们事先对这种情况有过约定：<br />你得到两张纸后做这样的运算：232（段地址）×10+006（偏移地址）=2326（物理地址）</p><h2 id="段的最大长度"><a class="markdownIt-Anchor" href="#段的最大长度"></a> 段的最大长度</h2><p>一个段中每个内存单元的地址表示为 段地址:偏移地址</p><p>其中，段的长度是偏移地址可以取的数值规定的，在8086cpu中，偏移地址使用一个16位的二进制数表示，其表示范围是（0000H:0FFFFH），总共有2^16(2的16次方)=64K个不同的取值，一个内存单元使用1个偏移地址，故一个段的大小是64K</p><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">作业:</span>1.给定段地址为0001H，仅通过变化偏移地址寻址，CPU的寻址范围为____0010H___到___1000F_____。2.有一段数据存放在内存20000H的单元中，现给定段地址为SA，若想用偏移地址去寻址到这个单元，则SA满足的条件是：最小为___1001_____，最大为______2000H_______<span class="hljs-section">解析:</span>1. 由于CPU的范围是“段地址×16”+偏移寻址，由于偏移寻址是16位，那么最大就是FFFF，最小就是0啦，所以最小范围就是0001H×16，最大就是0001H×16后再加FFFF2. 这里和第1题恰好反过来了，这里知道物理地址是20000H，所以先减去FFFF得到1 0001，再把10001转为十进制再÷16得到4096，再把4096转为十六进制就是1000H，但是1000H如果是段地址，那么进一位（×16），也就是10000H，但是应该是1001H才行，所以前面的段地址最小应该是1001H最大为2000H</code></pre></div><h2 id="8086-cpu读取指令过程"><a class="markdownIt-Anchor" href="#8086-cpu读取指令过程"></a> 8086 CPU读取指令过程</h2><p>段地址实际就是由段寄存器提供，8086 CPU有4个段寄存器：CS 、DS、SS 、ES</p><p>其中CS和IP它们指示了CPU当前要读取的地址，CS叫代码段寄存器，IP为指令指针寄存器，比如：在<code>任意时刻</code>，8086 CPU将从CS中的内容×16+IP的内容单元处开始读取一条指令（可以将CS理解为段地址、IP理解为偏移地址）</p><p>如下图：B8、23、01这些都是机器码，后面的20000、20001、20002这些是内存地址，后面是B8、23、01机器码对应的汇编指令（注意：<code>每个内存地址对应一个存储单元，每个存储单元大小为1字节</code>，恰好这里B8、23、01这些十六进制都是1个字节）</p><img src="/2022/08/20/22-0820-01/image-20220830100304478.png" class="" title="image-20220830100304478"><p>8086 PC读取和执行指令的相关部件以及过程如下：</p><p>步骤一：</p><img src="/2022/08/20/22-0820-01/image-20220830100330281.png" class="" title="image-20220830100330281"><p>步骤二：</p><img src="/2022/08/20/22-0820-01/image-20220830100750071.png" class="" title="image-20220830100750071"><p>步骤三：</p><img src="/2022/08/20/22-0820-01/image-20220830100801500.png" class="" title="image-20220830100801500"><p>步骤四：</p><img src="/2022/08/20/22-0820-01/image-20220830100809487.png" class="" title="image-20220830100809487"><p>步骤五：</p><img src="/2022/08/20/22-0820-01/image-20220830100826437.png" class="" title="image-20220830100826437"><p>步骤六：</p><img src="/2022/08/20/22-0820-01/image-20220830100835114.png" class="" title="image-20220830100835114"><p>步骤七：</p><img src="/2022/08/20/22-0820-01/image-20220830100846225.png" class="" title="image-20220830100846225"><p>步骤八：</p><img src="/2022/08/20/22-0820-01/image-20220830100854359.png" class="" title="image-20220830100854359"><p>步骤九：</p><img src="/2022/08/20/22-0820-01/image-20220830101101510.png" class="" title="image-20220830101101510"><p>步骤十：</p><img src="/2022/08/20/22-0820-01/image-20220830101110907.png" class="" title="image-20220830101110907"><p>步骤十一：</p><img src="/2022/08/20/22-0820-01/image-20220830101121777.png" class="" title="image-20220830101121777"><p>步骤十二：</p><img src="/2022/08/20/22-0820-01/image-20220830101129951.png" class="" title="image-20220830101129951"><p>步骤十三：</p><img src="/2022/08/20/22-0820-01/image-20220830101136970.png" class="" title="image-20220830101136970"><p>步骤十四：</p><img src="/2022/08/20/22-0820-01/image-20220830101145687.png" class="" title="image-20220830101145687"><p>步骤十五：</p><img src="/2022/08/20/22-0820-01/image-20220830101154735.png" class="" title="image-20220830101154735"><p>步骤十六：</p><img src="/2022/08/20/22-0820-01/image-20220830101201719.png" class="" title="image-20220830101201719"><p>经过上面的步骤，可总结CPU执行指令的步骤如下：</p><ol><li>从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器</li><li>IP = IP+读取的指令的长度，指向下一条指令</li><li>执行指令，执行完成转到步骤1，重复这个过程</li></ol><h2 id="如何修改csip的值"><a class="markdownIt-Anchor" href="#如何修改csip的值"></a> 如何修改CS:IP的值</h2><p>8086 CPU加电启动或复位后，CS和IP的值被设置为CS=FFFFH、IP=0000H，开机后执行的第一条指令的内存地址就是 CS=FFFFH、IP=0000H</p><p>如何要同时修改CS:IP的值，那么可以通过jmp（跳转）指令来实现，比如：<code>jmp 0fffh:0100h</code>，把CS修改为0fffh，IP改为0100h</p><p>如果仅仅修改IP的值，jmp 某个寄存器，比如：<code>mov ax,0fffh,jmp ax</code>，可以将这个分开理解，<code>mov ax,0fffh</code>就是ax=0fffh，后面的<code>jmp ax</code>可以理解为<code>mov ip,ax</code>，也就是ip=ax=0fffh，这样ip就成了0fffh，为啥修改ip的值要这么麻烦呢？？？因为语法就这么规定的。。。</p><div class="code-wrapper"><pre><code class="hljs txt">作业：mov ax,bxsub ax,axjmp ax这3条指令执行后，CPU几次修改IP？都是在什么时候？，最后IP的值是多少？解答：注意：sub是减法指令mov ax,bx  读取到指令缓冲器mov ax,bx 修改自己ip+2  执行sub ax,ax  读取sub ax，bx 修改ip+2   执行jmp ax     读取jmp ax ，修改ip+2  执行注意：jmp ax，这里由于sub ax，ax后，ax为0，也就是jmp 0，所以还会修改ip，ip还会修改1次所以ip一共修改了4次</code></pre></div><h1 id="debug调试方法"><a class="markdownIt-Anchor" href="#debug调试方法"></a> Debug调试方法</h1><blockquote><p>注意：这里要在windows 2003中使用，win10版本太高，无法直接使用</p></blockquote><p>cmd下直接输入debug即可</p><img src="/2022/08/20/22-0820-01/image-20220830104037882.png" class="" title="image-20220830104037882"><p>-r 查看和改变寄存器内容</p><img src="/2022/08/20/22-0820-01/image-20220830104056968.png" class="" title="image-20220830104056968"><p>-d 以数据方式显示寄存器的内容</p><img src="/2022/08/20/22-0820-01/image-20220830104104567.png" class="" title="image-20220830104104567"><p>-u 以汇编指令的方式显示寄存器的内容</p><img src="/2022/08/20/22-0820-01/image-20220830104509769.png" class="" title="image-20220830104509769"><p>-t 执行一条机器指令</p><img src="/2022/08/20/22-0820-01/image-20220830104519704.png" class="" title="image-20220830104519704"><p>-a 用汇编形式写入指令，这里是向0AEF:100这个地址写入mov ax,100（两次回车退出）</p><img src="/2022/08/20/22-0820-01/image-20220830104528150.png" class="" title="image-20220830104528150"><p>然后-r查看寄存器的内容如下，AX的值是0，我们现在是想把ax值变成100，如果后面执行-t的话，下图中绿色划线的指令mov [96C7],AL，我们只需要让其-t执行mov ax,100即可把ax的值由0变成100</p><img src="/2022/08/20/22-0820-01/image-20220830105122544.png" class="" title="image-20220830105122544"><p>所以我们需要修改IP的值，把IP的值修改成100即可，这样段地址（CS）：偏移地址（IP） = 0AEF：0100，这个地址也就对应-a写入时的地址</p><p>通过-r ip修改ip的值，修改后，再次-r查看寄存器内容，指向的就是ax,100</p><img src="/2022/08/20/22-0820-01/image-20220830172405342.png" class="" title="image-20220830172405342"><p>然后-t执行后，ax的值就改成了100</p><img src="/2022/08/20/22-0820-01/image-20220830172414669.png" class="" title="image-20220830172414669"><p>-d 0aef:0170从0aef:0170开始查看数据</p><img src="/2022/08/20/22-0820-01/image-20220830172421247.png" class="" title="image-20220830172421247"><p>如果要查看0aef:0170到0aef:0177之间的数据，如下划红线的数据：</p><img src="/2022/08/20/22-0820-01/image-20220830172429001.png" class="" title="image-20220830172429001"><p>使用 -d 0aef:0170 0177</p><img src="/2022/08/20/22-0820-01/image-20220830172436745.png" class="" title="image-20220830172436745"><p>-e修改数据内容，比如：修改0aef:1000开始的数据，没修改前，数据46,EB,EB，修改成00,11,22</p><img src="/2022/08/20/22-0820-01/image-20220830172444557.png" class="" title="image-20220830172444557"><p>修改后如下：</p><img src="/2022/08/20/22-0820-01/image-20220830172451282.png" class="" title="image-20220830172451282"><p>也可以按字符串修改</p><img src="/2022/08/20/22-0820-01/image-20220830172459440.png" class="" title="image-20220830172459440"><p>修改后如下：</p><img src="/2022/08/20/22-0820-01/image-20220830172505840.png" class="" title="image-20220830172505840"><p>也可以通过-a写入数据，比如通过-a向1000:0这个地方写入mov ax,bx，然后查看</p><img src="/2022/08/20/22-0820-01/image-20220830172512107.png" class="" title="image-20220830172512107"><p>通过-u查看更明显</p><img src="/2022/08/20/22-0820-01/image-20220830172518360.png" class="" title="image-20220830172518360"><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">作业:</span>查看内存中的内容，PC主板上的ROM上有一个生成日期，在内存FFF00-FFFFFH的某几个单元中，请找到这个生产日期并且试图改变他<span class="hljs-section">解析:</span>物理地址=段地址*10+偏移地址，这三个地址都是16位数字，数字后面的H可以写，也可以不写，都表示的是16位的数据；16表示的是十进制的，转换成16进制就是10。段地址占用4个字符，即：fff0，因为物理地址=fff00，所以偏移地址=0，计算过程即：fff00=fff0*10+0；同样的道理，物理地址fffff，段地址是fff00，便宜地址是ff所以，查看内存的指定物理地址的数据，就直接使用命令，d fff0:0 ff即可得到该内存中fff00-fffff的数据。</code></pre></div><img src="/2022/08/20/22-0820-01/image-20220830191832791.png" class="" title="image-20220830191832791">]]></content>
    
    
    <categories>
      
      <category>16位汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>转载：理解 分段 | 分页 机制</title>
    <link href="/2022/08/13/22-0813-02/"/>
    <url>/2022/08/13/22-0813-02/</url>
    
    <content type="html"><![CDATA[<h1 id="分段分页的产生"><a class="markdownIt-Anchor" href="#分段分页的产生"></a> 分段|分页的产生</h1><blockquote><p>转载自：<a href="https://blog.csdn.net/low5252/article/details/106068865/">https://blog.csdn.net/low5252/article/details/106068865/</a></p></blockquote><p>分段和分页都是为了利用和管理好计算机的资源—内存。在分段技术没有出现之前，程序运行是需要从内存中分配出足够多的连续的内存，然后把整个程序装载进去。举个例子，某个程序大小是10M，然后，就需要有连续的10M内存空间才能把这个程序装载到内存里面。如果无法找到连续的10M内存，就无法把这个程序装载进内存里面，程序也就无法得到运行。上面这种直接把整个程序装载进内存的方式是有一定的问题的。</p><ol><li><p>地址空间不隔离</p><p>举个例子，假设我有两个程序，一个是程序A，一个是程序B。程序A在内存中的地址假设是<code>0x00000000~0x00000099</code>，程序B在内存中的地址假设是<code>0x00000100~x00000199</code>。那么假设你在程序A中，本来想操作地址<code>0x00000050</code>，不小心手残操作了地址<code>0x00000150</code>，那么，不好的事情或许会发生。你影响了程序A也就罢了，你把程序B也搞了一顿。</p></li><li><p>程序运行时候的地址不确定</p><p>因为我们程序每次要运行的时候，都是需要装载到内存中的，假设你在程序中写死了要操作某个地址的内存，例如你要地址<code>0x00000010</code>。但是问题来了，你能够保证你操作的地址<code>0x00000010</code>真的就是你原来想操作的那个位置吗？很可能程序第一次装载进内存的位置是<code>0x00000000~0x00000099</code>，而程序第二次运行的时候，这个程序装载进内存的位置变成了<code>0x00000200~0x00000299</code>，而你操作的<code>0x00000010</code>地址压根就不是属于这个程序所占有的内存。</p></li><li><p>内存使用率低下</p><p>举个例子，假设你写了3个程序，其中程序A大小为10M，程序B为70M，程序C的大小为30M。你的计算机的内存总共有100M。这三个程序加起来有110M，显然这三个程序是无法同时存在于内存中的。并且最多只能够同时运行两个程序。<br />可能是这样的，程序A占有的内存空间是<code>0x00000000～0x00000009</code>，程序B占有的内存空间是<code>0x00000010～0x00000079</code>。假设这个时候程序C要运行该怎么做？可以把其中的一个程序换出到磁盘上，然后再把程序C装载到内存中。假设是把程序A换出，那么程序C还是无法装载进内存中，因为内存中空闲的连续区域有两块，一块是原来程序A占有的那10M，还有就是从<code>0x00000080～0x00000099</code>这20M，所以，30M的程序C无法装载进内存中。那么，唯一的办法就是把程序B换出，保留程序A，但是，此时会有60M的内存无法利用起来，很浪费对吧。</p></li></ol><p>为了解决上面的问题就引入了分段和分页技术</p><h1 id="分段的理解"><a class="markdownIt-Anchor" href="#分段的理解"></a> 分段的理解</h1><p>为了实现分段技术，需要引入虚拟地址空间的概念。那么什么是地址空间呢？简单的说就是可以寻址的一片空间。如果这个空间是虚拟的，我们就叫做虚拟地址空间；如果这个空间是真实存在的，我们就叫做物理地址空间。<strong>虚拟地址空间是可以任意的大的，因为是虚拟的。而物理地址空间是真实存在的，所以是有限的</strong>。</p><p>分段这个技术做了一件什么事情呢？它把虚拟地址空间映射到了物理地址空间（<strong>未开启分页情况下，从虚拟机地址空间到物理地址空间的转换是段基地址+段内偏移地址</strong>），并且你写的程序操作的是虚拟地址。假设，程序A的虚拟地址空间是<code>0x00000100～0x00000200</code>。此时，不仅需要一块连续的物理内存来存放程序A，还需要把程序A的虚拟地址空间映射到（转换为）物理地址空间。可能，程序A的虚拟地址空间从<code>0x00000100～0x00000200</code>映射到了物理地址空间<code>0x00000000～0x00000100</code>。</p><p>分段技术可以解决上面1、2两个问题。</p><p>在问题1中，假设程序A的虚拟地址空间是<code>0x00000000~0x00000099</code>，映射到的物理地址空间是<code>0x00000600~0x00000699</code>，程序B的虚拟地址空间是<code>0x00000100~0x00000199</code>，映射到的物理地址空间是<code>0x00000300~0x00000399</code>。假设你还是手残，在程序A中操作了地址<code>0x00000150</code>，但是英文此时的地址<code>0x00000150</code>是虚拟的，而虚拟化的操作是在操作系统的掌控中的，所以，操作系统有能力判断，这个虚拟地址<code>0x00000150</code>是有问题的，然后阻止后续的操作。所以，体现出了隔离性。（另一种体现隔离性的方式就是，操作同一个虚拟地址，实际上可能操作的是不同的物理地址）（<strong>注意，实际上，很可能程序A和程序B的虚拟地址都是<code>0x00000000~0x00000099</code>。这里的举例只是为了方便理解。</strong>）</p><p>问题2也很好的解决了。正是因为这种映射，使得程序无需关注物理地址是多少，只要虚拟地址没有改变，那么，程序就不会操作地址不当。</p><h1 id="分页的理解"><a class="markdownIt-Anchor" href="#分页的理解"></a> 分页的理解</h1><p>但是问题3仍然没有解决。因为第三个问题是换入换出的问题，这个问题的关键是能不能在换出一个完整的程序之后，把另一个完整的程序换进来。而这种分段机制，映射的是一片连续的物理内存，所以问题3得不到解决。</p><p>而问题出在哪呢？就是<strong>完整和连续。</strong></p><p>而分页技术的出现就是为了解决这个问题的。分页这个技术仍然是一种虚拟地址空间到物理地址空间映射的机制。但是，粒度更加的小了。单位不是整个程序，而是某个“页”，一段虚拟地址空间组成的某一页映射到一段物理地址空间组成的某一页。（如何理解这个“页”的概念，这个问题见下面）</p><p>分页这个技术，它的虚拟地址空间仍然是连续的，但是，每一页映射后的物理地址就不一定是连续的了。正是因为有了分页的概念，程序的换入换出就可以以页为单位了。那么，为什么就可以只换出某一页呢？实际上，不是为什么可以换出某一页，而是可以换出CPU还用不到的那些程序代码、数据。但是，把这些都换出到磁盘，万一下次CPU就要使用这些代码和数据怎么办？又得把这些代码、数据装载进内存。性能有影响对吧。所以，我们把换入换出的单位变小，变成了“页”。（实际上，这利用了空间局部性），问题3是不是就解决了呢？<br />所以，分段和分页的区别在于：<strong>粒度</strong>。</p><h1 id="分段和分页的概述"><a class="markdownIt-Anchor" href="#分段和分页的概述"></a> 分段和分页的概述</h1><p>分段就是将一个程序分成代码段，数据段，堆栈段什么的，如下：</p><img src="/2022/08/13/22-0813-02/image-20220821104720506.png" class="" title="image-20220821104720506"><p>分页就是将这些段，例如代码段分成均匀的小块，然后这些给这些小块编号，然后就可以放到内存中去，由于编号了的，所以也不怕顺序乱，如下：</p><img src="/2022/08/13/22-0813-02/image-20220821105207174.png" class="" title="image-20220821105207174"><p>然后我们就能通过段号，页号，页内偏移找到程序的地址，如下：</p><img src="/2022/08/13/22-0813-02/image-20220821105323219.png" class="" title="image-20220821105323219">]]></content>
    
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo入门+Fluid主题美化|汉化</title>
    <link href="/2022/08/03/22-0803-01/"/>
    <url>/2022/08/03/22-0803-01/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="5001fcd208dad6f2b6840c1f1d8605761a1a257c57748df8bc3adb4240998722">bb37e7fa29ac998f9193b7733de58c59ffc2b770bd4b3ca6766c4a815de0249883f92792439ac57210abede1f2ef6caa040406f67f17ef6c27509103db6f265e866169ea347167b9e1e75f0efecf3e14405bdd736ac18f5705ffec9464444edbe5a8d888cb1da2404244f887508db1c4d55c2d162efa6678465716aa8ae5ae8219dc29b59e118e5b8f4c00b74afcaed09f8607fcd1b4f66297f4d130ceee2f88a08f9ee965c97baf26c6f54682c69844de46e216e458ad8aa50a643c1c6f4311b93517ace7797cb5806d81d7ed284963f0561222215cfce9c050b7b4c8984835120147a9e836f3b4961cb4307b7bd7c1566188d9c9acb60b74948ca829f02dc57a69516f00f7a662882e00b0838a72f94362dcf7ff7d5c2cdbb73fa0ca07d9aef1451a6122bb1a82f11e07d8f5994aa02ac6a4f1bea67ce6e3d2689b3ae41210f14dad939a4fc1e05f6574376d8f5fdd9e5d367322f102e22b13ff915473366f39cb4a9f845474ccefd66cbaa4d38e87bff82c0f3e803d905fd3a22c5723338378b373cb227a643a0fe184be48e83ceb0a0781a575da60df2747cd66f5cac516691c06698738f02c97c281c2d8db05e9dd63c98443dc43146b7c631e3cb3dddb03ed09e28bbe98d15cac6de46fd1f1acbfa8969d37c6af4379e484473433433cfc94616cf2ab59553a623d6107d66927670dd555b2c5ca31baa98ab4ecd157b3260ec141b70d6af874b43980d236b4551814b1ed9655e27ec8fde807008fef773f08772e10539fabddc963a4d36424947ecfc622d3f8e40e1ee7faa6f251ce0ece13046dfb668bff7974dcb78f476ed3e3529e795ad4706071616ce77dc748adb2214c829d06ae7b7636261e7049354f7f2f9bc11d709b3bc5a4e792683cf91633a6b1b19a90b2543546458f31089f95a4200862b3b5fe1526a0e89b742c91a1291252363ec1b4843711063cee3d5e25a95b7c9e4e7e41f56563122a5d9feaeb97154750a4866843ea0b95a7ebadb55077fd9327f138d0bb6c13f4d7617b327320b4fbd2ca9aca49202b333f8f254e7f0f8c032ca25039150e4e673084e06482459fc949296ce77b4706a0399ce6e9ee94487be66ff0cf3efc038adce38ed9ce15812e3c3f69fea5da914f56c962d19bd46260011f6ac4fb1f8a0c06e70c82451d5a55c1fb181253919044efe359ae0a66bf1a7d3439c78ef8a4cfdc28a249d7ae0b025b087dcaa8fcbe1a1838777062ae8734f0d0cc2bad13ffed98982f86205b83ea307baeccce73ccf2554384bf6b97b6fd623f9c83da43e2bfa90ee36fb2e1b7fc3652988c895c6586213866d946640aecf41fdc85bdefb9952ef910b052c6f47fd8514272e8406ed59f342151057fb61bf47c21e996e199b36c93716f80c90a3473330ec154e0de2679df326790c4dd1ce69e2a6d309e688cdbcedebe185050b7dc9d0e0e00c6373aaa009cd1eafd0f2fdbc86d3d93b957e7b97fa3560e10cb405ea0686c64d0fc60443fb07a97472e66aef15e54301032c44d781c66ac6fbe437cf09d91d8f24a93a058d7be988dadf78c13f7f855b81d78c225b580fd644bad9f6cd81919df997b41fed46a43fcb58501679317bc9c7949048b2c37787f535405a2082fb9f13ab9bd87393048fda10b8bcd49834455144294fef1794497984376c3a0956de6f17ee1e7ec17f54bd7a2e3e9edf413aa8972eb96a7e66dc99255718fe45a3d60e5fe65b41338929c3aabccee0cf7a57d3c7f60445a5e58e597397a38d11e6c4ac365a7978247c1fd6e1e365838f38552cbb65fdcdd34e77b4e0bf9fc637ceacbc74198381b8dd60f869a1e2343e061e5342f9344f38138da39445076671482f3284cfc750327ceea74a34ae9e8ab3a350573bb2b7e07d809c326da1f358d33b910cdd5113e802c7c6ddb7a9aaa97cc63dd21609c57813cc8a5f5c03e4b99312baaf9b7e0c95da44afb427b113aabcd888dc853788a038bc1b450a587cbe96296faee4ec7722602f35964f1ff374ac452786a413d91509bf63554bf6479e9bba2e26d2f92e7ccc84af819e88a6c2ba9e704bcd5b0207d015d6b6c155558b0e651e52f3039452dbc0d752fa0d7da64030fafb20ab8931ee028c9eaf608355115d709d9506a8c91f27607fb826a64c19504a0f4deab08d04d41b64666b35ffb45e5e2bdb8f3dc2c230ebfb64e9d886e7a019edd53f7ba23b2432cf6cf19b202830fb584cdf6a30da17bc169329c5be98f949aaae913902f77711d50569665b3c3478ac616e6dfdb4ab9e84aef5d87f957392488ade7643d521ccbfbdf076c298036aeee25b99858cf671fbd30aa95f91f6d3f6eb138ffd66af0aa9188e40269a992cfe0d909899af0dc02d1c0db75ccd3aa08626c498054e28adc78802ed561071dd3eb357a1f060912d1eca4a8c68f8f151dd5c7f081ff019dd6150fac66bcf842db207db9307d53b248f46644770b4bc991493b7bdc294d316adb6d355a29be14055f171aedc44894ce1fd027fef54ae890b43e8bf5bdec8b98b179491a259055a9f6053708dd3ea4039b0fb12358da2cc3d9c7886256043ea9b6dcf0923aa424d2d19ee1176da397676a628f3b4cca78e2a3d0c61f73e647f878b628b79f15649ed575b304adc64376792b414b27c7cb2deb783ba852df69bb149b9287dfebb0cebd7686d6fa92cf86f40e48dea98eaef128c5b969229b0e71efaeb3f9102387e2146fd89d182d093b570b456dbc24c2e64dd9b2fe8e879bba747cd3f6c7937aa46951932a486bbcaa588c98be3941bcda0883acf3530026b85b28cb8780e5c7727498b09926514c72517e61f90576acad153a97309547c718282860c47151101a58ecc7c1cd77e40d58ecf698753afad80c39bdfdecc7d310e7fc08dc5a045d5f0fd5ed075404464f513a7d299fb6b90ed124fd9a0a8b3dda851aba09cbf50db828906eb42c4d09d3b47938e0e4ff1ca48d7c32293daabfd5532f41a292cf2bac8d0ceb9864a09ea7fb749223a4faa9babec456472c69f1ed1213d927fd05732700e526235537d1feafe6898b3dc186d5af2651a581099b637f79a044e06ce771f134e9b84702880fc3e871d026e9c5048fb1921c3094fa684ff7de1ec7b6d58ac3917b587b21ca4dd7051dadfb7700236dc9d9dea66cca55a590e01e2579d2565e1d9f04abce3031b830903a3ecc710031baee303bd4c6c9ee17efc24131b0bd4e659be39e8fd0f347693a2a6f1272d501dd1a60f5bd70031f638eed8f6238f8fbce20083dcbb552a9ee2e2a8e486e1cc804ed1169a8e225f83e1822e4be75f744f1135ec381faab81d9f3352d715ecaf1f2faeccd03ea54208101a126392309ca7af8bf94669732eaaf17970960b64e0810812e8c765806b9ccf1dd7b684e17d3f1fa8bba35224ad10196ce3acaa3cfe914e637cff4fc0f776401166e0830ff81325c4d5491666f6df5c4804a64bce3c56e975e2cc1af7f43ef52e99f86688c4f53ed0c57d37c43c6df2272b7e57890702b12093e848174ab88ac40a5847647219165ce35b5162d9d22bbb5fbbd3bed477234c8c2f55378fb2ffccc61cabae9ae1c485100982c245b2756545726e55dcceb8d6138c42fa3adeee3309cef5238bc78ae0af9e039ad4826838a9368dbdce1bb24feaba42ec5c1fc3a5da5f0395b8faad16cd38323851bb1e2ee09e9861eda2cdbbc273394cc202ec3e92876e90e519515ce66c355edb8f6e0652a44dbdd32a632c74751719c55e41fb4a1f49135666d0df6cf92b07c9e05b5a04e643957ddd4d3d02163aeea4615ed95182eef91369edb3c1e2c7dc6c69e113ff498ef39abc7f92950cc89ba0193331489181e606a48dd2b1108a7f7be86e9fb9f2c728332f0b66df390c3c86e01b965b88c78e63c5bc3d76edd282295a026b1344960b5db22c26f60d12b6feeff78630075fa35f567173dee27d0828572422f773cb89d7681da5d8beb978b06f7e9a810d10c5c4419bff36d024efe4d81a6ee338e2b88d067853ade6ce766acc9289384b1664722a38e1f86596e8c1f2af0367a4f1bda4b4471ce3b92cbd0170dbef41840eafb31311232913ffba9b160b54028f0d7352412adfc3128d58958d6127aba9c59a636539a49d42b31d1e6013a0e101c41e15e58c6dbfd0d3ac51fc546145a27fd96021da5eaf73c0afc5f31b19d10f2c5c319372baa6d05a33cf5d07e7ceb1beb2c7f47db169aadd46987e4413312624eac88e051d8c1b35be8727fd651982b8532263da3ad03df5c5547196c1452fcd65d0347c8f54801398dbcd4d7144b4e46a7fbbb53342e662561d32895c26ceeecdd4eda7f9b9858101409121fd346f0849fb097240e8bc8419080a89f96bdfbb99793fae1b5f653e96594930bf51165f00aded720122dbe163a1c048382e11dbad6d50c8a0bd11eb59caacfc653964dc164f825b52b35f7dd97334ed978b8add812d50c24da79549cd8907a6187a9ed4e749b5632a897d289b1ebbcbf03bdcd78810e8cd2f062f8972659cd93d1643eddb1aec73720a64c7ff0dc64e079fb82a8f885631eeb0a1f289d1f1c869df47741ad2efb80d4588860430bd77fb72ba3282c530bcd6fce907224f011367aa2086d154f741cf2c44dcad67f0b94af21502cafb50b4bb161d4c953817986c9f76e81060875d5549023bdb1fec6d979e75471b0bc1820553ad4adb792dea5ce25059975f14b7349b9eec177f0f1fcad103fcc55e005b131e4981f84af04deb26eaf83bbc5c8c29986e58cb4b9a2d229e7e42c5f8886ec5865ac5f8c817370c71d1aed619aa11b0c8dc402e1b0e9f9db90502f392288480ddc0b73be44f2e284f8582edecde5bf0bb53b4388be72205bf3f52a2d42e8c5801675505b9420bdbf0e2f3761d49d264e4ce4f9a8fb3fef457f512f4c3a933e4143c549bbdcd7199753cf172c0802eeccf4eebcef9fd92b4d91ce389a5454be67f14add946054e0263d2e7859efe66dbadebae2c44e7874d07ab5eebebe4d3bb07508eab5f2bd59d04faba8b373f6b27f633c9e2a2ab629adb8571cdb3cfebbdb2f36c38281bfb16faeb9ac70b889574218d61b64697daf56c77c5d5f9524bf8429852cdb9d642467c52d2be4407ac39560f7659b5cdeae307f3b5399dbaad64b817e05a00931afcee0e3d779749c902d0854b2afe74afadac193e44662e459de21d789c00920f450dcefe15717314719242dbc3c1a6f9b743972de5fa1657e19f03f8650aa42da5f9cceb7e46d36a31f8698ad6ed8c0bdfabe1c32629e698c65a5d0845b2f6c273d07dea0132de7e11c4aa4aca2e90fddfd34f6695b6fe854f12839bbd64bdb8ffdd364e42366d544dca38b4528dac9cc76cdba5625d9d836040a5d8fd7fb5f0d45a4232a3176962bc1466fc50166a6e9329602c8e8a4bba910e45677eb241fd5163c56a5e576fb60fbe32646ba0eae6c63e40b9fb81f0cc06faa10affed4e8ebc3c56bdf26848fb7cdc13baf4cf056924f174d87b6e0f53164f9448a49a6921be058e10d8d17aa8d9bddec168b5cae3714a5ec27895cd286df3f1ee8571b1d31f0970b81d052bd1c4af7f08629d13bcbc3111ee39bf8fcd5c73232a953630cc7ee39bd3ecd12c96049a77e8e5ecea77562ed915d90ce5ad11ec077a9086ad58fa02445785048bfd6f5591c0d6f13ef87fde1fd1dd074df0ebdebc839fece7410eacae7c85a0582a719078611981eafe558b5de4dc18eb86e6d35d9db8c30a5c52745c783883de4ad1c372f7eb48f407d6c899ff65ce57a3220401dac0949c227d8611a42dd6a38a55954ba7ae41e6550b39f2694c534315123ae72b883f7b5e3054c02f5421ea17c992e3e99afb8067483362cfef045a21cdeee0897b763b62b0b9de1316c12b65335c227895830aa035571ab08bfe949b62ad561a16faf8b1a6b1acca019e1250801b7aedb0b91f96e9e2f2f4bae85c0645487f879f57d6c664820164bc0e318a04a81de6ea945fb8aceb0b25aa12a501ccb47450cc78bbd87ce2d1133ae65a5066677ce74eb3caf0498453cc491be4579e0b6474dde127632c0118028ca857aa6eae20bdf7aba181f2ca5e0ca6e725c5cf76c11ac2cb3f544f9740628f830ac86fe78831bda726d5a63bf4c3c473306a1bd28a6f7c8c542ee91d6c9e497f1263709fbc046e5004cd381e5538d9d3741ffc5ce8aadc9e3ccafd1b0bc23961ee148039e8c05fd05e0d1ae91e2ee8ba845ca753696fb4200acf2a1c23ec36a23b9e36d38aa46a2fe7f744263aeb32c354897f51e9233830ad790343860e51e525ee834191773a0f205136c78e5d77910f52aafb6f4334d3340614d15a8559d5ff8993a45e7a9359f25f478d0ab2decbf3c844bf3cfa10636ec82829467b0180e8841ada0b78177c285c3814d1c556a7a0be1f22137d0d31673113c3268e85639f8d3ad481addd566eb77779483e02d721a684f9722da08cb0fc420c35a356f1acb8132e0118dcfe7de6102d7c7bee95e3fd0fa79cf53aac5ad28d0549ba950b2d73eb842206b04eb39fc16dc0afd93241e3cf3a9dbe776d665595154facba1510e3d7f42e3ea245342f39586cef019bb59f545ca16568784bee87c3490f6b258496c0c18b2fd3d21ecd223f600a490ab19f6c893a8c3ab9a40c6bc8d88e70849f34f2a7990d5bdeabaec5b35a3f6596a96efd82f63bc587053e467235f1d5651995bf301b2f43712e9ec3d285e46aac5e362fb7e2ae17bdf804cc7b8edf81529c97910f28a29c77bce28fb4e02b2bedcd6f18e7229887cc50bcbeca5bd62b41ea1ef3ded0f3af63b2a1fb68056d61e70e7b34bcd23012cac9b04183f8e23716c1843631fe68ac5713fc08f4caf522e9ce901a05229f2d5d8bed5378ee4d6edf991576f9a40a55274c21f152531284973f2426db9346833caa82a94f2f1fa802e965efbd5a048ff6a1e315f921df2aba3a56724d0e3faa1103340bb9ffe0791d0cffdcda2353a0ba632356f186d396374ac64407f405d1a1d256e0221f0299531f733dc5f20e81413259ddad7c39d48d24d984193c3dc0438b418cc24726f779a6ac100ef98cf6a583c1779801e689a67bae8f1b084bf3a8409deb1d02715995931866effa46098aca6f4ea883016cbdbe5cf6b2deb876e48e44c4e0d73b82858fb24101c05ec81f112c76363aeeb5882b8c43db51f664ceb261bab788495b6cd9afe0b63844e8c9c112155ee9a7b03db1b79fdc2b1c00b067b7074f6502779aa92fffbdc5dc926df9cf2925e24503f34bb26d76dd5abe1a9fa4dd597a3d7848bba43ad43a093e4fa3c1a4b913976395b1575870ff5516ff0e6bcf225188e6ef03a036d94837b813bf9992691ec34283d94eb3cebfa971b682ef6321c458584ba09bbef0369653491bec37f295e78b259e352f7df5caa7050da890e4cc7f0f2ae678a1664d9f3247791b09998a930d611094a891533b8d02ea6a72b0df4cbcc448e135e88f3e218815a9198a79715363cdfb6185d29d062990cecc1f1ec33fe2e99f3201f004e4782de06558bef6818f5dd0fdeefff22fc5f20eff343680c8b58392e12b0081571325c7df99467e1e33518c22a8f5179d6424a385c72aaedf6eae3daa3f165d2478c5f81eb06331a93414a6e4547ab52a26f3385a690c05a134c8d0ab03e67651496c4b1af2f3953207f930fb61387615b39cee86fa4dfafa6ab4a2f008c1a37cb938ef0d43dcb8843ea75f9f0e2fd1c917a00a19a6d6429420d8967470848e1c9fc6ea8e79ba81e204dba674c78b1a5d8b9b6e103427a4ccf7a295bb7e2ac73ff3ce3028c1f267f0abb9d42b6ce1d976abcd859cfc350211bb9a991c2095982c53986d21db81c067080da7ef1411c14f195f5afd0f22094726123d89238b2d3c54d012f774ba027af22ed8bdf4443a311332bb83896b4a338f13e9461ffb53ed6299fd4b262bbd6f96562ee84bfa3b8a2db381d6684f21c14ca3f7a295f202668ffeea035f8438b648c3d1c7112b824f1770a10dc935d904fb61aec0d71dd7f2135f829a3770b071dda7b18c3b75953c619d0fd87fb2fa2e7ded36c3d443cc055cd572a9b8e619818a2447ea83cef542d67d1e7e340958a42ee0b90ea5152660bed6904b6822ce8c8005885bcb362addf1bfa4026f0942f238d2fb1a2bd243272c373e6944cc4712858c31291d55a4446ed050a87f935424ca05b3f755b774c16e7c5fbc1afd686499f9e3d8d248fb73e4ce17cd17724ded2aa93671bd77d7baed78ff75a4ff3f8a4280ad46ab31cafd713f89aca87d885b9ce0041c5483bdbc366a7ba57d3059b49173351edb96886f41dd94d7a1badfa8d0b991ce11754b63abbb59e049281e32c12ea853373b09a92f54e24b3069ef6bbef4ed60d11c54226b9e5df27878887c1881f6794ddb1db7714d32c1450e740ddaaa12fd964d39995c5bd44cb7ad1a111122f532c26f89713983716276648128dc03a3eb9a6d39b4bd2a55a5203495d3c6945a2836ed5b28eb48f69b2548290eb2b11e491e8c835e0deddae766acbabb208032580e4e3b2fa156365b57768a2fe1ac9128f9ff5fe92ae3c416e1796df0ba20f338076f41d1bed3398ac01462115483ef4a78fad751bf35dba265d5535ea2d68f7c9486755dddb393d4f4eaca15a7122f70fb8e179c20cfb9d5731ac97d6263b05530511ef230dda8f8d1a7904de6e45a399f9982a6b44e9b63c4d11909e7556aa4be7a1244e8823f7ab093bf1329a868d5cc2c67147bd06f4c0a1a24a47527109ee9df44a8a3152b83e7550fd270bbe99bb8cdad7fe23ae0b6a2366cb16f019916cd3b1184268a92f782efe1c0877ee57babc98c89ba9e14412245a72aeab8c6d6afb8ec0091e2b294a58352ccc2fa83dfbfdff854fa9d84045e6af156079d4fe7c598414354a5531f8c535bea9311b187c59fb069d9b6fa386832d7b4f5877a618b19906d94303ecb404d59095c2681cec5157e21d1e4863c286280149c3eb4eebc57e14fcb7504334f28e33b7903b68892e96374ff0c01ba60dedefbff304b5090180edcc0cc20282ada8ec3a6f40aa028d45343ee72c9767f9da615da1b50fa68c05f8bbc634ce4a0156763fbd187dcbfdae19adb725d414922299c42cd6313e0d44e63e65d954e538e9b4140c45a896f284af575e0867835626a859dc61f391aeab90e3664c050bb3f83c4777aa38b0c9a7c4468f66c33bbc2b01258ef7c2a2919bb8403c51e37b9bde5580a972844d3e2945627b16ac6a93a1938b96e907e4f3b17bb17c791de4e17b5a6711d72c4489fa25996188d6a4f403b83c9582dc0a6b0baeee9c400554a68c749a99ab10f21431b263b3f51a4efcd8d0f7743f3003c4c0a9a89db15f1f8304eefd132be726227472a220094f49ad2099a5da57fac1f12bf02d427aca796d8aae57491c0473447c4029a3d2a512c391998a701eef3ccfbab2090b1498f35dcdacba61a20a8ad107082f4bfff17d7f352b409c767589ca0e5910d5a504eb9aa34b0c57e4ac785b7f3951c350eaf782682c466452d8b2e25919057958c21c069591ee41252010965e29e5619bf7fe3fa634c05c3436e07033c6c6de5055d3ccc15a0c9c1c9abb542b79cff80f749af94bdba0c233de51726efa6fd7503e3a08c7c25fff85b4ed8cabd7c3eb1ee45dacbf0d98d89a5cefcb42212fe2d1dbe6da4e2ea1230aa9993307eed47b24f7c6232e158ec4d08f824220b8a1c0197820394ec7ab31ceefbec7c3701dbee1f23cad0645902b165d4ffde6646e6df28b1e323eebfb84d4267e5c3d31087b2bb68a81ed3ba8e298c9d066bc35b7ff51c1a56575510fc4ad2a4d14b5f463d291776b8aafac843fa0a385a7010a8433a5d3caed23e761479753bd6f82aa429dc8629b965be523e5051d9d1cd8b849ac57a436e421567c15a088c1ee92bad56bcfb2273954d0c68d2fb285ad7d0c8ad285c3cf954e9e99be4f9f35a06dd378c7edf0de407b54476d2a58509b799ea7240f38a79167367cd14913445c0e78d3e1b486edd2747cde2040798359def0bfa0464ea43f38b9db713a34b94e1c2c0ab51c5bad46a7e99ca4952430aff5f8050c8cdb06ac0a7bb85b34358ad16eb784864206e1e1cada1aa871eb7bd05c8eecc03d2bffec13bb8da94f22a91e9bcb3f8ec22d16ec7f9c5139f22325966e40944926917fba88bd18225f708ff73f1814c58ddabd67d76e6c7ab559e2ac94cd5a9be8c34062c69416ff5db165d49354e1b925af0c486d99134c4e815963a7f5ef63827adf00ab1a57a12db1015bf02fc95b5ab1944c119dfaa8de888b016888a5877dcc5149453f7a5a914eadd6deb2f765ca2545bf7cbd7e46aca817ec60a095dc945ad7c688dccf53cd8b548638221a5f6ed1717683a8b719c3163bac730ad9c3ca23727d557d3be010e96feb2c2698ec24e2bbd12fa79413d9219c28dc8325bae855a05b2ee81808fd426658551f87ea5ef3bcf89a24c4209d675e6fc9762cd9d27c7464778ee204b67cdae5f699070f338b310a5371a7c1e7406b4b3cd613e803ffcce366a77fbec9dab2f5af13ff4c090d2ffca0388a69027d92c7a79594ac4ab105bd3561daa986f0d86f90f30f2a0203cf6189fb0081fbfc86a103c362e1d5973984f7ed88f39414e0a19d1c78b6d9983b203c913418af51cfba4b85720639991dd78c5bfa3971a0e0f7e1add16f043f8a81034a743e536f9546590996be061ccac68565cbd71faf0b6a925621361581acac463fa8256892aad49b7948f55f1f982c118e0db03d264537f41d63c2b6e0e15962c788f8aba2b533d7e75269af18a736248972b69a58a98abea83441ef7bb70cffe639f9102e03456c9ba4d5b534e3c19255e00342f5a6e68a55c213a4ea3fe20f087466c644742a9edfe8cf1e5e11c666590378b0b5c65840555749db86ac7afb04659fd05403cf0c86f880f3d0cdcc366dc2dd320eff517f9aabb733452142c78f44975c77327ef7f6f841e54759cbab80a15cd5712a9a1ca2c263b5176ae589ea108d905e9f48937f560e4cd10a56855f02a03e971323aa636a4a4aea779d3d5fbfdb896797599b0ac74d2951e283530f19a59f010e8aec9fd96416eadf879b853d3935ca007806767242de9e701b7663c10b6ff3de421438061ba036a996631d70baf01268d4ce0a54d6d37c6e2033d3cac49f06e3904542987afa647b41b94baf6185572247a42b1ab19b82b39dfc5c66dc14b75481aebc6d958cd7ecf1aa36f17e91caaa21a5832bebc2e22f92edf6803d563a3704d2c71fedfcd0086ef80b51162393b2c8d8f6adae9a8846904e6dcf59ed72b170d4821932e2f1458ce69fbbabe9c5a11cf8eb5e2aba7a09b2cf518561a8256f1d3d01fa5fcfd536ccd53a60271a985b0977bdf3ab5d508e51a6f70e54cba7a7870be31462c10c894d08744848bedbc3ef123e334171661a4b98f9587163164b93327bc4f003a95bb8437f876cf1efbe67d19f74ccf4fa1c02cbb49caf4e6c9fcb937c7d98f26535ab570fca2c6d18301d9a7486b91f3f18d4daffd8fdfab996ad9a8101c85f4c03b40f84e24d06ac67567ff5ee44ea26940f84ab1beae43ac16314d29a889bc08723b8e5ad88d89010046f9b931c0f653110c0dda937dc09a429e8500629cac5a55cde50438db9269a706b0d6021eb9e16147173e90338b4a13522399fa67f90d40dea23192e1702154556d4de23ef7d5a5367dc3dbe8b9daad3615abe6fb8e44ae411577392dce7311dcafc8213c3f18f569f05d43c8e5a38a8ac65c373fa4e2ba693a6d9b1691d9003009e6578ae11e7779d0309019dca4f8f7989260d00efeaee4910bf264a0e1d941ebaca3f06e789ce20cd1d6eee163140bc59969e5bbb7cb80a1d3d3dab510add30c628a995c5631a24350f9fbae4427fc6b16d282fbcad2796b62e6b5533cc3b88ffc6dd447dfa668ea8042cca922e6a24a28da1f08f93259ab0b63b400f81d547d4eb4491dffabf37953cf7439a89ce734ff4377fb10948d47734dafd4f98e760933b48968da5ec0b6ac5b964fa4ef6c9ddd38bbbe13d0014666f8bef2cfe0e2e909b916a50e81827433f27479140c6e28d7607856ebc2e1bc232545a4fff88fe8811e28e1314bf09f15f6ee29fa24f5bde6994ef73eb0784b6fa3ce5786a4cc04c6ed4d499bf3f0e5001f8beb7edd14ce0cde82f636d90ce9d8f84da790614f979ee96b8e945b86318ee0ecd1afbc58c2d073d5ba04b1304b825c4eb2bc49c3df4a2b909264759a93aeebd0cd65950ca6a73c05568de9b9b2e0386829cdba1e77fac80c881d04c4fbb1ffb4d0f3c237840ed8a15494801c1a1e39d7012d30be1c11842e08e5adaceffe4080fde79643bff779bfce69ce40fe11765d9c0ea2b0336dd494934751bb7a551ee68e9f916b1a2d661e4f6b5eb6cc58b392ff820f3e7a34d27d27a256c3860a9d28c806bffda98c99e35acdf4001041cdbfd85fd8528fdc77f5b85e96faa81a4b6bdf3e0e9ad9aba4cad0251b53eeb5a994134b948ac08eacb00af708942e5c0ea376a7f5038763b2c164fd4a05d732185fbe843046fee99338958fee774ababab4cfbace00fd7ae51905d2d9e304a9eb99adfe61db9806d7063b71e337bae06bac3ecee6cc16f7db350ccd3f65c4413c450ce237e68388f49c97ee4dfa8348af61f8f591d85c9624b4783a140b0656545237ed24f9b8ab0abd4bd72bd62f0440fc5beab9add337abb748c7db12959ea3903863ab0564062be9f23ce6600ff1943a8978f1f2e45dd7952f489ffa5ddae284da9499da0ce93b47f301a301739df74c52dbe87d8decf3c05d96c45009dc4b4a65d919e9700c1a255e0ed70343d5689f6b1a8b946faf7e44f94849ea20edad1d4e165720fff5054d13353a9ec06f3629583fb965eb1d5dd2bf7e61b8afce8986735f0b11131d096d0fda4b3abf09aa9b9055509aaa20ea39f5b57bc3442fe20ac1c43ad0f803cdcadd3087060b72ee08ca78539b956d7f7b4654e7528f6bcdf7cb50e8b136355ac6fdd7bba95df5eaae30f8ec3b70ffb4a99034bfb2c57732ea9aebe402a8137ff5626fa0f6af3e7bb646022134ee465c2464837cdc890b34a71ebe9f9d50a6b3591990c4f5052180e1c50f70b6953d3a2653cf0e853d2c9280840b50790182c7e8aa09e9d6d6b68184b99a2938d48e0339bc4e2405f7f09303e6bd286f9894ce3786b074a60aaff4ab1028be93b0a9e600e679d08f6a4537c9abf57b7ef4ba2e05e9d39d4ea2b610e1b2bc3ac4cf6d55c92308fe8d0cf6d14a40b22b7ac9b5e0d4cc463b7667d9e39a1db0f00fee74a7a8a82029a0f175e970ed077bf1cb4960f22a04a7f60d1327e150e12c084d4fc2ec5a3680e44c0b9602b0239de9efa8a1a4efdfce6ec7650cfc1cd6e684876f2c1487e1c2286fe268940c98cf051bf3e64b76811118839de26d6b464b283fb9d936c67b3d7824a3987dafecb0606ed8f8f70f3b526872057566009fa6218994d41ae9059d05c2e4f0625b4cd80bc9ad95cbe28a9e1e4d94dda07a38925d38e3a8bc9ed533d1ca9b682021a7d517400a1742f76709bceff7dc79e2ed030d657d75b0a05ad74779b0e19409433224a57a7e48ed287b0330b8b9014b2b4b271212d3b46ac93b1e916cd125e539adcf086a76a629cc43cdcd59ac2674b22cc07ba4ed3cfc9e3fdb87c8728e312258d836487959c11ae2f876627059360290f22b3665258fbe78e8f8484284ef9aee1015cc7ec486a49d9e1285fe35e674c51021a025ca9eb904e539777a319685cbc135eb83495f691e0511aabe1a49091c8f84e81cb9758ff1a165b664216f462215dd9333986208816dae49c17b4f0dd19db74ce8983ca49b0f111e38ef880212e950259e3c64528eb944aff66ca35aaf6ed01985afc1e4789776255a6968356009099eb2834ad93807ce3afbba15cd8b5e5e4ac3fa67a17c087fd7c7a087030dc496d5d233d2a633fe2f26e68f7b5d72959110bac8fa703c5127b3e8c0b6c2b3a84d92e887752c078ff5aaf99bb7ab4da786dd4e6618b221882c051ff3d0593bca2cae9602418564a521235aef4d7d2fe02aa38d1ff9135960d2d2c7a288f6f79d4b4d24ec466639cc7cb643e5674e22662acc3df1958e876f14df608bdcc0d9bcc7b2e53f76dadcb48333e288e79b85a97f877fd0f678f32ec8c0c96b108165a8e6c3793ecb5a6f2733e36576ea6e6591ac836655a04d4bd94bb3cbc071ccfc16f6e075b906c780c1e1865d83c4067aca24641b121c30576952ff33928fd9d766fdde5acea67184358cbf9d7148e062d8afb2cbd844fe11e023ed79f919803854beea9621b49a8998280dbedce6e34cc34cc95744cf2f556f1ea99b9e9eb49736fb6b2eb8c5cf6ae2eb674fd0d2b7a675a7618a33183ed8ab38a6a5923fb0c44941be82536663e579bb8cbbc9ee2f3637528726271566edca203d763c3ce0ee5702d66e62e0b6f7de13ec96594a3a3e4e344356348c823ee399f59b0b05d5d63e8d133fe354a7d43f8bec16d51ccfab6b8e9c6f217991fd673a3b12dbd8ae3c965bfcb40263f1d12140745e0d26822b87ae9e8b83912dc0b277d737d09fce755816e08de4daa1fb66dd21622494a1109e46891045541114de43252d4691bd8f18e81fb9fc06dc418055c05407b0a36a1a5bb65ded09a76d83b29f4c644bf52319f0f3010c58c1a16fd8b587c7f22f327f51f1399d0da2eb8965116469fb6be538005142e390fa3d573130a0d93ff86b3d259b292c0c05502344e0252e91817c2c483652469ce6d6d6899c19c2154e64a8f7d2555e87c4069e3596f8cb0a98d4eae9292050bae209b0c497bfc0c55a02aabdc297834cbd90aee9d5b1fef2d1f95e431d7b54203d930bac7bf2ebff1812731d14ab7f9dcb9a92b3fea27cc2d9c417aea45fe257f622ec41d6ee74fc31a8b9e52fa0c3b818c8da4b7f0103f3e0f5ac0f4d0d006e93b338ac3d4b95e376fd3be669d950622fff81eec1a7b9cf999f0afc3c47dc4a0b1406996f76624c99f26c66efa93afde55d9dcf8b05a4cbfea7feb33f2244f9e2c291deead70884a521d53a2e17c0197d8114720958a74290cfc9be79396b99f45cf6c31499e1dfc3749c4c02c69929579c60da882c77c11d91c13e0c6742d4b7d79e143001b763a08a7ed74dfeadfb3d65d31a1a1c33a10c4c2a25bdd01317e29a3c1799867d5148cb00391b17ca46809fb89860a0f777b051db79994c91ad1665994882a6a38ac3ecd6852e174b14ce3598fa9e3cf652fb655564e1bb4c0fd63091d9642daa9caacc126b6603de56135e39d28b83200211727d40eb50d97916a4b003871efba353b454353d13ff10e28400e06829f083b3a1edcafe80d86139a7565897bd2dac847e1cf3c3355d559e97348954bd92adae0224fe8727e4658cea8bcfd78d5cf2a6efd096d47b6556d8961ca99d1a77e62eef80d6942da5230b5b9213b81f1c7f73e16b28724993e65dee075ed527ac618a6d91872e3da6c061c7552e9ad84e3cb26d082052d87db44e770eaa8b15394ec008330be52e7d1674f99253157303de708bceb930258fa65a4f4a4f7c9a6c364036459eb13617335ca9debc45f28534343c4ff16260bfb90e9eba6b1447ac62675a306491a3e7f88a4161e8d5dacb3a2734890e0d56c7f578690a7103e3bbd8a64de51b4d9041d0720596ad9464c9ff8b9ee192e3acc2e53328bf664e580702934e2afff2c561d9690194ec8a97484a5361a8c198736365a807e8a129d8e5d8db16098319de8025d33663bd8e649a8757415a501629e16f3864ee4bb297d1bfeaada61a277fe2e6f12d9d171787b2444d3e60ad34e81072af11df24bfc81a77da985c4544fbe23808e8e1d5fb94a2500584eabd2560004cf5e13b2f8dd66b1057ab9d42d1b1ac9e594b84c7c4dcaaa3444cada31f7cb4d6e933c45e32c526cff4e5f0feeb50e739abcd1d12279c0455489d1f5485500fff4d6990dd93c2621326702b512ed04e24bc810b2bff8b7620af8bf7e2c93db1ec2c8c3fa70f3114b9bc32622d3b4d78d2aabcdeb46966ff3ad43482ff22451d57a3e9f4d57df34aee663d656f9bc13fe3f9e60980de34a054c10a3e7a3731864dd9fbe0786f873223c9f38d355cc647b63d43ad6a2cad40ed2b700938d0e8128c6f5f64908f1f34aa2991bbeef1e4cded7b75458101a4b8ae30731eaf3da26895aaa3b173843b8cc57a4608ea79ab5a510638345beb0bc0bc1c2f934a748fe5aa43232f5b5aabc17e089cf7d042e49bc53c2a8ff08534d8e63715881098ba18780c51b977dde9cbdb4da6fc9b568af1ceb3900d839afbf56758ae348d8c217e23db2c69d6cc4b0fdef432ab46740e378c61eb856edb6eba8e8d4c895bd83d778976538bb59547d0ce2bb5f875fb289fb89153979b42d06dbf580143de3b78930894e863e011de196cf3d113f56dac7f7b507a76592e921806e546119d95789bbc11dca82aa995eb7e2df99f9cfff9e05c2541ae6cbc3276de3107087441567dd361a598486c7efb08938cac37cc26c686f8335fb1167a2f1d44bb893c3eac40cfbcc6c208e70694feac4a6756b8a3ae85a8580786fc82d9999c9310c09949979964f96cc2ade5e72586cc118969a642bbf5080afd313ab39df4d84ddcb6527234f0543bd8cf390821c477257e74680061585a7ebf9893e2981ef651f747f53a7927983e8d39925ca97be22a15f42c264cdbdec09d0764cdbb3522e33045b29de046e6508de235b9f4309494f7116b9a7f7d2e0f9c07a98db8669f42a26506e414f431f132837a0e2b9f045416a161d652a2ca6f1720f57365b4f2d09d7a0c7aae32e648c7f05c2ef7fcd369d92f042fe42800dacd8ab8a1a5fc01c894b95dc9ab59c4436449c58d9ac89b475eb9c21fe78b6cc153da4bd378432260c7bb80ac87164f9e8238f20e3cb75605bc5d68a43af3f8c18dd898746e7d4b025d3498d3836a8e58a4bea40daefc5057648341a80e91a02b036c41687bec2800ff76aaba2b9767fddfd679eb42769dcf7baf1d8d1e7e15f176b3a00be543827d0ae97e5cd4588ad7dc6df1a4c69bc2090ad012c8ce0f66b9b3c9d133fbdcd818271d8e71d262246d16fec4068be48d3facc25738265499fdac4d1d61f1d4950e3de4aab8506f32c880929c721c8d0d72cc5d00d7f3c6c9731d71a1f2e3365e4ba93ec3eab74385b91551e4ec76a71fc9eaa745ec5bc0dc7ffedce481be0a4d681f6a9dba4af3f9e336331c9cdfc6944febcee7a566bbfc1b97e0fe5356ff17721c46cd4bce7023314ae3a4b216ac597d7fca9402872c4373193e06f505c2cfff5dcd8b24c5ab1fad5b1b4668c6929fcd1153e06634dacf4a87811c321961d6b44aca15682fe8f81fff3164793ee5709bbf207b28c0db8162edf4027a8f1274133b148feb9908b6308dc88be4c7cb5e011853f386c65b698907bd1bf6bfb46441daa3e4ab524fd9993e6f1f21bbde67d9c8d72b4d36b563d9630514c68e024b6d8c9ed1e0bdc65122557252710730271eb215ec203579b16273e63bccf3a61a87d6297e9b724ff125aed70524dd1014ff2a2420ae61e0d6b0c4b6e27f0e53a450acd9bd9734cd31c9f32f8306c1bc30f12d3090629704e15a18372d33dd6179ed5ba04fd572f97bbd1f497b2d4f31870ebc1166244bd0539d5609ed937f2202c76fef3dfc0ec1f995af56b25811b0c38ade7390b3569172710504cc4cb6e871fa6f0c7b171998cad7884ef76f9f389c001a85c4c1c9498febc4cfefc6aeeb7daac43926322c62d25b1ae1258c229de2b4e24fa8355cdd16a9739719af589d1ba9c9ce7170f55a3426e6dbd40bc01edcb10ca0b6179fa0a47512f4fd77e6f87090a790accfaac88b866f7f1bd2fe63a98748c97947bb3605ff390c696ff0a7b369106434426b4047ea808eda0094053c7b054932057e62a43b6569fc6f594f02ab8268e189ba8caac69be1b9239a92778e3216a4843c438b647abe8dbc6f8cda53b10ab0e7729a20980a93705d08627d9577451c769400a3ff29d882f3edb4ca9b7f02b035d093c181db4a91936c2e31b5e52de1b06ed619b00eddb1cc01ff01caec03df5a4320a8dede12305ecad6d3b7959abfb3cca1e70b1f54132a3822d53a81be8806f78ffe793e3458fcdc14bc2fcf899bec9fbb6e619bb068765cc998f7975d8d6086cc6713e85527b4b590d08303d01e72b5d7d39d356615e689b2d60018e38979d18f05dd8311bb27cf86803fbf16ce441a71d2923bc77558ae2f0d78456aad749206cb31709c9ae5e9f173d09512f71931ec3617042b618881737af2f85cdc71734a3580f9d516ddc1f416dfc03b45ca92851e7ab1ac64a21bb8fbf4096939edff5e484291dcab75681b87b42988c6f77a6f1ffaf32480e81b7369888193f159eaeb49f6468653ee6924cc8e56fea349444f65636bd2989a7ab2d7111871c9f24696e67d3469c7d979e195c555ca1c242863c7911258a15400e16e53c27b09779bfe0038cc88cbbbe6636aabfd276a625d20715bda46e24c17589a1339a5d9bb773ce47325871cc7444153a0b467b61c9a2480b8e1651b8bd138e72216dd9577e4dd67753345b69ff44ffc80ac9b124fbd41dcdd29316980e0542e9b3be1cd68c1b1189c19fd41c61dd9113d92b6a88e6a1ec90564b27c5aea0041b5c90919762692f4e299768bbdb38f51ab3a26804d1d5c75667bdd2ce85350bdd08d668d6571beb79156d436309b1e155964db67451b7c0ce29a6ab799f3f52c6ce09436ba7b5f359a218fbee3b9ec871b693cb938ed2e3d28c0f67a7ae4603c6c8d3d9feb673c8d1937766abc8f35174744024f0e3c596c2d69ed71a342ab87082ddf85c8875e77adef3c98fb935bfac2d1646bec2b1da44ee5897f36035eac9b03beea619dafa44a94a0fefa437e8390d296e07c529f1b9d993b72224b7419ea04a6071c1259a90c4c8fa9d20eb66190aa161807cd23b4aad116e49bff9898f36577cbcbeec93d9bcb8159df16752423b0090cec7a8213262dc81e5aad168bc7a86e1a4ae210d7994176fefdfc121965db7a0e563edaac67ff4546cd87f760842cc4ab66a35c9ad16a9c84c69b8d7541bff9d27c417970ba59be3626cea75c40cb53e1ffa2cb5fb9862d5008230cfe4fd458cd6d93f3cbd319b3e5cc1c7fd907fa61f49429c37f88eb775c31794f373fae2628366dccbab80d035dfe39144f5168b21859fa443173beae585c2208fed4f7a7b6f16618f39c28032f0ee8ef240253e0d802bda30d8a921f88d1e7c60ddb37d574de4baaa91dd60a464b77b75456ba585c3d6866c33054405946bc2416626fbeaa5219097905da20ad9baf12b8f96c66d3d438d49b86018ddc43b675b053079f1b1a1ad2d56bd428dd513decc7caf8ab5ed568e5d45c890b3ecc4f6f318c4130e068ae7bf86d39865a5ff735a35922b2e4910a64012b9b941fec2200e2656a27de15361deaba9da47a1556b050547b77cc0ccdf57ced0df4597781a18e7180b5a8c794700c4cbadf0c221bf066c8b2225dded4bdbf4a9e84bf3b2c90892ec5794c6f58987820798e69965b3d3e33c17a193b65ec7cd110b5b3499d599d2011070606e08698b5d570f0dc6b974def5cf746cfda570e2a6deccdaf7ff42e0c398df383dcd6ee504969cf1dd80ea3d9387ae9c7ee2c038502a55bd638be37d6f2be7e49111b8cc30ad1c75d324b771357ba2a646ce7b21102a5db9d284df63e4d74b733df95589e8a4205d115ecf3ad10178788de9d635ad29c65ba8837c9579d4f733390a25c72d83a8f8f8ce14014697bc64c64299e624e5ee6d6805c2340f75e44e5d9c4631652172f10dc940b34816bac659d43c680dcd0a37b54c0aeaa9d07175e86c60de7c76e9f2884a256217bef922598dfd5dcc6cbede01e9fe8eaa8a72145e55189fc599adcd695cc53cac178620b2a8388bf5045bc2f2ae23e6e0ebceab88d7c4020f90e1d11fef02aadecc17c2e4816fc7de7af8482c05b1edd7e2e18a8fd5334d83c242938373861d129b4b291e74d6661321327c636f9b83ac3204bf48f72e863141e07982b185f4fc9021ff7dc014c050ab495a7abf3c3aa8de24bf76d29606908921e0ffcd56556a6f82c3da1ee35242a62bda8a595a543b2933ed11616aca4a0b2980e8a82f348efc6d7887f129ec06ea8751270e6998ae50efb350ffd81e12fd85115e37c90e4bbc3a70eb2bdaa0743c77421c5aea773c490d9adfbc645d299e1b4976f5cbf76e1e6375e5fc3e8e4963574a325cd18b2cbcef4c8e89afa76c224db22541ce54542980f91d4dacb5d4cdf84086100ba0a3b976cfd8d4f34a781d5393ce70f4f5a88114a07c03f0750e58f2c30c6e3ad87cea1ea79658e415eb826a1ef82e0798e94f3a874b71b1d3d32c93be982f0076a4c372fdd534ca47e36a6700d43fe502714999945d4b9a547f5996e353ad3e9faf246b36ba58ae8bb054c93e70e91d58294328c0c287aa1a6ae2d91c7382be7e56550dde348cf4e0795a60a48d44d89add1c34de5b3bc0d02f9b2f7c1b44f8b972c9f84fe3d1ecdb872d03affb1cb48f0274b4cdf57da322e45a80d4a9bd31494f5b65e0bf696fe3cd1f06961436152cdf75ca3572f599d104b755c1c8c93d7fc50921f4aeff083127eea2be44cb9cc17f7eca1a3014435ab3890edea63d27d615d9764c7e17ae2cc3b2d8915d562c91d90fa7e936007bc75b4c5b7304ed78be2504ee048b590d3a6335b26a70afa9f322c0cd858253f0e896bc58c7b6bb0064db744621ec1c955ccf0c605f50f8b1a1abe1176ea0d11010bb1acde58fefbc8f1de0c59045d8371c68ef92900aee7b56098c2ce86eb0553e22246561c5d40e427af56dc3d0708f3c6f8053afb430e6f4c62b1dcb3f71b8901dd7b99cf5c451c92dad23f68e086dee7a47dd3b8ec0ee58d7bd02b26cf401dd57a2dbe62565c231bd1ca255aa9d3fbcc403bffc42aae52470418c6531d78ac77948af6a66af6085c884b3b16aebf482d1d57b11e18167d51152d44bdad63fcacb8194c53c3011e351bc7197e1a18830e38a951db77037541799f4011c8940264bab7996254e084827ee159b5eed5da659cb65c04ad184127b263fc2e19c12d721cd42c2131200802af523d021429b2ece9c1225c9ad9a6a02363f1119d4a0de9478961712ed7a4efd6aed660b1371a64d3d5ffc467a409fddd473c440ffdbc1793a73d4083d8df7b972f33b371d0829f26523fa3cb114cdfde2876770d94c23e2f52ed3974cdff6ee91c443ae6315958278af65a423fcb25b9aad8a4fdf5f31bc5d54c75401651f6d0e301e515841ae5adde993794ea058f1ed8a0614fd04e4624bd5fbf87775aa371f87f87c00dc842fac4f5431a67f5f67eebed3df87a954761e57c29c7184768e8c0a3d7f8541c9e81322ba4e9c369236ae10a250b50d9edb0eacaf49f537dce7572acab11f79cc5de582d415648a1da340b453a12d176d0a0145c0b9c5e0f70bf29942b5ab3a4f0b866f5dd567f60b18c27a55009d7808988dbb2b5d10e56ad46f0833e993f7b81b882570349c8e234c096ea2d0ac25bf2c793080d3c6a63bb1aee85509c94c21ffd9f27dd3324d9a92e33b30112b14651c90c4ed9d822ca4fca4e12fa83da8e357a27175ff392a1ab187cd84ba37adda97f5ce7c8810703aa936ac3995f71af79f12c9d292f20307ea2d7dc75a5e53129516941137cb099f9f25fda120292385efd323ffe2eac477a34513358f74b380cdcf77e8abaf65b4d17dd2a24472141c8c5b99e153831fc64beeb4d2dad25efbe2b4e7270fe96c3441158af56bf8199a4ca33e9bd26078262d96af1014237c76a798047576aeb6ceb1cd4e853dd0299719a5cca00708110f619e656e9422d43c4edfc0226ca0197536c945f3784519908927faf4686fd281733c396419953483ea7fdfa8a2a2bae86dce81dc4b45f14d575a3e02aa2dead043dbca6cd3f89692c5ece4b9864882940601655e9cabe06b291bd980c2e597d4ad5ad5a0f4bd34afcda6386fdd51af52a7e4aa969c3aba3ed98cf2ace99e459eae3eeb5f0f58d7aa59f600af1fa15155438643fc0c84e87bd1b233e5ebbfd7f382453c6566c249912b3d7025ef2027261f65f2b69029f7919841e05926cf76b79684f035aec8df03ca1401af1e7644bd650f7d8b135303fa13b739adf590ae2d3b951b2f408fe4d9160c242a25cdc8e695b63e296865e897aa861f9810212243e2e2585b3c7cbbc62b21f06b9e3ec6f46ed2ac121cae49b0e0974453eceed5e3427cc11ec687a204aa68066a1a9fc013db4468a20ba5ed3d2de8f6ffcfe0242092b07ef3b616d98549aa49b245483b1d4c849f572c73c8de4f5fa39ae5c643039792baf91648febd101bc0b9d17af28cb4270f6ab73eaf761d32c5fb0f25a65b54dc83c32d6180161bb4494c255ef7975609fec16a5bbfa12fc11f8fa6db3436ab7c93a6c9553852931b9c4c0490b6fb401d072df1525653332d2c65f679b962a2557cb97bdcbc927cfd9bb15a2fdb2cefc814c54bf8f46906c5d06645af1521793928d637c8abe51b5c91b9690ab1c1ea3bbdc6572e373d9153e7b552475d6588f202c12a104ce8ba915741d12292ff5e5574be80c471629b2ba634cb1091cb963a0b2e6ff4bf48e3dabf90fdf114b1bded4fffe3019b097f367542b4276a90468e0b0cac399cb2115709da24bbb3fda4137bcad07d7e9cdbafbeb5ae4fdd098e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
    <tags>
      
      <tag>博客搭建优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
